<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>匆匆</title>
    <url>/2019/12/13/debbie/</url>
    <content><![CDATA[<p><span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<span id="more"></span>

<p><em><strong>The sun shines through the kitchen, and we are making love, feel like the rest of the world doesn’t exit any more and I finally understand the meaning of eternity.</strong></em>  </p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>love</tag>
        <tag>debbie</tag>
      </tags>
  </entry>
  <entry>
    <title>jq使用</title>
    <url>/2021/05/31/jq/</url>
    <content><![CDATA[<p>使用<code>json</code>做客制化配置，一开始每份客制化用一份<code>json</code>配置，直接用复制替换的方式切换，虽然不高明但是很实用。后来领导的要求越来越花哨，大致需要先去解析<code>json</code>的内容，然后再去客制化，这里记录过程中用到的<code>jq</code>操作，方便以后有类似需求时直接参考。<br>官方文档在<a href="https://stedolan.github.io/jq/manual/">这里</a>  ，虽然是英文，但是还算方便，虽说不一定看懂。</p>
<span id="more"></span>


<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>较简单使用</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat built.json | jq <span class="comment"># 不使用过滤器，则原样输出</span></span><br><span class="line">$ cat built.json | jq <span class="string">'.'</span> <span class="comment"># 使用 . 过滤器获取 key 的值，这里原样输出</span></span><br><span class="line">$ jq <span class="string">'.'</span> built.json <span class="comment"># 使用 . 过滤器获取 key 的值，这里原厂输出</span></span><br><span class="line">$ jq <span class="string">'.config.built'</span> built.json <span class="comment"># 使用 . 过滤器获取 key 的值</span></span><br><span class="line">$ jq <span class="string">'.config.built.fw_builtdate | tonumber'</span> built.json <span class="comment"># 将格式正确的字符串转换成对应的数字</span></span><br><span class="line">$ jq -c <span class="string">'.'</span> built.json <span class="comment"># 将json在一行输出</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>简单使用</p>
<ul>
<li><p><code>--slurp/-s</code>参数</p>
<blockquote>
<p>Instead of running the filter for each JSON object in the input, read the entire input stream into a large array and run the filter just once.</p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ jq -s <span class="string">'.[0] * .[1]'</span> built.json irmap.json <span class="comment"># 将两份json合并</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>--argjson</code>参数</p>
<p>将一个<code>json</code>对象给变量赋值。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">SMARTTVJSON=smarttv/smarttv.json</span><br><span class="line">jq -n --argjson order <span class="string">"<span class="subst">$(&lt;<span class="string">"<span class="variable">${SMARTTVJSON}</span>"</span>)</span>"</span> <span class="string">'{"smarttv":null} | .smarttv = $order'</span> &gt; smarttv.json</span><br></pre></td></tr></tbody></table></figure>

<p>将smarttv.json的内容，转换成<code>json</code>对象，然后把这个<code>json</code>对象，赋给变量order；</p>
<p>过滤器添加一个smarttv的空key，接着把变量order的值给到smarttv这个key；</p>
<p>最后把处理后的数据重定向到一个<code>json</code>文件。</p>
</li>
<li><p><code>--slurpfile</code>参数</p>
<p>将一个<code>json</code>文件给变量赋值。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">COMMON_JSON=public/public.json</span><br><span class="line">ORDER_JSON=order/order.json</span><br><span class="line">jq --slurpfile public <span class="variable">${COMMON_JSON}</span> <span class="string">'paths(scalars) as $order | $public[] | getpath($order)'</span> <span class="variable">${ORDER_JSON}</span></span><br></pre></td></tr></tbody></table></figure>

<p>将public.json文件，赋给变量public；</p>
<p>过滤器，将order.json文件的非null（这个不太理解，只是刚好功能OK）的key的路径赋给order变量，然后拿到public.json对应的这些路径的key的值（如果是null，说明public.json没有这个key）。</p>
<p>过滤器这样设计，是要找出order.json里比public.json多的有效值（这个key的值不是null）。</p>
<p><code>paths(scalars)</code>在<code>builtin.jq</code>里的定义：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">def scalars: select(<span class="built_in">type</span>|. != <span class="string">"array"</span> and . != <span class="string">"object"</span>);</span><br><span class="line">def paths(node_filter): . as <span class="variable">$dot</span>|paths|select(. as <span class="variable">$p</span>|<span class="variable">$dot</span>|getpath(<span class="variable">$p</span>)|node_filter);</span><br><span class="line">def leaf_paths: paths(scalars);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>-f</code>参数</p>
<p>从文件中读取过滤器。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">jq -f mergeorder.jq -s public.json order.json &gt; order.json</span><br></pre></td></tr></tbody></table></figure>

<p>过滤器mergeorder.jq内容如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">def mergeorder(a;b):</span><br><span class="line">    reduce b[] as <span class="variable">$item</span> (a;</span><br><span class="line">        reduce (<span class="variable">$item</span> | keys_unsorted[]) as <span class="variable">$key</span> (.;</span><br><span class="line">            <span class="variable">$item</span>[<span class="variable">$key</span>] as <span class="variable">$val</span> | (<span class="variable">$val</span> | <span class="built_in">type</span>) as <span class="variable">$type</span> | .[<span class="variable">$key</span>] = <span class="keyword">if</span> (<span class="variable">$type</span> == <span class="string">"object"</span>) <span class="keyword">then</span></span><br><span class="line">            mergeorder({}; [<span class="keyword">if</span> .[<span class="variable">$key</span>] == null <span class="keyword">then</span> {} <span class="keyword">else</span> .[<span class="variable">$key</span>] end, <span class="variable">$val</span>])</span><br><span class="line">            <span class="keyword">elif</span> (<span class="variable">$type</span> == <span class="string">"null"</span>) <span class="keyword">then</span></span><br><span class="line">            .[<span class="variable">$key</span>]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="variable">$val</span></span><br><span class="line">            end)</span><br><span class="line">        );</span><br><span class="line">    mergeorder({}; .)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://cloud.tencent.com/developer/ask/40577">如何使用JQ合并2个 JSON文件？</a></p>
<p><a href="https://stackoverflow.com/questions/66024299/how-to-merge-two-json-files-using-jq-or-any-tool">How to merge two JSON files using jq or any tool?</a></p>
<p><a href="https://stackoverflow.com/questions/19529688/how-to-merge-2-json-objects-from-2-files-using-jq">How to merge 2 JSON objects from 2 files using jq?</a></p>
<p><a href="https://justcode.ikeepstudying.com/2018/02/shell%EF%BC%9A%E6%97%A0%E6%AF%94%E5%BC%BA%E5%A4%A7%E7%9A%84shell%E4%B9%8Bjson%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7jq-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90json-jq%E8%A7%A3%E6%9E%90-json/">Shell：无比强大的shell之json解析工具jq , Linux命令行解析json, jq解析 json 实例</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/7565371.html">JSON格式化输出和解析工具 - jq</a></p>
<p><a href="https://e.printstacktrace.blog/merging-json-files-recursively-in-the-command-line/">Merging JSON files recursively in the command-line</a></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/uIKvYgix-L4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe> 

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell</title>
    <url>/2021/02/24/linux-shell/</url>
    <content><![CDATA[<p><span class="github-emoji"><span>💲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  </p>
<span id="more"></span>


<h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><ul>
<li><p>session  </p>
<p>  当我们登录系统后，bash程序启动，并且会读取一系列称为启动文件的配置脚本，这些文件定义了默认的可供所有用户共享的shell环境。然后是读取更多位于我们自己家目录中的启动文件，这些启动文件定义了用户个人的shell环境。确切的启动顺序依赖于要运行的shell会话类型。有两种shell会话类型：一个是登录shell会话，另一个是非登录shell会话。    </p>
<p>  登录shell会话的启动文件：  </p>
<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/etc/profile</td>
<td align="left">应用于所有用户的全局配置脚本</td>
</tr>
<tr>
<td align="left">~/.bash_profile</td>
<td align="left">用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</td>
</tr>
<tr>
<td align="left">~/.bash_login</td>
<td align="left">如果文件 ~/.bash_profile 没有找到，bash会尝试读取这个脚本</td>
</tr>
<tr>
<td align="left">~/.profile</td>
<td align="left">如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash会试图读取这个文件。这是基于Debian发行版的默认配置，比方说Ubuntu</td>
</tr>
</tbody></table>
<p>  非登录shell会话的启动文件：  </p>
<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/etc/bash.bashrc</td>
<td align="left">应用于所有用户的全局配置文件</td>
</tr>
<tr>
<td align="left">~/.bashrc</td>
<td align="left">用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</td>
</tr>
</tbody></table>
<p>  在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。  </p>
</li>
<li><p>启动选项  </p>
<p>  为了方便debug，有时在启动Bash的时候，可以加上启动参数。<br>  <code>-n</code> - 不运行脚本，只检查是否有语法错误<br>  <code>-v</code> - 输出每一行语句运行结果前，会先输出该行语句<br>  <code>-x</code> - 每一个命令处理之前，先输出该命令，再执行该命令  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ bash -n scriptname  </span><br><span class="line">$ bash -v scriptname  </span><br><span class="line">$ bash -x scriptname  </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>变量分类  </p>
<p>  环境变量：<code>env</code>或<code>printenv</code>命令，可以显示所有环境变量；<code>set</code>命令可显示所有变量（包括环境变量和自定义变量），以及所有的Bash函数。<br>  自定义变量：局部变量、全局变量。<br>  变量命名规则：  </p>
<ul>
<li>变量名可由字母数字字符（字母和数字）和下划线字符组成  </li>
<li>变量名的第一个字符必须是一个字母或一个下划线  </li>
<li>变量名中不允许出现空格和标点符号  </li>
</ul>
</li>
<li><p>读取变量  </p>
<p>  读取变量的时候，直接在变量名前加上<code>$</code>就可以了。读取变量的时候，变量名也可以使用花括号<code>{}</code>包围，比如 $a 也可以写成 ${a} 。这种写法可以用于变量名与其他字符连用的情况。<br>  如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。  </p>
</li>
<li><p>删除变量  </p>
<p>  <code>unset</code>命令用来删除一个变量：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> NAME  </span><br></pre></td></tr></tbody></table></figure>
<p>  这个命令不是很有用。因为不存在的Bash变量一律等于空字符串，所以即使<code>unset</code>命令删除了变量，还是可以读取这个变量，值为空字符串。<br>  所以，删除一个变量，也可以将这个变量设成空字符串:  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=<span class="string">''</span>  </span><br><span class="line">$ foo=  </span><br></pre></td></tr></tbody></table></figure>
<p>  上面两种写法，都是删除了变量foo。  </p>
</li>
<li><p>输出变量：<code>export</code>命令  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NAME=value</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令执行后，当前shell及随后新建的子shell，都可以读取变量<code>$NAME</code>。子shell如果修改继承的变量，不会影响父shell。  </p>
</li>
<li><p>特殊变量（包含位置参数）  </p>
<ul>
<li><code>$?</code> - 上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是0，表示上一个命令执行成功；如果是非零，上一个命令执行失败  </li>
<li><code>$$</code> - 当前shell的进程ID  </li>
<li><code>$_</code> - 上一个命令的最后一个参数  </li>
<li><code>$!</code> - 最近一个后台执行的异步命令的进程ID  </li>
<li><code>$0</code> - 当前shell的名称，脚本文件名  </li>
<li><code>$1</code>到<code>$9</code> - 对应脚本的第一个参数到第九个参数。通过参数展开方式可以访问的参数个数多于9个。只要指定一个大于9的数字，用花括号括起来就可以，例如 ${10}、${55}、${211} 等  </li>
<li><code>$-</code> - 当前shell的启动参数  </li>
<li><code>$#</code> - 参数的总和  </li>
<li><code>$@</code> - 全部的参数。当它被用双引号引起来的时候， 它把每一个位置参数展开成一个由双引号引起来的分开的字符串  </li>
<li><code>$*</code> - 全部的参数。当它被用双引号引起来的时候，展开成一个由双引号引起来的字符串，包含了所有的位置参数，每个位置参数由shell变量<code>$IFS</code>值的第一个字符分隔开，默认为空格，但是可以自定义  </li>
</ul>
</li>
</ul>
<ul>
<li><p>变量的默认值  </p>
<ul>
<li><code>${varname:-word}</code>：如果变量varname存在且不为空，则返回它的值，否则返回word。它的目的是返回一个默认值，比如${count:-0}表示变量count不存在时返回0。  </li>
<li><code>${varname:=word}</code>：上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则将它设为word，并且返回word。它的目的是设置变量的默认值，比如${count:=0}表示变量count不存在时返回0，且将count设为0。  </li>
<li> <code>${varname:+word}</code>：上面语法的含义是，如果变量名存在且不为空，则返回word，否则返回空值。它的目的是测试变量是否存在，比如${count:+1}表示变量count存在时返回1（表示true），否则返回空值。  </li>
<li> <code>${varname:?message}</code>：上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则打印出varname: message，并中断脚本的执行。如果省略了message，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如${count:?”undefined!”}表示变量count未定义时就中断执行，抛出错误，返回给定的报错信息undefined!。  </li>
</ul>
<p>  上面四种语法如果用在脚本中，变量名的部分可以用数字1到9，表示脚本的参数。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">filename=<span class="variable">${1:?"filename missing."}</span></span><br></pre></td></tr></tbody></table></figure>
<p>  上面代码出现在脚本中，1表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。  </p>
</li>
<li><p>其他  </p>
<ul>
<li><code>declare</code> - 声明一些特殊类型的变量，为变量设置一些限制。  </li>
<li><code>readonly</code> - 等同于<code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能<code>unset</code>变量。  </li>
<li><code>let</code> - 声明变量时，可以直接执行算术表达式：    <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">let</span> foo=1+2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>Bash 函数定义的语法有两种。    <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="function"><span class="title">fn</span></span>() {</span><br><span class="line"><span class="comment"># codes</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() {</span><br><span class="line"><span class="comment"># codes</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>如果函数与脚本、别名同名，优先级：别名&gt;函数&gt;脚本。  </li>
<li>参数变量：与脚本的参数变量是一致的。  </li>
<li>调用时，就直接写函数名，参数跟在函数名后面。  </li>
<li>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。  </li>
<li>函数里面可以用<code>local</code>命令声明局部变量。  </li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>创建数组  </p>
<p>  逐个赋值：ARRAY[INDEX]=value<br>  一次性赋值：ARRAY=(value1 value2 … valueN)  </p>
<p>  定义数组时，可以使用通配符：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mp3s=( *.mp3 )</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，将当前目录的所有MP3文件，放进一个数组。  </p>
<p>  还可以通过指定下标，把值赋给数组中的特定元素：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)  </span><br></pre></td></tr></tbody></table></figure>
<p>  先用<code>declare -a</code>命令声明一个数组，也是可以的：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -a ARRAYNAME</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>read -a</code>命令则是将用户的命令行输入，读入一个数组：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -a dice</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令将用户的命令行输入，读入数组dice。  </p>
</li>
<li><p>读取数组  </p>
<p>  读取单个元素：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">${array[i]}</span>   <span class="comment"># i 是索引</span></span><br></pre></td></tr></tbody></table></figure>
<p>  读取所有成员：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>@</code>和<code>*</code>是数组的特殊索引，表示返回数组的所有成员。  </p>
<p>  遍历数组:  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">${names[@]}</span>"</span>; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  <code>@</code>和<code>*</code>放不放在双引号之中，是有差别的。  </p>
<p>  拷贝一个数组的最方便方法，就是写成下面这样：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hobbies=( <span class="string">"<span class="variable">${activities[@]}</span>"</span> )</span><br></pre></td></tr></tbody></table></figure>
<p>  这种写法也可以用来为新数组添加成员：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hobbies=( <span class="string">"<span class="variable">${activities[@]" diving )</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>默认位置  </p>
<p>  如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用0号位置。  </p>
</li>
<li><p>数组的长度  </p>
<p>  要想知道数组的长度（即一共包含多少成员），可以使用下面两种语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">${#array[*]}</span></span><br><span class="line"><span class="variable">${#array[@]}</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>提取数组序号  </p>
<p>  <code>${!array[@]}</code>或<code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。  </p>
</li>
<li><p>提取数组成员  </p>
<p>  <code>${array[@]:position:length}</code>的语法可以提取数组成员。<br>  如果省略长度参数length，则返回从指定位置开始的所有成员。  </p>
</li>
<li><p>追加数组成员  </p>
<p>  数组末尾追加成员，可以使用<code>+=</code>赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=(a b c)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line">$ foo+=(d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>删除数组  </p>
<p>  删除一个数组成员，使用<code>unset</code>命令：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">unset</span> foo[2]</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b d e f</span><br></pre></td></tr></tbody></table></figure>
<p>  将某个成员设为空值，可以从返回值中“隐藏”这个成员。<br>  直接将数组变量赋值为空字符串，相当于“隐藏”数组的第一个成员。<br>  <code>unset ArrayName</code>可以清空整个数组。  </p>
</li>
<li><p>关联数组  </p>
<p>  关联数组使用字符串而不是整数作为数组索引。<br>  <code>declare -A</code>可以声明关联数组。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -A colors</span><br><span class="line">$ colors[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">$ colors[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">$ colors[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br></pre></td></tr></tbody></table></figure>
<p>  整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有<code>-A</code>选项的<code>declare</code>命令声明创建。  </p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>字符串的长度  </p>
<p>  获取字符串长度的语法如下：<code>${#varname}</code>。  </p>
</li>
<li><p>子字符串  </p>
<p>  字符串提取子串的语法如下：<code>${varname:offset:length}</code>。<br>  这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hello=<span class="string">'abcdefg'</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${hello:2:3}</span></span><br></pre></td></tr></tbody></table></figure>
<p>  如果省略length，则从位置offset开始，一直返回到字符串的结尾。<br>  如果offset为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格，以防止与<code>${variable:-word}</code>的变量的设置默认值语法混淆。此时还可以指定length，length可以是正值，也可以是负值（负值不能超过offset的长度）。  </p>
</li>
<li><p>切割和替换  </p>
<ul>
<li><p>字符串头部的模式匹配  </p>
<p>  <code>${variable#pattern}</code> - 如果 pattern 匹配变量 variable 的开头，删除最短匹配（非贪婪匹配）的部分，返回剩余部分<br>  <code>${variable##pattern}</code> - 如果 pattern 匹配变量 variable 的开头，删除最长匹配（贪婪匹配）的部分，返回剩余部分  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ myPath=/home/cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${myPath#/*/}</span></span><br><span class="line">cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${myPath##/*/}</span></span><br><span class="line">long.file.name</span><br></pre></td></tr></tbody></table></figure>

<p>  <code>${variable/#pattern/string}</code> - 将头部匹配的部分，替换成其他内容  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=JPG.JPG</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo/#JPG/jpg}</span></span><br><span class="line">jpg.JPG</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符串尾部的模式匹配  </p>
<p>  <code>${variable%pattern}</code> - 如果 pattern 匹配变量 variable 的结尾，删除最短匹配（非贪婪匹配）的部分，返回剩余部分<br>  <code>${variable%%pattern}</code> - 如果 pattern 匹配变量 variable 的结尾，删除最长匹配（贪婪匹配）的部分，返回剩余部分  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ path=/home/cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path%.*}</span></span><br><span class="line">/home/cam/book/long.file</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path%%.*}</span></span><br><span class="line">/home/cam/book/long</span><br></pre></td></tr></tbody></table></figure>

<p>  <code>${variable/%pattern/string}</code> - 将尾部匹配的部分，替换成其他内容  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=JPG.JPG</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo/%JPG/jpg}</span></span><br><span class="line">JPG.jpg</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>任意位置的模式匹配  </p>
<p>  <code>${variable/pattern/string}</code> - 如果 pattern 匹配变量 variable 的一部分，最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配<br>  <code>${variable//pattern/string}</code> - 如果 pattern 匹配变量 variable 的一部分，最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ path=/home/cam/foo/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path/foo/bar}</span></span><br><span class="line">/home/cam/bar/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path//foo/bar}</span></span><br><span class="line">/home/cam/bar/bar.name</span><br></pre></td></tr></tbody></table></figure>

<p>  如果省略了string部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ path=/home/cam/foo/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path/.*/}</span></span><br><span class="line">/home/cam/foo/foo</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>改变大小写  </p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">${parameter,,}</td>
<td align="left">把 parameter 的值全部展开成小写字母</td>
</tr>
<tr>
<td align="left">${parameter,}</td>
<td align="left">仅仅把 parameter 的第一个字符展开成小写字母</td>
</tr>
<tr>
<td align="left">${parameter^^}</td>
<td align="left">把 parameter 的值全部转换成大写字母</td>
</tr>
<tr>
<td align="left">${parameter^}</td>
<td align="left">仅仅把 parameter 的第一个字符转换成大写字母（首字母大写）</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><ul>
<li><p>算术表达式  </p>
<p>  <code>((...))</code>语法可以进行整数的算术运算：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ((foo = 5 + 5))</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">10</span><br></pre></td></tr></tbody></table></figure>
<p>  如果要读取算术运算的结果，需要在<code>((...))</code>前面加上美元符号<code>$((...))</code>，使其变成算术表达式，返回算术运算的值。<br>  <code>$((...))</code>的圆括号中，不需要在变量名之前加上<code>$</code>，不过加上也不报错。<br>  如果在<code>$((...))</code>里面使用字符串，Bash 会认为那是一个变量名，如果不存在同名变量，Bash 就会将其作为空值，而<code>$((...))</code>会将空值当做0。  </p>
<p>  逗号<code>，</code>在<code>$((...))</code>内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((foo = <span class="number">1</span> + <span class="number">2</span>, <span class="number">3</span> * <span class="number">4</span>))</span><br><span class="line">12</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>数值的进制  </p>
<p>  指定不同的数基  </p>
<table>
<thead>
<tr>
<th align="left">表示法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">number</td>
<td align="left">默认情况下，没有任何表示法的数字被看做是十进制数（以10为底）</td>
</tr>
<tr>
<td align="left">0number</td>
<td align="left">在算术表达式中，以零开头的数字被认为是八进制数</td>
</tr>
<tr>
<td align="left">0xnumber</td>
<td align="left">十六进制表示法</td>
</tr>
<tr>
<td align="left">base#number</td>
<td align="left">base进制的数</td>
</tr>
</tbody></table>
<p>  其他进制转换为10进制：</p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">0</span>xff))  </span><br><span class="line">255  </span><br><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2#11111111</span>))  </span><br><span class="line">255</span><br><span class="line">$ <span class="built_in">echo</span> $((<span class="number">8#11</span>))</span><br><span class="line">9</span><br><span class="line">$ <span class="built_in">printf</span> %d 0xFF</span><br><span class="line">$ ((num=8<span class="comment">#123))</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${num}</span></span><br><span class="line">83</span><br></pre></td></tr></tbody></table></figure>
<p>  10进制转换为其他进制：</p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"obase=16;65536"</span> | bc <span class="comment"># 利用bc计算器。echo "obase=进制;值" | bc</span></span><br><span class="line">10000</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"obase=8;65536"</span> | bc</span><br><span class="line">200000</span><br><span class="line">$ <span class="built_in">printf</span> %x 15</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ul>
<li><p>位运算  </p>
</li>
<li><p>逻辑运算  </p>
</li>
<li><p>赋值运算  </p>
</li>
<li><p>求值运算  </p>
</li>
<li><p><code>expr</code>命令  </p>
<p>  <code>expr</code>命令支持算术运算，可以不使用<code>((...))</code>语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ expr 3 + 2</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>expr</code>命令支持变量替换：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=3</span><br><span class="line">$ expr <span class="variable">$foo</span> + 2</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>expr</code>命令也不支持非整数参数。  </p>
</li>
<li><p><code>let</code>命令  </p>
<p>  <code>let</code>命令用于将算术运算的结果，赋予一个变量：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">let</span> x=2+3</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  注意，x=2+3这个式子里面不能有空格，如果包含空格，需要使用引号。  </p>
<p>  <code>let</code>可以同时对多个变量赋值，赋值表达式之间使用空格分隔：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">let</span> <span class="string">"v1 = 1"</span> <span class="string">"v2 = v1++"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$v1</span>,<span class="variable">$v2</span></span><br><span class="line">2,1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li><p><code>if</code>结构  </p>
<ul>
<li><p>语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands</span><br><span class="line">[<span class="keyword">elif</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands...]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">	commands]</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>test</code>命令  </p>
<p>  <code>if</code>结构的判断条件，一般使用<code>test</code>命令，有三种形式：  </p>
<ol>
<li><code>test expression</code>  </li>
<li><code>[ expression ]</code>  </li>
<li><code>[[ expression ]]</code>  </li>
</ol>
<p>  上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。  </p>
</li>
<li><p>判断表达式  </p>
<ol>
<li><p>文件判断</p>
<p>文件系统相关测试：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果下列条件为真则返回TRUE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-f $var</td>
<td align="left">给定的变量包含正常的文件路径或文件名</td>
</tr>
<tr>
<td align="left">-x $var</td>
<td align="left">给定的变量包含的文件可执行</td>
</tr>
<tr>
<td align="left">-d $var</td>
<td align="left">给定的变量包含的是目录</td>
</tr>
<tr>
<td align="left">-e $var</td>
<td align="left">给定的变量包含的文件存在</td>
</tr>
<tr>
<td align="left">-c $var</td>
<td align="left">给定的变量包含的是一个字符设备文件的路径</td>
</tr>
<tr>
<td align="left">-b $var</td>
<td align="left">给定的变量包含的是一个块设备文件的路径</td>
</tr>
<tr>
<td align="left">-w $var</td>
<td align="left">给定的变量包含的文件可写</td>
</tr>
<tr>
<td align="left">-r $var</td>
<td align="left">给定的变量包含的文件可读</td>
</tr>
<tr>
<td align="left">-L $var</td>
<td align="left">给定的变量包含的是一个符号链接</td>
</tr>
</tbody></table>
</li>
<li><p>字符串判断</p>
<p>字符串表达式：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果下列条件为真则返回True</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string</td>
<td align="left">string不为null</td>
</tr>
<tr>
<td align="left">-n string</td>
<td align="left">字符串string的长度大于零</td>
</tr>
<tr>
<td align="left">-z string</td>
<td align="left">字符串string的长度为零</td>
</tr>
<tr>
<td align="left">string1 = string2</td>
<td align="left">string1和string2相同。单或双等号都可以，不过双等号更受欢迎</td>
</tr>
<tr>
<td align="left">string1 == string2</td>
<td align="left">string1和string2相同。单或双等号都可以，不过双等号更受欢迎</td>
</tr>
<tr>
<td align="left">string1 != string2</td>
<td align="left">string1和string2不相同</td>
</tr>
<tr>
<td align="left">string1 &gt; string2</td>
<td align="left">string1排列在string2之后</td>
</tr>
<tr>
<td align="left">string1 &lt; string2</td>
<td align="left">string1排列在string2之前</td>
</tr>
</tbody></table>
</li>
<li><p>整数判断</p>
<p>整形表达式：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果为真…</th>
</tr>
</thead>
<tbody><tr>
<td align="left">integer1 -eq integer2</td>
<td align="left">integer1等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -ne integer2</td>
<td align="left">integer1不等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -le integer2</td>
<td align="left">integer1小于或等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -lt integer2</td>
<td align="left">integer1小于integer2</td>
</tr>
<tr>
<td align="left">integer1 -ge integer2</td>
<td align="left">integer1大于或等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -gt integer2</td>
<td align="left">integer1大于integer2</td>
</tr>
</tbody></table>
</li>
<li><p>综合表达式</p>
<p>逻辑操作符：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">测试</th>
<th align="left">[[]] and (())</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AND</td>
<td align="left">-a</td>
<td align="left">&amp;&amp;</td>
</tr>
<tr>
<td align="left">OR</td>
<td align="left">-o</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">NOT</td>
<td align="left">!</td>
<td align="left">!</td>
</tr>
</tbody></table>
</li>
<li><p>正则判断</p>
<p><code>[[ string =~ regex ]]</code>  </p>
<p>上面的语法中，<code>regex</code>是一个正则表达式，<code>=~</code>是正则比较运算符。  </p>
<p>举个例子：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">INT=-5</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$INT</span>"</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INT is an integer."</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INT is not an integer."</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>算术判断</p>
<p>Bash还提供了<code>((...))</code>作为算术条件，进行算术运算的判断。</p>
<p>注意，算术判断不需要使用<code>test</code>命令，而是直接使用<code>((...))</code>结构。这个结构的返回值，决定了判断的真伪。</p>
<p>算术条件<code>((...))</code>也可以用于变量赋值：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="keyword">if</span> (( foo = 5 ));<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"foo is <span class="variable">$foo</span>"</span>; <span class="keyword">fi</span></span><br><span class="line">foo is 5</span><br></pre></td></tr></tbody></table></figure>

<p>上面例子中，(( foo = 5 ))完成了两件事情。首先把5赋值给变量foo，然后根据返回值5，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是0，则判断为假。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>case</code>结构  </p>
<p>  语法如下：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">  pattern )</span><br><span class="line">	commands ;;</span><br><span class="line">  pattern )</span><br><span class="line">	commands ;;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></tbody></table></figure>

<p>  <code>case</code>的匹配模式可以使用各种通配符，下面是一些例子：  </p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a)</td>
<td align="left">若单词为”a”，则匹配</td>
</tr>
<tr>
<td align="left">a|b)</td>
<td align="left">若单词为”a”或”b”，则匹配</td>
</tr>
<tr>
<td align="left">[[:alpha:]])</td>
<td align="left">若单词是一个字母字符，则匹配</td>
</tr>
<tr>
<td align="left">???)</td>
<td align="left">若单词只有3个字符，则匹配</td>
</tr>
<tr>
<td align="left">*.txt)</td>
<td align="left">若单词以”.txt”字符结尾，则匹配</td>
</tr>
<tr>
<td align="left">*)</td>
<td align="left">匹配任意单词。把这个模式作为case命令的最后一个模式，是一个很好的做法，可以捕获到任意一个与先前模式不匹配的数值；也就是说，捕获到任何可能的无效值</td>
</tr>
</tbody></table>
<p>  执行多个动作：<br>  Bash 4.0之后允许匹配多个条件，这时可以用<code>;;&amp;</code>终止每个条件块。<br>  条件语句结尾添加了<code>;;&amp;</code>以后，在匹配一个条件之后，并没有退出<code>case</code>结构，而是继续判断下一个条件。  </p>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li><p><code>while</code>循环  </p>
<p>  <code>while</code>循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>until</code>循环  </p>
<p>  <code>until</code>循环与<code>while</code>循环恰好相反，只要不符合判断条件（判断条件失败），就不断循环执行指定的语句。一旦符合判断条件，就退出循环。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">until condition; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  一般来说，<code>until</code>用得比较少，完全可以统一都是用<code>while</code>。  </p>
</li>
<li><p><code>for...in</code>循环  </p>
<p>  <code>for...in</code>循环用于遍历列表的每一项。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>for</code>循环  </p>
<p>  <code>for</code>循环还支持 C 语言的循环语法。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( expression1; expression2; expression3 )); <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号<code>$</code>。  </p>
</li>
<li><p><code>break</code>, <code>continue</code>  </p>
</li>
<li><p><code>select</code>结构  </p>
<p>  <code>select</code>结构主要用来生成简单的菜单。它的语法与<code>for...in</code>循环基本一致。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">[<span class="keyword">in</span> list]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="终端打印"><a href="#终端打印" class="headerlink" title="终端打印"></a>终端打印</h2><p><code>echo</code>是用于终端打印的基本命令。  </p>
<p>另一个可用于终端打印的命令是<code>printf</code>:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4.2f\n"</span> 2 James 90.9989</span><br></pre></td></tr></tbody></table></figure>

<p>彩色输出：<br><img src="https://i.loli.net/2020/06/08/DEpRWVLrby8qOxI.png" alt="shell颜色语法.png"><br><img src="https://i.loli.net/2020/06/08/Yu5AzgHGvN7VdpS.png" alt="shell涉及的颜色.png"><br>每种颜色都有对应的颜色码。比如：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37。<br>要打印彩色文本，可输入如下命令：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;31m This is red text \e[0m"</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>\e[1;31m</code>将颜色设为红色，<code>\e[0m</code>将颜色重新置回。  </p>
<p>要设置彩色背景，经常使用的颜色码是：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;42m Green Background \e[0m"</span></span><br></pre></td></tr></tbody></table></figure>


<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul>
<li><p>重定向  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls -l /bin/usr 2&gt; ls-error.txt <span class="comment">#重定向标准错误</span></span><br><span class="line">$ ls -l /bin/usr &amp;&gt; ls-output.txt <span class="comment">#重定向标准输出和错误到同一个文件</span></span><br><span class="line">$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 <span class="comment">#重定向标准输出和错误到同一个文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; temp.txt <span class="comment">#把echo命令的输出写入文件前，temp.txt中的内容首先会被清空</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt;&gt; temp.txt <span class="comment">#这种方法会将文本追加到目标文件中</span></span><br><span class="line">$ &gt; ls-output.txt <span class="comment">#如果我们需要清空一个文件内容（或者创建一个新的空文件），可以使用这样的技巧</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>cat</code> </p>
<p>  <code>cat</code>命令读取一个或多个文件，然后复制它们到标准输出。<br>  如果<code>cat</code>没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘，它正在等待我们输入数据。下一步，输入<code>Ctrl-d</code>来告诉<code>cat</code>，在标准输入中，它已经到达文件末尾<code>EOF</code>。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat movie.mpeg.0* &gt; movie.mpeg</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>管道线  </p>
<p>  使用管道操作符<code>|</code>，一个命令的标准输出可以通过管道送至另一个命令的标准输入。  </p>
</li>
</ul>
<ul>
<li><p>过滤器  </p>
<p>  管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后输出它。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls /bin /usr/bin | sort | uniq | less</span><br><span class="line">$ ls /bin /usr/bin | sort | uniq | wc -l</span><br><span class="line">$ ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">$ <span class="built_in">echo</span> `who | awk <span class="string">'{print $1}'</span> | sort | uniq` | sed <span class="string">'s/ /, /g'</span> &gt; file.txt</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>head</code>/<code>tail</code> - 打印文件开头部分/结尾部分  </p>
<p>  默认打印10行，通过<code>-n</code>参数指定打印的行数。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls /usr/bin | tail -n 5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>tail</code>有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同时被写入。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tail -f /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></tbody></table></figure>
<p>  通过<code>-f</code>参数，<code>tail</code>命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。这会一直继续下去直到你输入<code>Ctrl+c</code>。  </p>
</li>
<li><p><code>tee</code> - 从<code>stdin</code>读取数据，并同时输出到<code>stdout</code>和文件<br>  为了和我们的管道隐喻保持一致，Linux提供了一个叫做<code>tee</code>的命令，这个命令制造了一个”tee”，安装到我们的管道上，<code>tee</code>程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子，这次包含<code>tee</code>命令，在<code>grep</code>过滤管道线的内容之前，来捕捉整个目录列表到文件ls.txt。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls /usr/bin | tee ls.txt | grep zip</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="引号和转义"><a href="#引号和转义" class="headerlink" title="引号和转义"></a>引号和转义</h2><ul>
<li><p>引号  </p>
<ul>
<li><p><strong>单引号</strong>：  </p>
<p>无视所有特殊字符，原样输出，所有字符在它眼里都是普通字符，比如星号<code>*</code>、美元符号<code>$</code>、反斜杠<code>\</code>等；单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p>
</li>
<li><p><strong>双引号</strong>: </p>
<p>无视文件通配符，但<code>$</code>、<code>\</code>和<code>`</code>会起作用。</p>
<p>双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通符号。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"*"</span></span><br><span class="line">*</span><br></pre></td></tr></tbody></table></figure>

<p>上面例子中，通配符<code>*</code>是一个特殊字符，放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，这意味着，双引号里面不会进行文件名扩展。</p>
<p>但是三个特殊字符除外：美元符号<code>$</code>、反引号<code>`</code>和反斜杠<code>\</code>。这三个字符在双引号之中，依然有特殊含义，会被Bash自动扩展。</p>
<p>双引号还有一个作用，就是保存原始命令的输出格式：</p>
<p>单行输出：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(cal)</span><br><span class="line">二月 2021 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28</span><br></pre></td></tr></tbody></table></figure>

<p>原始格式输出：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="subst">$(cal)</span>"</span></span><br><span class="line">	二月 2021         </span><br><span class="line">日 一 二 三 四 五 六  </span><br><span class="line">	1  2  3  4  5  6  </span><br><span class="line">7  8  9 10 11 12 13  </span><br><span class="line">14 15 16 17 18 19 20  </span><br><span class="line">21 22 23 24 25 26 27  </span><br><span class="line">28                    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>转义  </p>
<p>  某些字符在Bash里面有特殊含义（比如<code>$</code>、<code>&amp;</code>、<code>*</code>）。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$data</span></span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，输出$date不会有任何结果，因为<code>$</code>是一个特殊字符。<br>  如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做”转义”(escape)。  </p>
<p>  反斜杠除了用于转义，还可以表示一些不可打印的字符：<br>  <code>\a</code> - 响铃<br>  <code>\b</code> - 退格<br>  <code>\n</code> - 换行<br>  <code>\r</code> - 回车<br>  <code>\t</code> - 制表符<br>  如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用<code>echo</code>命令的<code>-e</code>参数：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a\tb</span><br><span class="line">atb</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"a\tb"</span></span><br><span class="line">a	b</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，命令行直接输出不可打印字符<code>\t</code>，Bash不能正确解析。必须把它们放在引号之中，然后使用<code>echo</code>命令的<code>-e</code>参数。  </p>
<p>  换行符是一个特殊字符，表示命令的结束，Bash收到这个字符以后，就会对输入的命令进行解释执行。换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash会将其当做空格处理，从而可以将一行命令写成多行。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mv \</span><br><span class="line">/path/to/foo \</span><br><span class="line">/path/to/bar</span><br></pre></td></tr></tbody></table></figure>
<p>  等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mv /path/to/foo /path/to/bar</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>Bash的模式扩展：<br>    shell接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元，然后，shell会扩展词元里面的特殊字符，扩展完后才会调用相应的命令。  </p>
<ul>
<li><p>波浪线扩展  </p>
<p>  自动扩展成当前用户的主目录。  </p>
</li>
<li><p><code>?</code>字符扩展  </p>
<p>  代表文件路径里面的任意单个字符，不包括空字符。  </p>
</li>
<li><p><code>*</code>字符扩展  </p>
<p>  代表文件路径里面的任意数量的任意字符，包括零个字符。  </p>
</li>
<li><p>方括号扩展  </p>
<p>  1、匹配括号之中的任意一个字符。如果需要匹配连字号<code>-</code>，只能放在方括号内部的开头或结尾，比如[-aeiou]或[aeiou-]。<br>  2、方括号扩展有一个简写形式<code>[start-end]</code>，表示匹配一个连续的范围。比如[a-c]等同于[abc]，[0-9]匹配[0123456789]。  </p>
<p>  举例：  </p>
<pre><code>  [a-z]：所有小写字母；  
  [a-zA-Z]：所有小写字母与大写字母；  
  [a-zA-Z0-9]：所有小写字母、大写字母与数字；  
  [abc]*：所有以a、b、c字符之一开头的文件名；  
  program.[co]：文件program.c与文件program.o；  
  BACKUP.[0-9][0-9][0-9]：所有以BACKUP.开头，后面是三个数字的文件名。  
</code></pre>
<p>  这种简写形式有一个否定形式<code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如[!a-zA-Z]表示匹配非英文字母的字符，[!1-3]表示排除1、2和3。  </p>
</li>
<li><p>大括号扩展  </p>
<p>  表示分别扩展成大括号<code>{...}</code>里面的所有值，各个值之间使用逗号分隔。比如{1,2,3}扩展成1 2 3。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> d{a,e,i,o,u}g</span><br><span class="line">dag deg dig dog dug</span><br></pre></td></tr></tbody></table></figure>
<p>  1、大括号内部的逗号前后不能有空格，否则，大括号扩展会失效。  </p>
<p>  2、逗号前面可以没有值，表示扩展的第一项为空。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cp a.log{,.bak}</span><br></pre></td></tr></tbody></table></figure>
<p>  等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cp a.log a.log.bak</span><br></pre></td></tr></tbody></table></figure>
<p>  3、大括号可以嵌套。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {j{p,pe}g,png}</span><br><span class="line">jpg jpeg png</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a{A{1,2},B{3,4}}b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></tbody></table></figure>
<p>  4、大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> /bin/{cat,b*}</span><br><span class="line">/bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ...</span><br></pre></td></tr></tbody></table></figure>
<p>  基本等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> /bin/cat;<span class="built_in">echo</span> /bin/b*</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，会先进行大括号扩展，然后进行<code>*</code>扩展，等同于执行两条<code>echo</code>命令。  </p>
<p>  由于大括号扩展<code>{...}</code>不是文件名扩展，所以它总是会扩展的。这与方括号扩展<code>[...]</code>完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。  </p>
<p>  不存在 a.txt 和 b.txt 时：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> [ab].txt</span><br><span class="line">[ab].txt</span><br><span class="line">$ <span class="built_in">echo</span> {a,b}.txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></tbody></table></figure>

<p>  5、大括号扩展有一个简写形式<code>{start..end}</code>，表示扩展成一个连续序列。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {a..c}</span><br><span class="line">a b c</span><br></pre></td></tr></tbody></table></figure>
<p>  这种简写形式支持逆序：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {c..a}</span><br><span class="line">c b a</span><br></pre></td></tr></tbody></table></figure>
<p>  这种简写形式可以嵌套使用，形成复杂的扩展：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> .{mp{3,4},m4{a,b,p,v}}</span><br><span class="line">.mp3 .mp4 .m4a .m4b .m4p .m4v</span><br></pre></td></tr></tbody></table></figure>

<p>  6、大括号扩展的常见用途：<br>  新建一系列目录：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mkdir {2007..2009}-{01..12}</span><br></pre></td></tr></tbody></table></figure>
<p>  用于for循环：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..4}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  如果整数前面有前导0，扩展输出的每一项都有前导0：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {01..5}</span><br><span class="line">01 02 03 04 05</span><br><span class="line">$ <span class="built_in">echo</span> {001..5}</span><br><span class="line">001 002 003 004 005</span><br></pre></td></tr></tbody></table></figure>

<p>  7、这种简写形式还可以使用第二个双点号<code>(start..end..step)</code>，用来指定扩展的步长：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {0..8..2}</span><br><span class="line">0 2 4 6 8</span><br></pre></td></tr></tbody></table></figure>
<p>  多个简写形式连用，会有循环处理的效果：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {a..c}{1..3}</span><br><span class="line">a1 a2 a3 b1 b2 b3 c1 c2 c3</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>变量扩展  </p>
<p>  Bash将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值。变量名除了放在美元符号后面，也可以放在<code>${}</code>里面。<br>  <code>${!string*}</code>或<code>${!string@}</code>返回所有匹配给定字符串string的变量名。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">${!S*}</span></span><br><span class="line">SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，${!S*}扩展成所有以S开头的变量名。  </p>
</li>
<li><p>子命令扩展  </p>
<p>  <code>$(...)</code>可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(date)</span><br><span class="line">Tue Jan 12 10:56:55 CST 2021</span><br><span class="line">$ file $(ls /usr/bin/* | grep zip)</span><br></pre></td></tr></tbody></table></figure>
<p>  还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `date`</span><br><span class="line">Tue Jan 12 10:58:51 CST 2021</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>$(...)</code>可以嵌套，比如：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$(ls $(<span class="built_in">pwd</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>  利用子shell生成一个独立的进程：<br>  子shell本身就是独立的进程。可以使用<code>()</code>操作符来定义一个子shell：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>;</span><br><span class="line">(<span class="built_in">cd</span> /bin; ls);</span><br><span class="line"><span class="built_in">pwd</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>  当命令在子shell中执行时，不会对当前shell有任何影响；所有的改变仅限于子shell内。例如，当用cd命令改变子shell的当前目录时，这种变化不会反映到主shell环境中。  </p>
</li>
<li><p>算术扩展  </p>
<p>  <code>$((...))</code>可以扩展成整数运算的结果。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符类  </p>
<p>  比如：<code>[[:digit:]]</code>匹配任意数字 0-9。  </p>
<p>  使用注意点：<br>  1、通配符是先解释，再执行。<br>  2、文件名扩展在不匹配时，会原样输出。<br>  3、只适用于单层路径。所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code>或<code>*</code>这样的通配符，不能匹配路径分隔符<code>/</code>。  </p>
<pre><code>  如果要匹配子目录里面的文件，可以写成下面这样：  
</code></pre>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls */*.txt</span><br></pre></td></tr></tbody></table></figure>
<p>  4、文件名可以使用通配符。这时引用文件名，需要把文件名放在单引号里面。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ touch <span class="string">'fo*'</span></span><br><span class="line">$ ls</span><br><span class="line">fo*</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>量词语法  </p>
<p>  量词语法用来控制模式匹配的次数。它只有在Bash的<code>extglob</code>参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> extglob</span><br><span class="line">extglob on</span><br></pre></td></tr></tbody></table></figure>
<p>  量词语法有下面几个：<br>  <code>?(pattern-list)</code> - 匹配零个或一个模式<br>  <code>*(pattern-list)</code> - 匹配零个或多个模式<br>  <code>+(pattern-list)</code> - 匹配一个或多个模式<br>  <code>@(pattern-list)</code> - 只匹配一个模式<br>  <code>!(pattern-list)</code> - 匹配零个或一个以上的模式，但不匹配单独一个的模式  </p>
<p>  <code>shopt</code>命令可以调整Bash的行为。它有好几个参数跟通配符扩展有关。<br>  <code>shopt</code>命令的使用方法如下：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s [optionname] <span class="comment">#打开某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -u [optionname] <span class="comment">#关闭某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> [optionname] <span class="comment">#查询某个参数关闭还是打开</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>shell本身不支持正则表达式，使用正则表达式的是shell命令和工具。<br>正则表达式基本上是一种“表达式”， 只要工具程序支持这种表达式，那么该工具程序就可以用来作为正则表达式的字串处理之用。 例如 <code>vi</code>, <code>egrep</code>, <code>awk</code> , <code>sed</code>, <code>perl</code>, <code>less</code> 等等工具，因为她们有支持正则表达式， 所以，这些工具就可以使用正则表达式的特殊字符来进行字串的处理。但例如 <code>find</code>, <code>cp</code>, <code>ls</code>, <code>rm</code> 等系统命令一般并未支持正则表达式， 所以就只能使用 Bash 自己本身的通配符而已。</p>
<p>正则表达式元字符由以下字符组成：<br><code>^</code> <code>$</code> <code>.</code> <code>[ ]</code> <code>{ }</code> <code>-</code> <code>?</code> <code>*</code> <code>+</code> <code>( )</code> <code>|</code> <code>\</code>  </p>
<p>其他所有字符都被认为是原义字符。在个别情况下，反斜杠会被用来创建元序列，元字符也可以被转义为原义字符，而不是解释为元字符。<br>注意：正如我们所见到的，当 shell 执行展开的时候，许多正则表达式元字符，也是对 shell 有特殊 含义的字符。当我们在命令行中传递包含元字符的正则表达式的时候，把元字符用引号引起来至关重要，这样可以阻止 shell 试图展开它们。  </p>
<ol>
<li><p>任何字符  </p>
<p> 圆点字符，用来匹配任意字符。如果我们在正则表达式中包含它，它将会匹配在此位置的任意一个字符。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -h <span class="string">'.zip'</span> dirlist*.txt  </span><br><span class="line">bunzip2  </span><br><span class="line">bzip2  </span><br><span class="line">bzip2recover  </span><br><span class="line">gunzip  </span><br><span class="line">gzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">prezip-bin  </span><br><span class="line">unzip  </span><br><span class="line">unzipsfx</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>锚点  </p>
<p> 在正则表达式中，插入符号和美元符号被看作是锚点。这意味着正则表达式只有在文本行的开头或末尾被找到时，才算发生一次匹配。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -h <span class="string">'^zip'</span> dirlist*.txt  </span><br><span class="line">zip  </span><br><span class="line">zipcloak  </span><br><span class="line">zipgrep  </span><br><span class="line">zipinfo  </span><br><span class="line">zipnote  </span><br><span class="line">zipspli  </span><br><span class="line">$ grep -h <span class="string">'zip$'</span> dirlist*.txt  </span><br><span class="line">gunzip  </span><br><span class="line">gzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">unzip  </span><br><span class="line">zip  </span><br><span class="line">$ grep -h <span class="string">'^zip$'</span> dirlist*.txt  </span><br><span class="line">zip  </span><br></pre></td></tr></tbody></table></figure>

<p> 注意正则表达式<code>'ˆ$'</code>（行首和行尾之间没有字符）会匹配空行。  </p>
</li>
<li><p>中括号表达式和字符类  </p>
<p> 通过使用中括号表达式，能够从一个指定的字符集合（包含在不加中括号的情况下会被解释为元字符的字符）中匹配单个字符。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -h <span class="string">'[bg]zip'</span> dirlist*.txt  </span><br><span class="line">bzip2  </span><br><span class="line">bzip2recover  </span><br><span class="line">gzip  </span><br></pre></td></tr></tbody></table></figure>

<p> 一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后会失去了它们的特殊含义。 然而，在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。第一个元字符 是插入字符<code>^</code>，其被用来表示否定；第二个是连字符字符<code>-</code>，其被用来表示一个字符范围。  </p>
</li>
<li><p>否定  </p>
<p> 如果在中括号表示式中的第一个字符是一个插入字符<code>^</code>，则剩余的字符被看作是不会在给定的字符位置出现的字符集合。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -h <span class="string">'[^bg]zip'</span> dirlist*.txt  </span><br><span class="line">bunzip2  </span><br><span class="line">gunzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">prezip-bin  </span><br><span class="line">unzip  </span><br><span class="line">unzipsfx  </span><br></pre></td></tr></tbody></table></figure>

<p> 一个否定的字符集仍然在给定位置要求一个字符，但是这个字符必须不是否定字符集的成员。<br> 插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去它的特殊含义，变成字符集中的一个普通字符。  </p>
</li>
<li><p>传统的字符区域  </p>
</li>
<li><p>POSIX字符集  </p>
<p> POSIX 把正则表达式的实现分成了两类： 基本正则表达式（BRE）和扩展的正则表达式（ERE）。  </p>
<p> BRE 和 ERE 之间有什么区别呢？这是关于元字符的问题。BRE 可以辨别以下元字符：  </p>
<p> <code>^</code> <code>$</code> <code>.</code> <code>[ ]</code> <code>*</code>  </p>
<p> 其它的所有字符被认为是文本字符。ERE 添加了以下元字符（以及与其相关的功能）:  </p>
<p> <code>( )</code> <code>{ }</code> <code>?</code> <code>+</code> <code>|</code>  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -Eh <span class="string">'^(bz|gz|zip)'</span> dirlist*.txt  </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>限定符  </p>
<p> 扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数。  </p>
<ul>
<li><code>?</code> - 匹配零个或一个元素  </li>
<li><code>*</code> - 匹配零个或多个元素  </li>
<li><code>+</code> - 匹配一个或多个元素  </li>
<li><code>{}</code> - 匹配特定个数的元素  </li>
</ul>
<p> <code>{}</code>元字符都被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定：  </p>
<table>
<thead>
<tr>
<th align="left">限定符</th>
<th align="left">意思</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n</td>
<td align="left">匹配前面的元素，如果它确切地出现了 n 次</td>
</tr>
<tr>
<td align="left">n,m</td>
<td align="left">匹配前面的元素，如果它至少出现了n次，但是不多于m次</td>
</tr>
<tr>
<td align="left">n,</td>
<td align="left">匹配前面的元素，如果它出现了n次或多于n次</td>
</tr>
<tr>
<td align="left">,m</td>
<td align="left">匹配前面的元素，如果它出现的次数不多于m次</td>
</tr>
</tbody></table>
</li>
</ol>
<p>正则表达式的基本组成部分：  </p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">行起始标记</td>
<td align="left">^tux匹配以tux起始的行</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">行尾标记</td>
<td align="left">tux$匹配以tux结尾的行</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意一个字符</td>
<td align="left">Hack.匹配Hackl和Hacki，但是不匹配Hackl2和Hackil，它只能匹配单个字符</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">匹配包含在[字符]之中的任意一个字符</td>
<td align="left">coo[kl]匹配cook或cool</td>
</tr>
<tr>
<td align="left">[^]</td>
<td align="left">匹配除[^字符]之外的任意一个字符</td>
<td align="left">9[^01]匹配92、93，但是不匹配91或90</td>
</tr>
<tr>
<td align="left">[-]</td>
<td align="left">匹配[]中指定范围内的任意一个字符</td>
<td align="left">[1-5]匹配从1~5的任意一个数字</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配之前的项1次或0次</td>
<td align="left">colou?r匹配color或colour，但是不能匹配colouur</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配之前的项1次或多次</td>
<td align="left">Rollno-9+匹配Rollno-99、Rollno-9，但是不能匹配Rollno-</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配之前的项0次或多次</td>
<td align="left">co*l匹配cl、col、coool等</td>
</tr>
<tr>
<td align="left">()</td>
<td align="left">创建一个用于匹配的子串</td>
<td align="left">ma(tri)?x匹配max或matrix</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">匹配之前的项n次</td>
<td align="left">[0-9]{3}匹配任意一个三位数，[0-9]{3}可以扩展为[0-9][0-9][0-9]</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">之前的项至少需要匹配n次</td>
<td align="left">[0-9]{2,}匹配任意一个两位或更多位的数字</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">指定之前的项所必须匹配的最小次数和最大次数</td>
<td align="left">[0-9]{2,5}匹配从两位数到五位数之前的任意一个数字</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">交替一一匹配|两边的任意一项</td>
<td align="left">Oct(1st|2nd)匹配Oct 1st或Oct 2nd</td>
</tr>
</tbody></table>
<h2 id="sed入门"><a href="#sed入门" class="headerlink" title="sed入门"></a>sed入门</h2><p>名字 <code>sed</code> 是 stream editor（流编辑器）的简称。  </p>
<p><code>sed</code>地址表示法：  </p>
<table>
<thead>
<tr>
<th align="left">地址</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n</td>
<td align="left">行号，n是一个正整数</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">最后一行</td>
</tr>
<tr>
<td align="left">/regexp/</td>
<td align="left">所有匹配一个POSIX基本正则表达式的文本行。注意正则表达式通过斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc来指定表达式，这里c就是一个备用字符</td>
</tr>
<tr>
<td align="left">addr1,addr2</td>
<td align="left">从addr1到addr2范围内的文本行，包含地址addr2在内。地址可能是上述任意单独的地址形式</td>
</tr>
<tr>
<td align="left">first~step</td>
<td align="left">匹配由数字first代表的文本行，然后随后的每个在step间隔处的文本行。例如1<del>2是指每个位于偶数行号的文本行，5</del>5则指第五行和之后每五行位置的文本行</td>
</tr>
<tr>
<td align="left">addr1,+n</td>
<td align="left">匹配地址addr1和随后的n个文本行</td>
</tr>
<tr>
<td align="left">addr!</td>
<td align="left">匹配所有的文本行，除了addr之外，addr可能是上述任意的地址形式</td>
</tr>
</tbody></table>
<p><code>sed</code>基本编辑命令：  </p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">输出当前的行号。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">在当前行之后追加文本。</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">删除当前行。</td>
</tr>
<tr>
<td align="left">i</td>
<td align="left">在当前行之前插入文本。</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">打印当前行。默认情况下，sed程序打印每一行，并且只是编辑文件中匹配指定地址的文本行。通过指定-n选项，这个默认的行为能够被忽略。</td>
</tr>
<tr>
<td align="left">q</td>
<td align="left">退出sed，不再处理更多的文本行。如果不指定-n选项，输出当前行。</td>
</tr>
<tr>
<td align="left">Q</td>
<td align="left">退出sed，不再处理更多的文本行。</td>
</tr>
<tr>
<td align="left">s/regexp/replacement/</td>
<td align="left">只要找到一个regexp匹配项，就替换replacement的内容。replacement可能包括特殊字符&amp;，其等价于由regexp匹配的文本。另外，replacement可能包括序列\1到\9，其是regexp中相对应的子表达式的内容。在replacement末尾的斜杠之后，可以指定一个可选的标志，来修改s命令的行为。</td>
</tr>
<tr>
<td align="left">y/set1/set2</td>
<td align="left">执行字符转写操作，通过把set1中的字符转变为相对应的set2中的字符。注意不同于tr程序，sed要求两个字符集合具有相同的长度。（y命令不支持字符区域（例如，[a-z]），也不支持POSIX字符集。）</td>
</tr>
</tbody></table>
<p><strong>逆参照</strong>：如果序列<code>\n</code>出现在<code>replacement</code>中，这里<code>n</code>是指从1到9的数字，则这个序列指的是在前面正则表达式中相对应的子表达式。为了创建这个子表达式，我们简单地把它们用圆括号括起来。  </p>
<p><code>s</code>命令的另一个功能是使用<strong>可选标志</strong>，其跟随替代字符串。一个最重要的可选标志是<code>g</code>标志，其指示sed对某个文本行全范围地执行查找和替换操作，不仅仅是对第一个实例，这是默认行为。这里有个例子：  </p>
<p>例子：  </p>
<ul>
<li><p>替换  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/text/replace/g'</span> file</span><br></pre></td></tr></tbody></table></figure>
<p><code>-i</code>可以将替换结果应用于原文件。<br><code>/g</code>意味着<code>sed</code>会替换每一处匹配。  </p>
</li>
<li><p>移除空白行  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sed <span class="string">'/^$/d'</span> file</span><br></pre></td></tr></tbody></table></figure>
<p>空白行可以用正则表达式<code>^$</code>进行匹配。<br><code>/pattern/d</code>会移除匹配样式的行。  </p>
</li>
<li><p>已匹配字符串标记&amp;<br>在<code>sed</code>中，用<code>&amp;</code>标记匹配样式的字符串，就能够在替换字符串时使用已匹配的内容。例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> this is an example | sed <span class="string">'s/\w\+/[&amp;]/g'</span>  </span><br><span class="line">[this] [is] [an] [example]  </span><br></pre></td></tr></tbody></table></figure>
<p>正则表达式<code>\w\+</code>匹配每一个单词，然后我们用<code>[&amp;]</code>替换它。<code>&amp;</code>对应于之前所匹配到的单词。  </p>
</li>
<li><p>子串匹配标记\1<br><code>&amp;</code>代表匹配给定样式的字符串。但我们也可以匹配给定样式的其中一部分。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> this is digit 7 <span class="keyword">in</span> a number | sed <span class="string">'s/digit \([0-9]\)/\1'</span>  </span><br><span class="line">this is 7 <span class="keyword">in</span> a number  </span><br></pre></td></tr></tbody></table></figure>
<p>这条命令将digit 7替换为7。样式中匹配到的子串是7。<code>\(pattern\)</code>用于匹配子串。模式被包括在使用斜线转义过的<code>()</code>中。对于匹配到的第一个子串，其对应的标记是<code>\1</code>，匹配到的第二个子串是<code>\2</code>，往后依次类推。<br>下面的示例中包含了多个匹配：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> seven EIGHT | sed <span class="string">'s/\([a-z]\+\) \([A-Z]\+\)/\2 \1'</span></span><br><span class="line">EIGHT seven</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>组合多个表达式<br>利用管道组合多个<code>sed</code>命令可以用下面的方式代替：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sed <span class="string">'expression; expression'</span> <span class="comment"># sed 'expression' | sed 'expression'</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>引用<br><code>sed</code>表达式通常用单引号来引用。不过也可以使用双引号。双引号会通过对表达式求值来对其进行扩展。当我们想在sed表达式中使用一些变量字符串时，双引号就有用武之地了。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ text=hello</span><br><span class="line">$ <span class="built_in">echo</span> hello world | sed <span class="string">"s/<span class="variable">$text</span>/HELLO/"</span></span><br><span class="line">HELLO world</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>其他例子：替换文本或文件中的字符串<br>用另一个指定的数字替换文件中所有的3位数字：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat sed_data.txt</span><br><span class="line">11 abc 111 this 9 file contains 111 11 88 numbers 0000</span><br><span class="line">$</span><br><span class="line">$ cat sed_data.txt | sed <span class="string">'s/\b[0-9]\{3\}\b/NUMBER/g'</span></span><br><span class="line">11 abc NUMBER this 9 file contains NUMBER 11 88 numbers 0000</span><br></pre></td></tr></tbody></table></figure>
<p>上面的单行命令只替换3位数字。\b[0-9]{3}\b是一个用于匹配3位数字的正则表达式。[0-9]表示从0到9的数字范围。{3}用来匹配3次之前的数字。{3}中的<code>\</code>用于赋予<code>{</code>和<code>}</code>特殊的含义。<code>\b</code>是单词边界标记。  </p>
</li>
</ul>
<h2 id="awk入门"><a href="#awk入门" class="headerlink" title="awk入门"></a>awk入门</h2><p><code>awk</code>脚本的结构基本如下所示：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN{ commands } pattern{ commands } END{ commands }'</span> file  </span><br></pre></td></tr></tbody></table></figure>
<p>一个<code>awk</code>脚本通常由3部分组成：<code>BEGIN</code>语句块、<code>END</code>语句块和能够使用模式匹配的通用语句块。这3个部分是可选的，它们中任何一个部分都可以不出现在脚本中。脚本通常会被包含在单引号或双引号中。  </p>
<p><code>awk</code>命令的工作方式如下所示：<br>执行<code>BEGIN{ commands }</code>语句块中的语句。<br>从文件或<code>stdin</code>中读取一行，然后执行<code>pattern{ commands }</code>。重复这个过程，直到文件全部被读取完毕。<br>当读至输入流(input steam)末尾时，执行<code>END{ commands }</code>语句块。  </p>
<p><code>BEGIN</code>语句块在<code>awk</code>开始从输入流中读取行之前被执行。这是一个可选的语句块，诸如变量的初始化、打印输出表格的表头等语句通常都可以写入<code>BEGIN</code>语句块中。<br><code>END</code>语句块和<code>BEGIN</code>语句块类似。<code>END</code>语句块在<code>awk</code>从输入流中读取完所有的行之后即被执行。像打印所有行的分析结果这类汇总信息，都是在<code>END</code>语句块中实现的常见任务（例如，在比较过所有的行之后，打印出最大数）。它也是一个可选的语句块。<br>最需要的部分就是<code>pattern</code>语句块中的通用命令。这个语句块同样是可选的。如果不提供该语句块，则默认执行<code>{ print }</code>，即打印每一个读取到的行。<code>awk</code>对于读取的每一行，都会执行这个语句块。  </p>
<p>这就像一个用来读取行的<code>while</code>循环，在循环体中提供了相应的语句。<br>每读取一行时，它就会检查该行和提供的样式是否匹配。样式本身可以是正则表达式、条件以及行匹配范围等。如果当前行匹配该样式，则执行<code>{}</code>中的语句。<br>样式是可选的。如果没有提供样式，那么它就会默认所有的行都是匹配的，并执行<code>{}</code>中的语句。  </p>
<p>关于<code>print</code>：<br>当<code>print</code>的参数是以逗号进行分割时，参数打印时则以空格作为定界符；<br>在<code>awk</code>的<code>print</code>语句中，双引号是被当作拼接操作符使用的。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ var1="v1"; var2="v2"; var3="v3"; \</span></span><br><span class="line"><span class="string">print var1"-"var2"-"var3; }'</span>  </span><br><span class="line">v1-v2-v3  </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>特殊变量<br>以下是可用于<code>awk</code>的一些特殊变量：  </p>
<ul>
<li><code>NR</code> - 表示记录数量，在执行过程中对应于当前行号  </li>
<li><code>NF</code> - 表示字段数量，在执行过程中对应于当前行的字段数  </li>
<li><code>$0</code> - 这个变量包含执行过程中当前行的文本内容  </li>
<li><code>$1</code> - 这个变量包含第一个字段的文本内容  </li>
<li><code>$2</code> - 这个变量包含第二个字段的文本内容<br>例如：  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3\nline2 f4 f5\nline3 f6 f7"</span> | \</span><br><span class="line">awk <span class="string">'{print "Line no:"NR", No of fields:"NF", $0="$0", $1="$1", $2="$2", $3="$3""}'</span></span><br><span class="line">Line no:1, No of fields:3, <span class="variable">$0</span>=line1 f2 f3, <span class="variable">$1</span>=line1, <span class="variable">$2</span>=f2, <span class="variable">$3</span>=f3</span><br><span class="line">Line no:2, No of fields:3, <span class="variable">$0</span>=line2 f4 f5, <span class="variable">$1</span>=line2, <span class="variable">$2</span>=f4, <span class="variable">$3</span>=f5</span><br><span class="line">Line no:3, No of fields:3, <span class="variable">$0</span>=line3 f6 f7, <span class="variable">$1</span>=line3, <span class="variable">$2</span>=f6, <span class="variable">$3</span>=f7</span><br></pre></td></tr></tbody></table></figure>
可以用<code>print $NF</code>打印一行中最后一个字段，用<code>$(NF-1)</code>打印倒数第二个字段，其他字段依次类推即可。<br><code>awk</code>的<code>printf()</code>函数的语法和C语言中的同名函数一样。可以用这个函数来代替<code>print</code>。  </li>
</ul>
</li>
<li><p>将外部变量值传递给<code>awk</code><br>借助选项<code>-v</code>，可以将外部值（并非来自<code>stdin</code>）传递给<code>awk</code>：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ VAR=10000</span><br><span class="line">$ <span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">'{ print VARIABLE }'</span></span><br><span class="line">10000</span><br></pre></td></tr></tbody></table></figure>
<p>还有另一种灵活的方法可以将多个外部变量传递给<code>awk</code>，例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ var1=<span class="string">"Variable1"</span>; var2=<span class="string">"Variable2"</span></span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ print v1,v2 }'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line">Variable1 Variable2</span><br></pre></td></tr></tbody></table></figure>
<p>当输入来自于文件而非标准输入时，使用：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'{ print v1 v2 }'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> filename</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的方法中，变量之间用空格分隔，以键-值对的形式（v1=$var1 v2=$var2）作为<code>awk</code>的命令行参数紧随在<code>BEGIN</code>、<code>{}</code>和<code>END</code>语句块之后。  </p>
</li>
<li><p>用<code>getline</code>读取行  </p>
</li>
<li><p>用样式对<code>awk</code>处理的行进行过滤<br>可以为需要处理的行指定一些条件，例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'NR &lt; 5'</span>      <span class="comment"># 行号小于5的行</span></span><br><span class="line">$ awk <span class="string">'NR==1,NR==4'</span> <span class="comment"># 行号在1到4之间的行</span></span><br><span class="line">$ awk <span class="string">'/linux/'</span>     <span class="comment"># 包含样式linux的行（可以用正则表达式来指定样式）</span></span><br><span class="line">$ awk <span class="string">'!/linux/'</span>    <span class="comment"># 不包含样式linux的行</span></span><br></pre></td></tr></tbody></table></figure>
<p>要打印处于start_pattern与end_pattern之间的文本，使用下面的语法：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'/start_pattern/, /end_pattern/'</span> filename</span><br></pre></td></tr></tbody></table></figure>
<p>例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat section.txt</span><br><span class="line">line with pattern1</span><br><span class="line">line with pattern2</span><br><span class="line">line with pattern3</span><br><span class="line">line end with pattern4</span><br><span class="line">line with pattern5</span><br><span class="line">$</span><br><span class="line">$ awk <span class="string">'/pa.*3/, /end/'</span> section.txt</span><br><span class="line">line with pattern3</span><br><span class="line">line end with pattern4</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设定字段定界符<br>默认的字段定界符是空格。我们也可以用 <code>-F "delimiter"</code> 明确指定一个定界符。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk -F: <span class="string">'{ print $1,$2,$3,$NF }'</span> /etc/passwd</span><br></pre></td></tr></tbody></table></figure>
<p>或者  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN { FS=":" } { print $1,$2,$3,$NF }'</span> /etc/passwd</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>从<code>awk</code>中读取命令输出<br>在下面的代码中，<code>echo</code>会生成一个空白行。变量cmdout包含命令grep root /etc/passwd的输出，然后打印包含root的行；<br>将command的输出读入变量output的语法如下：<br>“command” | getline output ;<br>例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ "grep root /etc/passwd" | getline cmdout ; print cmdout }'</span>  </span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></tbody></table></figure>
<p>通过使用<code>getline</code>，能够将外部shell命令的输出读入变量cmdout。</p>
</li>
</ul>
<p>遇到的问题：</p>
<ol>
<li><a href="https://blog.csdn.net/rj042/article/details/72860177"><code>awk</code>中不能使用<code>shell</code>定义的变量，使用<code>-v</code>选项</a></li>
<li><a href="https://stackoverflow.com/questions/34236675/kill-command-doesnt-work-in-awk"><code>kill</code>在<code>awk</code>中无所有</a></li>
</ol>
<h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><p><code>!n</code> - 执行历史文件里面行号为n的命令<br><code>!string</code> - 执行最近一个以指定字符串string开头的命令<br><code>!?string</code> - 执行最近一条包含字符串string的命令<br><code>Alt + .</code> - 插入上一个命令的最后一个词<br><code>Ctrl + k</code> - 剪切光标位置到行尾的文本<br><code>Ctrl + u</code> - 剪切光标位置到行首的文本<br><code>Ctrl + y</code> - 在光标位置粘贴文本<br><code>Ctrl + r</code> - 反向增量搜索。从当前命令行开始，向上增量搜索。意思是在字符输入的同时，bash会去搜索历史列表（直接出结果，并高亮匹配的第一个字），每多输入一个字符都会使搜索结果更接近目标。输入<code>Ctrl-r</code>来启动增量搜索，接着输入你要寻找的字。当你找到它以后，你可以敲入<code>Enter</code>来执行命令，或者输入<code>Ctrl-j</code>，从历史列表中复制这一行到当前命令行。再次输入<code>Ctrl-r</code>，来找到下一个匹配项（历史列表中向上移动）。输入<code>Ctrl-g</code>或者<code>Ctrl-c</code>，退出搜索。  </p>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><ul>
<li><p>移动光标  </p>
<p>  <code>0</code> - (零按键) 移动到当前行的行首<br>  <code>^</code> - 移动到当前行的第一个非空字符<br>  <code>$</code> - 移动到当前行的末尾  </p>
</li>
<li><p>基本编辑  </p>
<p>  <code>u</code> - 撤销<br>  <code>Ctrl + r</code> - 反撤销  </p>
</li>
<li><p>打开一行  </p>
<p>  <code>o</code> - 当前行的下方打开一行<br>  <code>O</code> - 当前行的上方打开一行  </p>
</li>
<li><p>删除文本  </p>
<p>  <code>d$</code> - 从光标位置开始到当前行的行尾<br>  <code>d0</code> - 从光标位置开始到当前行的行首<br>  <code>d^</code> - 从光标位置开始到文本行的第一个非空字符<br>  <code>dG</code> - 从当前行到文件的末尾  </p>
</li>
<li><p>复制文本  </p>
<p>  <code>y$</code> - 从当前光标位置到当前行的末尾<br>  <code>y0</code> - 从当前光标位置到行首<br>  <code>y^</code> - 从当前光标位置到文本行的第一个非空字符<br>  <code>yG</code> - 从当前行到文件末尾  </p>
</li>
<li><p>连接行  </p>
<p>  <code>J</code>  </p>
</li>
</ul>
<ul>
<li><p>编辑多个文件  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ vim file1 file2 file3 ...</span><br></pre></td></tr></tbody></table></figure>
<p>  文件之间的切换：  </p>
<p>  从这个文件切换到下一个文件<code>:n</code>；<br>  回到先前的文件<code>:N</code>。  </p>
<p>  查看正在编辑的文件列表，使用<code>:buffers</code>命令。  </p>
<p>  要切换到另一个缓冲区（文件），输入<code>:buffer</code>, 紧跟着你想要编辑的缓冲器编号。  </p>
<p>  跨文件复制粘贴：正常复制粘贴。  </p>
</li>
</ul>
<h2 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h2><ul>
<li><p>内建功能  </p>
<p>  <code>set -x</code> - 在执行时显示参数和命令<br>  <code>set +x</code> - 禁止调试<br>  <code>set -v</code> - 当命令进行读取时显示输入<br>  <code>set +v</code> - 禁止打印输入  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#文件名：debug.sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..6}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">set</span> x</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Script executed"</span></span><br></pre></td></tr></tbody></table></figure>
<p>  在上面的脚本中，仅在<code>-x</code>和<code>+x</code>所限制的区域，echo $i的调试信息才会被打印出来。  </p>
<p>  有一些环境变量常用于调试：<br>  <code>LINENO</code> - 返回它在脚本里面的行号<br>  <code>FUNCNAME</code> - 返回一个数组，内容是当前的函数调用堆栈。该数组的0号成员是当前调用的函数，1号成员是调用当前函数的函数，以此类推<br>  <code>BASH_SOURCE</code> - 返回一个数组，内容是当前的脚本调用堆栈。该数组的0号成员是当前执行的脚本，1号成员是调用当前脚本的脚本，以此类推，跟变量<code>FUNCNAME</code>是一一对应关系<br>  <code>BASH_LINENO</code> - 返回一个数组，内容是每一轮调用对应的行号  </p>
<p>  <code>${BASH_LINENO[$i]}</code>跟<code>${FUNCNAME[$i]}</code>是一一对应关系，表示<code>${FUNCNAME[$i]}</code>在调用它的脚本文件<code>${BASH_SOURCE[$i+1]}</code>里面的行号</p>
</li>
<li><p>自定义格式  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">DEBUG</span></span>()</span><br><span class="line">{</span><br><span class="line">[ <span class="string">"<span class="variable">$_DEBUG</span>"</span> == <span class="string">"on"</span> ] &amp;&amp; <span class="variable">$@</span> || :</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..10}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">DEBUG <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  可以将调试功能置为”on”来运行上面的脚本：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ _DEBUG=on ./script.sh  </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>shebang  </p>
<p>  把<code>shebang</code>从<code>#!/bin/bash</code>改成<code>#!/bin/bash -xv</code>，这样一来，不用任何其他选项就可以启用调试功能了。 </p>
</li>
</ul>
<ul>
<li><p>注释  </p>
<p>  单行注释：<code>#</code><br>  多行注释：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">&lt;&lt;<span class="string">'!'</span></span><br><span class="line">commands</span><br><span class="line">...</span><br><span class="line">!</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">ps -aux</span><br></pre></td></tr></tbody></table></figure>

<p>用 <code>top</code> 命令动态查看进程。  </p>
<p>中断一个进程<code>Ctrl+c</code>。  </p>
<p>把一个进程放置到后台 (执行)：在程序命令之后，加上<code>&amp;</code>字符：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">xlogo &amp;</span><br></pre></td></tr></tbody></table></figure>

<p>shell 的任务控制功能给出了一种列出从我们终端中启动了的任务的方法。执行 <code>jobs</code> 命令，可以看到输出列表：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+ Running xlogo &amp;</span><br></pre></td></tr></tbody></table></figure>

<p>进程返回到前台：<br>一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 <code>Ctrl-c</code> 来中断它。为了让一个进程返回前台 (foreground)，这样使用 <code>fg</code> 命令：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+ Running xlogo &amp;</span><br><span class="line">$ <span class="built_in">fg</span> %1</span><br><span class="line">xlogo</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>fg</code> 命令，可以恢复程序到前台运行，或者用 <code>bg</code> 命令把程序移到后台。  </p>
<p>停止一个进程<code>Ctrl+z</code>：输入 <code>Ctrl-z</code>，可以停止一个前台进程。  </p>
<p>通过 <code>kill</code> 命令给进程发送信号。<br>通过 <code>killall</code> 命令给多个进程发送信号。  </p>
<h3 id="目录堆栈"><a href="#目录堆栈" class="headerlink" title="目录堆栈"></a>目录堆栈</h3><ul>
<li><p><code>cd -</code>  </p>
</li>
<li><p><code>pushd</code>, <code>popd</code>  </p>
<p>  希望记忆多重目录，可以使用<code>pushd</code>命令和<code>popd</code>命令。它们用来操作目录堆栈。<br>  <code>pushd</code>命令的用法类似<code>cd</code>命令，可以进入指定的目录：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">pushd</span> dirname</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令会进入目录dirname，并将该目录放入堆栈。<br>  <code>popd</code>命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录（即原来的第二条目录）。  </p>
<ul>
<li><p><code>-n</code><br>  表示仅操作堆栈，不改变目录。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">popd</span> -n</span><br></pre></td></tr></tbody></table></figure>
<p>  上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。  </p>
</li>
<li><p>整数参数  </p>
</li>
<li><p>目录参数  </p>
</li>
</ul>
</li>
<li><p><code>dirs</code>  </p>
<p>  <code>dirs</code>命令可以显示目录堆栈的内容，一般用来查看<code>pushd</code>和<code>popd</code>操作后的结果。  </p>
<p>  参数：  </p>
<pre><code>  `-c`：清空目录栈。  
  `-l`：用户主目录不显示波浪号前缀，而打印完整的目录。  
  `-p`：每行一个条目打印目录栈，默认是打印在一行。  
  `-v`：每行一个条目，每个条目之前显示位置编号（从0开始）。  
</code></pre>
</li>
</ul>
<h3 id="校验和核实"><a href="#校验和核实" class="headerlink" title="校验和核实"></a>校验和核实</h3><ul>
<li><p><code>md5sum</code>  </p>
<p>  将输出的校验和重定向到一个文件，然后用这个MD5文件核实数据的完整性：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ md5sum filename &gt; file_num.md5</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ md5sum -c file_sum.md5</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>sha1sum</code>  </p>
<p>  用法与md5sum类似：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sha1sum filename &gt; file_num.sha1</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sha1sum -c file_sum.sha1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h3><p><code>-t</code>参数 - 设置超时秒数<br><code>-p</code>参数 - 指定用户输入的提示信息<br><code>-a</code>参数 - 把用户的输入赋值给一个数组，从零号位置开始<br><code>-n</code>参数 - 指定只读取若干个字符作为变量值，而不是整行读取<br><code>-e</code>参数 - 允许用户输入的时候，使用ReadLine库提供的快捷键，比如自动补全<br>其他参数 - 其他参数功能  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">"Enter one or more values &gt; "</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"REPLY = '<span class="variable">$REPLY</span>'"</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">"What do you want? </span></span><br><span class="line"><span class="string">    1) AAA</span></span><br><span class="line"><span class="string">    2) BBB</span></span><br><span class="line"><span class="string">    3) CCC</span></span><br><span class="line"><span class="string">    Type your choice: "</span> MyChoice</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MyChoice</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="生成任意大小的文件"><a href="#生成任意大小的文件" class="headerlink" title="生成任意大小的文件"></a>生成任意大小的文件</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></tbody></table></figure>
<p>该命令会创建一个1MB大小的文件junk.data。<br><code>if</code>代表输入文件(Input File)，<code>of</code>代表输出文件(Output File)，<code>bs</code>代表以字节为单位的块大小(Block Size)，<code>count</code>代表需要被复制的块数。  </p>
<h3 id="压缩归档文件"><a href="#压缩归档文件" class="headerlink" title="压缩归档文件"></a>压缩归档文件</h3><p>选项<code>-a</code>指定从文件扩展名自动判断压缩格式。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tar -cavf archive.tar.gz [FILES]</span><br><span class="line">$ tar -cavf archive.tar.bz2 [FILES]</span><br><span class="line">$ tar -cavf archive.tar.lzma [FILES]</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tar -xvf archive.tar.gz</span><br><span class="line">$ tar -xvf archive.tar.bz2</span><br><span class="line">$ tar -xvf archive.tar.lzma</span><br></pre></td></tr></tbody></table></figure>

<h3 id="mktemp命令"><a href="#mktemp命令" class="headerlink" title="mktemp命令"></a>mktemp命令</h3><p><code>mktemp</code>命令就是为安全创建临时文件而存在的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。  </p>
<p>Bash脚本使用<code>mktemp</code>命令的用法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<p>为了确保临时文件创建成功，<code>mktemp</code>命令后面最好使用OR运算符<code>||</code>，保证创建失败时退出脚本。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp) || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>
<p>为了保证脚本退出时临时文件被删除，可以使用<code>trap</code>命令指定退出时的清除操作。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">'rm -f "$TMPFILE"'</span> EXIT</span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp) || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>mktemp</code>命令的参数：<br><code>-d</code>参数可以创建一个临时目录。<br><code>-p</code>参数可以指定临时文件所在的目录。默认是使用$TMPDIR环境变量指定的目录，如果这个变量没设置，那么使用/tmp目录。<br><code>-t</code>参数可以指定临时文件的文件名模板。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mktemp -t mytemp.XXXXXXX -p <span class="built_in">test</span>/</span><br></pre></td></tr></tbody></table></figure>


<h3 id="trap命令"><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h3><p><code>trap</code>命令用来在Bash脚本中响应系统信号。<br><code>trap</code>的命令格式如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">trap</span> [动作] [信号1] [信号2] ...</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，”动作”是一个Bash命令，”信号”常用的有以下几个。<br>HUP：编号1，脚本与所在的终端脱离联系。<br>INT：编号2，用户按下 Ctrl + C，意图让脚本终止运行。<br>QUIT：编号3，用户按下 Ctrl + 斜杠，意图退出脚本。<br>KILL：编号9，该信号用于杀死进程。<br>TERM：编号15，这是kill命令发出的默认信号。<br>EXIT：编号0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。  </p>
<p><code>trap</code>命令响应EXIT信号的写法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">trap</span> <span class="string">'rm -f "$TMPFILE"'</span> EXIT</span><br></pre></td></tr></tbody></table></figure>
<p>上面命令中，脚本遇到EXIT信号时，就会执行rm -f “$TMPFILE”。  </p>
<p>trap命令的常见使用场景，就是在Bash脚本中指定退出时执行的清理命令。<br>注意，trap命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。  </p>
<p>如果trap需要触发多条命令，可以封装一个Bash函数。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> egress {</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	command3</span><br><span class="line">}</span><br><span class="line"><span class="built_in">trap</span> egress EXIT</span><br></pre></td></tr></tbody></table></figure>


<h3 id="set命令-shopt命令"><a href="#set命令-shopt命令" class="headerlink" title="set命令,shopt命令"></a>set命令,shopt命令</h3><p><strong>set -u</strong> - 遇到不存在的变量就会报错，并停止执行<br><strong>set -x</strong> - 在运行结果之前，先输出执行的那一行命令<br>脚本当中如果要关闭命令输出，可以使用<code>set +x</code>。  </p>
<p>Bash的错误处理<br>如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令。这种行为很不利于脚本安全和除错。<br>实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> || <span class="built_in">exit</span> 1</span><br></pre></td></tr></tbody></table></figure>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。<br>写法一：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> || { <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; }</span><br></pre></td></tr></tbody></table></figure>
<p>写法二：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>
<p>写法三：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> -ne 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>

<p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">command1 &amp;&amp; command2</span><br></pre></td></tr></tbody></table></figure>

<p><strong>set -e</strong><br>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code>从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。<br><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>。  </p>
<p>还有一种方法是使用command || true，使得该命令即使执行失败，脚本也不会终止执行  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">foo || <span class="literal">true</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，true使得这一行语句总是会执行成功，后面的echo bar会执行。  </p>
<p><strong>set -o pipefail</strong><br><code>set -e</code>有一个例外情况，就是不适用于管道命令。<br>所谓管道命令，就是多个子命令通过管道运算符<code>|</code>组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。<br><code>set -o pipefail</code>用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。  </p>
<p><strong>set -E</strong><br>一旦设置了<code>-e</code>参数，会导致函数内的错误不会被<code>trap</code>命令捕获。<br><code>-E</code>参数可以纠正这个行为，使得函数也能继承<code>trap</code>命令。  </p>
<p><strong>其他参数</strong>  </p>
<p><code>set</code>命令总结：<br>上面重点介绍的<code>set</code>命令的几个参数，一般都放在一起使用：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -Eeuxo pipefail</span><br></pre></td></tr></tbody></table></figure>
<p>建议放在所有Bash脚本的头部。  </p>
<p><code>shopt</code>命令<br><code>shopt</code>命令用来调整 Shell 的参数，跟<code>set</code>命令的作用很类似。<br><code>shopt</code>命令后面跟着参数名，可以查询该参数是否打开。<br><code>shopt</code>命令的使用方法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s [optionname] <span class="comment">#打开某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -u [optionname] <span class="comment">#关闭某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> [optionname] <span class="comment">#查询某个参数关闭还是打开</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>我们可以用管道将一个命令的<code>stdout</code>(标准输出)重定向到另一个命令的<code>stdin</code>(标准输入)。例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">cat foo.txt | grep <span class="string">"test"</span></span><br></pre></td></tr></tbody></table></figure>
<p>但是，有些命令只能以命令行参数的形式，而无法通过<code>stdin</code>接受数据流。在这种情况下，我们没法用管道来提供那些只有通过命令行参数才能提供的数据。  </p>
<p><code>xargs</code>能够处理<code>stdin</code>并将其转换为特定命令的命令行参数；<code>xargs</code>也可以将单行或多行文本输入转换成其他格式，例如单行变多行或是多行变单行。  </p>
<p><code>-d</code>: 为输入指定一个定制的定界符。<br><code>-n</code>: 指定每行最大的参数数量。<br><code>-I</code>: 指定一个替换字符串，对于每一个参数，命令都会被执行一次。  </p>
<p>例子1：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X  </span><br><span class="line">split split split split  </span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X -n 2  </span><br><span class="line">split split  </span><br><span class="line">split split  </span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>

<p>例子2：<br>有一个cecho.sh脚本：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#文件名：cecho.sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $*<span class="string">'#'</span></span><br></pre></td></tr></tbody></table></figure>

<p>有一个args.txt文件：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat args.txt  </span><br><span class="line">arg1  </span><br><span class="line">arg2  </span><br><span class="line">arg3  </span><br></pre></td></tr></tbody></table></figure>

<p>试试如下用法：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat args.txt | xargs -I {} ./cecho.sh -p {} -l  </span><br><span class="line">-p arg1 -l <span class="comment">#  </span></span><br><span class="line">-p arg2 -l <span class="comment">#  </span></span><br><span class="line">-p arg3 -l <span class="comment">#  </span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><code>less</code> - 浏览文件内容<br><code>which</code> - 查找可执行文件的绝对路径<br><code>whereis</code> - 查找命令、二进制文件、man文件、源代码文件<br><code>wc</code> - 打印行数、字数和字节数<br><code>diff/patch</code>    </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ diff -Naur old_file new_file &gt; diff_file  </span><br><span class="line">$ patch &lt; diff_file  </span><br></pre></td></tr></tbody></table></figure>

<p><code>history</code> - 显示历史列表内容<br><code>df</code> - 显示磁盘分区上可以使用的磁盘空间<br><code>du</code> - 显示每个文件和目录的磁盘使用空间<br><code>free</code> - 显示内存<br><code>file</code> - 识别文件类型<br><code>sort</code> - 排序文本行<br><code>uniq</code> - 报道或省略重复行<br><code>cut</code> - 从每行中删除文本区域<br><code>paste</code> - 合并文件文本行<br><code>join</code> - 基于某个共享字段来联合两个文件的文本行<br><code>comm</code> - 逐行比较两个有序的文件<br><code>tr</code> - 翻译或删除字符<br><code>grep</code> - 打印匹配行<br><code>ln file link</code> - 创建硬链接<br><code>ln -s item link</code> - 创建链接符号，item可以是一个文件或是一个目录<br>    当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中， <code>ls</code>命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。<br>    当建立符号链接时，你既可以使用绝对路径名，也可用相对路径名。<br>    不同目录，创建链接符号需要绝对地址，否则也是坏链接，会提示找不到文件。<br><code>rsync</code> - 备份/同步<br><code>time</code> - 计算命令执行时间<br><code>find</code> - 在一个目录层次结构中搜索文件<br><code>touch</code> - 更改文件时间<br><code>stat</code> - 显示文件或文件系统状态<br><code>alias</code> - 别名  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> install=<span class="string">'sudo apt-get install'</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>date</code> - 获取、设置日期<br><code>sleep</code> - 延时  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><a href="https://bbs.csdn.net/topics/394186543">[Linux资讯] Cshell 怎样实现变量名包含变量名？</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://man.linuxde.net/">Linux命令大全</a>  </li>
<li><a href="https://www.linuxcool.com/pronunciation">中国程序员最容易读错的单词汇总（带正确发音示范）</a>  </li>
<li><a href="https://blog.csdn.net/ljlfather/article/details/105106875">Bash Shell 中的 算术运算符、逻辑与或非(&amp; | ！)运算符、整数关系运算符、字符串关系运算符、文件或目录测试运算符</a></li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>script</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>定义新的Property</title>
    <url>/2020/11/19/customize-property/</url>
    <content><![CDATA[<p>自定义新属性。<dd23>  </dd23></p>
<span id="more"></span>


<p><span class="github-emoji"><span>👇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>希望新增自定义的属性，单纯使用  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">android.os.SystemProperties.set(<span class="string">"json.smarttv.config.order.backlight.home"</span>,<span class="string">"80"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>会报错：  </p>
<blockquote>
<p>libc    : Unable to set property “json.smarttv.config.order.backlight.home” to “80”: error code: 0x18  </p>
</blockquote>
<p>需要在device/realtek/common/sepolicy/property_contexts定义自己的属性  </p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">json. </span>                          u:object_r:<span class="keyword">json_prop:s0 </span> </span><br></pre></td></tr></tbody></table></figure>

<p>在device/realtek/common/sepolicy/property.te定义新增加的json_prop域  </p>
<figure class="highlight ada"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">json_prop, </span>property_type;  </span><br></pre></td></tr></tbody></table></figure>

<p>重新编译运行，可能还会有错。<br>可能还需要补充权限，比如：<br>修改device/realtek/common/sepolicy/hal_smarttv_default.te：  </p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line">set<span class="constructor">_prop(<span class="params">hal_smarttv_default</span>, <span class="params">json_prop</span>)</span>;  </span><br><span class="line">get<span class="constructor">_prop(<span class="params">hal_smarttv_default</span>, <span class="params">json_prop</span>)</span>;  </span><br></pre></td></tr></tbody></table></figure>
<p>修改device/realtek/common/sepolicy/system_app.te：  </p>
<figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line">allow system_app json_prop:file { read open getattr map };  </span><br></pre></td></tr></tbody></table></figure>

<p>[参考]<br><a href="https://www.itread01.com/content/1546437184.html">system.prop新增自己的欄位</a><br><a href="https://my.oschina.net/u/4339087/blog/3306403">Android coredomain 如何使用自定义的 property type？</a>  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>Android10 super.img解包方法</title>
    <url>/2020/11/19/extract-super-img/</url>
    <content><![CDATA[<p>如题。  </p>
<span id="more"></span>


<p>对于super.img，这份Android10的代码提供了system/extras/partition_tools工具，mmm system/extras/partition_tools会在out/host/linux-x86/bin目录（全编代码后，out/host/linux-x86/bin/目录下的工具基本齐全了。登录终端后，进android代码根目录执行source build/envsetup.sh;lunch后，lpunpack这些命令都可以直接像系统命令跑 了，不用加路径）生成lpdump、lpflash、lpmake、lpunpack文件。其中：  </p>
<ul>
<li>lpdump displays pretty-printed partition metadata.  </li>
<li>lpflash writes a non-sparse image from lpmake to a block device.   </li>
<li>lpmake is a command-line tool for generating a “super” partition image.  </li>
<li>lpunpack is a command-line tool for extracting partition images from super.  </li>
</ul>
<p>直接解编译出来的super.img包看看：<br>执行命令：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ lpunpack super.img  </span><br></pre></td></tr></tbody></table></figure>
<p>得到  </p>
<blockquote>
<p>lpunpack E 11-19 17:09:36 233504 233504 reader.cpp:77] [liblp]Logical partition metadata has invalid geometry magic signature.<br>lpunpack E 11-19 17:09:36 233504 233504 reader.cpp:77] [liblp]Logical partition metadata has invalid geometry magic signature.<br>This image appears to be a sparse image. It must be unsparsed to be unpacked.  </p>
</blockquote>
<p>解包失败，需要将super.img转换成unsparsed格式。  </p>
<p>Android提供了system/core/libsparse工具，mmm system/core/libsparse可在out/host/linux-x86/bin目录得到simg2img文件，这个工具可以将sparse格式转换成unsparsed格式。  </p>
<p>先转换格式：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ simg2img super.img super.raw.img  </span><br></pre></td></tr></tbody></table></figure>

<p>再解包：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ lpunpack super.raw.img  </span><br></pre></td></tr></tbody></table></figure>

<p>得到odm.img、product.img、system.img、vendor.img这4个文件。  </p>
<p>顺便用lpdump工具dump一下unsparsed格式的super.img，执行命令：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ lpdump super.raw.img  </span><br></pre></td></tr></tbody></table></figure>

<p>可以得到：  </p>
<blockquote>
<p>Metadata version: 10.0<br>Metadata size: 592 bytes<br>Metadata max size: 65536 bytes<br>Metadata slot count: 2<br>Partition table:  </p>
<hr>
<p>  Name: system<br>  Group: realtek_dynamic_partitions<br>  Attributes: readonly<br>  Extents:<br>    0 .. 1734399 linear super 2048  </p>
<hr>
<p>  Name: vendor<br>  Group: realtek_dynamic_partitions<br>  Attributes: readonly<br>  Extents:<br>    0 .. 496975 linear super 1736704  </p>
<hr>
<p>  Name: product<br>  Group: realtek_dynamic_partitions<br>  Attributes: readonly<br>  Extents:<br>    0 .. 664919 linear super 2234368  </p>
<hr>
<p>  Name: odm<br>  Group: realtek_dynamic_partitions<br>  Attributes: readonly<br>  Extents:<br>    0 .. 1295 linear super 2899968  </p>
<hr>
<h2 id="Block-device-table"><a href="#Block-device-table" class="headerlink" title="Block device table:  "></a>Block device table:  </h2><p>  Partition name: super<br>  First sector: 2048<br>  Size: 2147483648 bytes<br>  Flags: none  </p>
<hr>
<h2 id="Group-table"><a href="#Group-table" class="headerlink" title="Group table:  "></a>Group table:  </h2><p>  Name: default<br>  Maximum size: 0 bytes<br>  Flags: none  </p>
<hr>
<p>  Name: realtek_dynamic_partitions<br>  Maximum size: 2147483648 bytes<br>  Flags: none  </p>
<hr>
</blockquote>
<p>确实是有这4个分区。  </p>
<p>看下文件属性：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ file *  </span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>odm.img:       Linux rev 1.0 ext2 filesystem data, UUID=e1cf857c-334d-40cb-aa89-7634b14a39a2, volume name “odm” (extents) (large files) (huge files)<br>product.img:   Linux rev 1.0 ext2 filesystem data, UUID=9e1933ad-3f1b-4441-a314-f95987dc6c29, volume name “product” (extents) (large files) (huge files)<br>super.img:     data<br>super.raw.img: data<br>system.img:    Linux rev 1.0 ext2 filesystem data, UUID=3dab5a90-e84d-4e0c-a1e1-cc8779c3e0b2 (extents) (large files) (huge files)<br>vendor.img:    Linux rev 1.0 ext2 filesystem data, UUID=830ef149-3c4e-4455-ad55-f80faad5c8e1, volume name “vendor” (extents) (large files) (huge files)  </p>
</blockquote>
<p>如果查看各个分区的文件？<br>Linux rev 1.0 ext2 filesystem data 这个类型的文件可以直接mount：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ mkdir vendor_partition; mount vendor.img vendor_partition  </span><br></pre></td></tr></tbody></table></figure>

<p>或者在Windows平台用7zip工具直接打开（右键-&gt;7-Zip-&gt;打开压缩包）。  </p>
<p>至此，算是解包完成了。  </p>
<p>最后贴一个纯Windows平台的教程：  </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/J5cQdzivtXk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>  

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>Android:一个菜单刷新很慢的问题</title>
    <url>/2020/10/30/android-ui-update-slowly/</url>
    <content><![CDATA[<p>低端打工人之日常疑惑。  </p>
<span id="more"></span>


<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>一个串口自动化测试程序：<br>是一个服务：<code>FactoryAutomationService</code> （FactoryAutomationService.java文件）<br>服务启动之后准备创建子线程：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> FactoryUartThread mFacUartThread;  </span><br><span class="line">mFacUartThread = <span class="keyword">new</span> FactoryUartThread(<span class="keyword">this</span>);  </span><br><span class="line">mFacUartThread.startChangHongUartThread();  </span><br></pre></td></tr></tbody></table></figure>

<p>具体创建了子线程：（FactoryUartThread.java文件）  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Thread changhongUartThread;  </span><br><span class="line">changhongUartThread = <span class="keyword">new</span> Thread(ChangHongUartTest);  </span><br><span class="line">changhongUartThread.start();  </span><br></pre></td></tr></tbody></table></figure>

<p>子线程主要干的事情是<code>handleChangHongFactoryCommand</code>:  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable ChangHongUartTest = <span class="keyword">new</span> Runnable() {  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">while</span> (RunChangHongUartThread) {  </span><br><span class="line">	    <span class="comment">//...  </span></span><br><span class="line">	    handleChangHongFactoryCommand(ReceiveBuffer);  </span><br><span class="line">	    <span class="comment">//...  </span></span><br><span class="line">	}  </span><br><span class="line">    }  </span><br><span class="line">};  </span><br></pre></td></tr></tbody></table></figure>

<p><code>handleChangHongFactoryCommand</code>里面拿到正常的数据后，要刷新菜单，这个时候通过<code>handler</code>切换主线程去刷新菜单，如果有一些耗时的比如保存数据等操作，则还是在原来的子线程上操作。<br>如果测试完毕，要关闭<code>FactoryAutomationService</code>服务了，会关子线程，  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">changhongUartThread.join();  </span><br></pre></td></tr></tbody></table></figure>
<p><code>join()</code>会阻塞主线程，等子线程结束，保证数据存储完成，主线程可以继续跑下去。  </p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>在子线程<code>handleChangHongFactoryCommand</code>中有如下代码：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line">saveChangHongColorTemp(getcommand[<span class="number">2</span>]); <span class="comment">//刷新菜单</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    刷新菜单的实现如下：</span></span><br><span class="line"><span class="comment">    Log.d(TAG, "System.currentTimeMillis() = " + System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">    mHandlerComands.post(new Runnable() {</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">	public void run() {</span></span><br><span class="line"><span class="comment">	    Log.d(TAG, "AAA");</span></span><br><span class="line"><span class="comment">	    Log.d(TAG, "System.currentTimeMillis() = " + System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">	    showRGBValue(cTyte, r_value, g_value, b_value);</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">    });</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mHandler.post(<span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        Log.d(TAG, <span class="string">"BBB"</span>);</span><br><span class="line">	GetSys().SetValueInt(<span class="string">"Misc_PRE_SAVE_TEMP_VALUE"</span>, getcommand[<span class="number">2</span>]&amp;<span class="number">0xFF</span>); <span class="comment">//数据存储。按理说不应切到主线程？</span></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>以上写法，菜单要等一会才会被刷新出来。<br>稍作修改：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写法2</span></span><br><span class="line">saveChangHongColorTemp(getcommand[<span class="number">2</span>]); <span class="comment">//刷新菜单</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    刷新菜单的实现如下:</span></span><br><span class="line"><span class="comment">    Log.d(TAG, "System.currentTimeMillis() = " + System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">    mHandlerComands.post(new Runnable() {</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">	public void run() {</span></span><br><span class="line"><span class="comment">	    Log.d(TAG, "AAA");</span></span><br><span class="line"><span class="comment">	    Log.d(TAG, "System.currentTimeMillis() = " + System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">	    showRGBValue(cTyte, r_value, g_value, b_value);</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">    });</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">GetSys().SetValueInt(<span class="string">"Misc_PRE_SAVE_TEMP_VALUE"</span>, getcommand[<span class="number">2</span>]&amp;<span class="number">0xFF</span>); <span class="comment">//数据存储</span></span><br></pre></td></tr></tbody></table></figure>

<p>菜单刷新就很及时，为什么？<br>正常来说，耗时操作应该放在子线程，所以要按照写法2写代码。<br>但是如果按照写法1的话，为什么菜单刷新变慢了？看打印是先打印AAA，再打印BBB，刷新菜单的操作没有被存储数据的操作阻塞，那么它是堵在哪？不懂啊。  </p>
<p>顺便一提，无论是写法1还是写法2，System.currentTimeMillis()时间差都是25左右。  </p>
<p>再修改下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写法3</span></span><br><span class="line">saveChangHongColorTemp(getcommand[<span class="number">2</span>]); <span class="comment">//刷新菜单</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    刷新菜单的实现如下：</span></span><br><span class="line"><span class="comment">    showRGBValue(cTyte, r_value, g_value, b_value);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mHandler.post(<span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        GetSys().SetValueInt(<span class="string">"Misc_PRE_SAVE_TEMP_VALUE"</span>, getcommand[<span class="number">2</span>]&amp;<span class="number">0xFF</span>); <span class="comment">//数据存储</span></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>这样，菜单刷新跟写法2一样快。但是风险点在于子线程刷新UI，以及把耗时操作放到主线程。  </p>
<p>总结起来就是：刷新菜单和存储数据不在同一个线程，菜单就能正常刷新。菜单刷新在主线程，数据存储在子线程，所以写法2较为更为合理。  </p>
<p>问题在于，写法1是怎么阻塞的？可能要了解一下handler原理？  </p>
<h4 id="rocket"><a href="#rocket" class="headerlink" title=":rocket:"></a><span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>判断是否是主线程还是子线程：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getId()) == Looper.getMainLooper().getThread().getId();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>thread</tag>
        <tag>ui</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TV 蓝牙遥控适配</title>
    <url>/2020/09/17/android-bluetooth-remote/</url>
    <content><![CDATA[<p>HID(Human Interface Device)设备，即人机交互设备。常见的有鼠标、键盘、游戏手柄等。一般有线方式都是通过USB连线连接到机器设备，作为用户输入设备。在蓝牙技术中，HID设备的接入就是无线的。所以客户的蓝牙遥控器也是HID设备，本文记录蓝牙遥控器适配方法。  </p>
<span id="more"></span>


<p>通过客户提供的文档或者<code>getevent</code>命令（遥控跟TV需要先匹配上）确定遥控的HID码值（不是红外码值），比如按下语音键会得到如下信息：<br><code>getevent</code>:  </p>
<blockquote>
<p>/dev/input/event3: 0004 0004 000c0221<br>/dev/input/event3: 0001 00d9 00000001<br>/dev/input/event3: 0000 0000 00000000<br>/dev/input/event3: 0004 0004 000c0221<br>/dev/input/event3: 0001 00d9 00000000<br>/dev/input/event3: 0000 0000 00000000  </p>
</blockquote>
<p><code>getevent -l</code>:  </p>
<blockquote>
<p>/dev/input/event3: EV_MSC       MSC_SCAN             000c0221<br>/dev/input/event3: EV_KEY       KEY_SEARCH           DOWN<br>/dev/input/event3: EV_SYN       SYN_REPORT           00000000<br>/dev/input/event3: EV_MSC       MSC_SCAN             000c0221<br>/dev/input/event3: EV_KEY       KEY_SEARCH           UP<br>/dev/input/event3: EV_SYN       SYN_REPORT           00000000  </p>
</blockquote>
<p>通过上述打印可以得到如下信息：<br>0221是这个按键的HID码值，page类型是000c，00d9是这个Linux的键值（对应了KEY_SEARCH这个名字，这个名字起得很疑惑，明明是语音功能<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）。  </p>
<p>KEY_SEARCH是在kernel/linux/linux-4.14/include/uapi/linux/input-event-codes.h这个文件定义的：  </p>
<blockquote>
<p>#define KEY_SEARCH              217  </p>
</blockquote>
<p>十进制的217就是等于十六进制的d9。  </p>
<p>通过kernel/linux/linux-4.14/drivers/hid/hid-input.c这个文件:  </p>
<blockquote>
<p>case 0x221: map_key_clear(KEY_SEARCH);          break;  </p>
</blockquote>
<p>把HID码值跟Linux键值匹配在一起。  </p>
<p>蓝牙键值有不同类型，“07”代表普通蓝牙键值，“0C”代表多媒体键值，“0C”类型需要修改hid-input.c的<code>HID_UP_CONSUMER</code>，“07”类型则需要修改<code>hid_keyboard[256]</code>。  </p>
<p>现在知道了HID码值（0x0221）及其对应的Linux键值(0xd9)(217)了，但是功能实现还需要Android键值。Linux键值与Android键值是通过<code>kl</code>文件匹配的。怎么知道是哪个kl文件？  </p>
<p>通过<code>cat /proc/bus/input/devices</code>命令确认遥控器的<code>Vendor</code>ID和<code>Product</code>ID  </p>
<blockquote>
<p>I: Bus=0005 Vendor=1d5a Product=c081 Version=0000<br>N: Name=”H016A001”<br>P: Phys=<br>S: Sysfs=/devices/virtual/misc/uhid/0005:1D5A:C081.0001/input/input3<br>U: Uniq=20:19:10:23:00:f6<br>H: Handlers=event3<br>B: PROP=0<br>B: EV=12001f<br>B: KEY=1 8000000 0 3007f 0 0 0 0 403ffff 17aff32d bf540446 0 0 1 130f97 8b17e007 ffff7bfa d9415fff febeffd7 ffefffff ffffffff fffffffe<br>B: REL=40<br>B: ABS=1 0<br>B: MSC=10<br>B: LED=3ff  </p>
</blockquote>
<p>所以需要的kl文件是：Vendor_1d5a_Product_c081.kl<br>该文件有如下信息：  </p>
<blockquote>
<p>key 217   VOICE_ASSIST  </p>
</blockquote>
<p>Android Framework会把VOICE_ASSIST转化成Android键值，实现对应的功能。<br>Framework改到的文件有如下4个：<br><img src="https://i.loli.net/2020/09/17/x5E4wOcneVz7BJ9.png" alt="android_keycode.png">  </p>
<p>到此，基本适配完成了。  </p>
<p>另外，dumpsys input还可以得到如下信息：  </p>
<blockquote>
<p>4: H016A001<br>Classes: 0x80000121<br>Path: /dev/input/event3<br>Enabled: true<br>Descriptor: 83b91aadd3b6814a870f118082cde683c34f199e<br>Location:<br>ControllerNumber: 0<br>UniqueId: 20:19:10:23:00:f6<br>Identifier: bus=0x0005, vendor=0x1d5a, product=0xc081, version=0x0000<br>KeyLayoutFile: /system/usr/keylayout/Vendor_1d5a_Product_c081.kl<br>KeyCharacterMapFile: /system/usr/keychars/Generic.kcm<br>ConfigurationFile:<br>HaveKeyboardLayoutOverlay: false  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>bluetooth</tag>
        <tag>hid</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/09/14/quick-sort/</url>
    <content><![CDATA[<p>快速排序，基本思想是：通过一趟排序将要排序的数据分割成独立两部分，其中一部分的所有数据都比另外一部分的所有数据小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序数列。  </p>
<span id="more"></span>


<p><span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>一趟快速排序的算法是：  </p>
<ol>
<li>设置两个变量i、j，排序开始的时候：i=0，j=N-1；  </li>
<li>以第一个数组元素作为关键数据，赋值给key，即key=A[0]；  </li>
<li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的A[j]，将A[j]的值赋给A[i]；  </li>
<li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]的值赋给A[j]；  </li>
<li>重复第3、4步，直到i=j。  </li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> tmp = src[left];</span><br><span class="line">	src[left] = src[right];</span><br><span class="line">	src[right] = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partArray</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> pivot = src[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; src[high] &gt;= pivot)</span><br><span class="line">		{</span><br><span class="line">			high--;</span><br><span class="line">		}</span><br><span class="line">		swap(src,low,high);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; src[low] &lt;= pivot)</span><br><span class="line">		{</span><br><span class="line">			low++;</span><br><span class="line">		}</span><br><span class="line">		swap(src,low,high);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_quick_sort</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> pivot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(low &lt;= high)</span><br><span class="line">	{</span><br><span class="line">		pivot = partArray(src,low,high);</span><br><span class="line">		do_quick_sort(src,low,pivot<span class="number">-1</span>);</span><br><span class="line">		do_quick_sort(src,pivot+<span class="number">1</span>,high);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	do_quick_sort(src, <span class="number">0</span>, length<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">        quick_sort(a,length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>搜台与解析</title>
    <url>/2020/09/10/tuning/</url>
    <content><![CDATA[<p>搜台与解析的概念。  </p>
<span id="more"></span>


<h2 id="搜台"><a href="#搜台" class="headerlink" title="搜台"></a><strong>搜台</strong></h2><h3 id="两种搜台方式"><a href="#两种搜台方式" class="headerlink" title="两种搜台方式"></a>两种搜台方式</h3><h4 id="AFT"><a href="#AFT" class="headerlink" title="AFT"></a>AFT</h4><p>自动频率微调电路。主要是依据AFT反馈电压来判别当前频点与正确频点的接近情况。它的任务是保证图像中频信号的频率固定在规定的38MHz标准值上，从而使图像及伴音处于最佳状态。  </p>
<p>获得AFT反馈电压的两种方式：  </p>
<ol>
<li>外接比较电路。当图像中频偏离38MHz时，AFT电路检测这种频率偏移，并将频率偏移转换成直流误差控制电压，去调节本振电路的震荡频率，使图像中频恢复到38MHz上。  </li>
<li>Tuner内置AD，通过I2C从Tuner芯片中获得。  </li>
</ol>
<h4 id="AFC"><a href="#AFC" class="headerlink" title="AFC"></a>AFC</h4><p>自动频率控制。在搜台过程中，频率进入AFC可控范围前提下，通过读取Tuner的AFC状态寄存器，来判断当前频点与正确频点相差多少，从而直接加减相应的频点即可。<br>这种搜台算法与AFT算法相比，搜台会更快更准。  </p>
<p><img src="https://i.loli.net/2020/09/09/fldZ8jAH1FeuNI5.png" alt="变频的方法.png">  </p>
<p>总结：<br>写Tuner频点，检测同步信号输入端，判断是否存在稳定的同步信号，如果存在，判断AFT电压是否为标准值/Tuner AFC状态寄存器，如果是，则存台，判断图像、声音制式并进行相应设置，该频点搜台结束。  </p>
<p>无法搜台：<br>排查信号是否正常，Tuner是否能正常初始化，Tuner I2C通信是否正常，Tuner的晶振、中频和AGC管脚配置是否和硬件一致。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wenku.baidu.com/view/bd0cefd133d4b14e85246882.html">Tuner搜台基础</a><br><a href="https://wenku.baidu.com/view/168d33e60975f46527d3e126.html">电视机搜台原理</a><br><a href="https://wenku.baidu.com/view/3b771f8b84868762caaed514">自动搜台原理</a>  </p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h2><h3 id="TS流"><a href="#TS流" class="headerlink" title="TS流"></a>TS流</h3><ul>
<li>ES流：基本码流，不分段的音频、视频或其他信息的连续码流。  </li>
<li>PES流： 把基本流ES分割成段，并加上相应头文件打包成形的打包基本码流。  </li>
<li>PS流： 节目流，将具有共同时间基准的一个或多个PES组合（复合）而成的单一数据流（用于播放或编辑系统，如m2p）。  </li>
<li>TS流： 传输流，将具有共同时间基准或独立时间基准的一个或多个PES组合（复合）而成的单一数据流（用于数据传输）。  </li>
</ul>
<p>TS流的包结构长度是固定的，PQ流的包结构长度是可变的，TS流的抵抗传输误码能力强于PS流。  </p>
<p>视频ES和音频ES分别打包成视频PES和音频PES，PES再复用成TS传输流。  </p>
<p>TS流是基于Packet的位流格式，由n个包组成。每个包由Packet Header和Packet Data组成。其中Packet Header指示了该Packet是什么属性的，并给出了该Packet Data的数据的唯一网络标识符PID。如果一个TS流中的一个Packet的Packet Header中的PID是0x0000，那么这个Packet的Packet Data就是DVB的PAT表而非其他类型数据（如Video、Audio或其他业务信息）。  </p>
<h3 id="功能表"><a href="#功能表" class="headerlink" title="功能表"></a>功能表</h3><h4 id="业务与事件"><a href="#业务与事件" class="headerlink" title="业务与事件"></a>业务与事件</h4><p>按照普通人的习惯来说，CCTV1是一个频道，但其标准说法应该是“业务(Service)”，《新闻联播》是一个节目，其标准说法是“事件(Event)”。  </p>
<p>“Channel”指的是“频点”或者“信道”，每个“Channel”里会有一个或多个“Service”。  </p>
<h4 id="PSI-SI-Table"><a href="#PSI-SI-Table" class="headerlink" title="PSI/SI Table"></a>PSI/SI Table</h4><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">全称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PAT</td>
<td align="left">节目关联表</td>
<td align="left">将节目号码和节目映射表PID相关联，获取数据的开始</td>
</tr>
<tr>
<td align="left">PMT</td>
<td align="left">节目映射表</td>
<td align="left">指定一个或多个节目的PID</td>
</tr>
<tr>
<td align="left">CAT</td>
<td align="left">条件接收表</td>
<td align="left">将一个或多个专用EMM流分别与唯一的PID相关联</td>
</tr>
<tr>
<td align="left">NIT</td>
<td align="left">网络信息表</td>
<td align="left">描述整个网络，如多少TS流、频点和调制方式等信息</td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2020/09/09/put7hxKGnPaQFE9.png" alt="SI.png">  </p>
<p>PSI只提供了单个TS流的信息，使接收机能够对单个TS流中的不同节目进行解码。 但是，它不能提供多个TS流的相关业务，也不能提供节目的类型、节目名称、开始时间、节目简介等信息。 因此，DVB对PSI进行了扩展，提供了其他不同类型的表，形成了SI。  </p>
<p>SI定义的表，并不需要全部传输， 其中，SDT、EIT和TDT是必须传输的； 而又以SDT和EIT最为重要，利用这2个表可以构成功能不同的EPG， 如提供节目附加信息、节目分类、节目预定和家长分级控制等。  </p>
<p>通过PAT及其他PSI信息，我们可以一点一点地把整个TS流的信息组织和管理起来，从而分离出不同的业务(Service)， 以及该业务的视频、音频、图文(Teletext)、字幕(Subtitle)、其他音轨等分量；再根据SI信息，我们就可以得到每个业务的名称、事件(Event)等附加信息，从而形成EPG，更好地管理各个业务。  </p>
<p>Decoder在解析TS流的时候进行数据的同步，等待完整的Packet到来，首先寻找PAT表，根据PAT获取所有PMT表的PID；再寻找PMT表，获取该频段所有节目数据并保存。 这样，只需要知道节目的PID就可以根据PacketHeade给出的PID过滤出不同的Packet，从而观看不同的节目。 这些就是PAT表和PMT表之间的关系。  </p>
<h4 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h4><ul>
<li>PAT表描述TS流中有几个节目，以及它们的PMT PID分别是多少。通过program_map_PID找到了对应的PMT表。  </li>
<li>PMT表给出了节目号与组成这个节目元素之间的映射。通过program_number与SDT表中的service_id关联起来。    </li>
<li>NIT：搜索主频点的同时解析NIT表，就可以得到这个网络的频点列表，按顺序对这个列表的频点锁频、解析，就可以将整个网络的业务搜索出来。  </li>
<li>CAT表描述了节目的加密方式。  </li>
<li>SDT表将节目名称和该节目的PID对应起来。描述业务内容及信息，连接了NIT、EIT和PMT。    </li>
<li>EIT表按时间顺序提供每一个业务所包含的事件信息。通过service_id与SDT表中的service_id以及PMT表的program_number关联起来。  </li>
<li>TDT表仅传送UTC时间和日期信息。  </li>
<li>TOT表包含了UTC时间和日期信息，以及当地时间偏移（时差）等信息。  </li>
<li>BAT表将网络中的所有业务分成了多个业务群，以此界定用户。  </li>
</ul>
<p><img src="https://i.loli.net/2020/09/09/PEXyujYZ24xVUMh.png" alt="SI关联.png">  </p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.onelib.biz/doc/stb/">林晓州OneLib智库</a>  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>scan</tag>
        <tag>tuning</tag>
      </tags>
  </entry>
  <entry>
    <title>TV一些概念</title>
    <url>/2020/09/09/tv/</url>
    <content><![CDATA[<p>一些名词或概念。  </p>
<span id="more"></span>


<h3 id="AVC-AVL"><a href="#AVC-AVL" class="headerlink" title="AVC/AVL"></a>AVC/AVL</h3><p>自动音量控制。电视节目中的音频信号由于片源出自不同的电视台和采编单位，导致其音频水平不固定，因此容易出现在不调节电视音量的情况下，有的电视节目声音很大，有的电视节目又声音很小。使用AVC功能后，电视机可以根据节目输入的音量大小，自动调节输出音量水平，保持声音的稳定，减少或消除爆音，同时放大较小的声音至适宜的范围。  </p>
<h3 id="PreScale"><a href="#PreScale" class="headerlink" title="PreScale"></a>PreScale</h3><p>由于各个通道原始音量不尽相同，会先透过PreScale将各通道音量调整一致。  </p>
<h3 id="消隐"><a href="#消隐" class="headerlink" title="消隐"></a>消隐</h3><ul>
<li>行消隐：电子束在每一行从右边回到左边的时间  </li>
<li>场消隐：电子束从每一场的右下角回到左上角的时间。在场消隐期间可能输出一些CC或者TT等信息  </li>
</ul>
<h3 id="解调"><a href="#解调" class="headerlink" title="解调"></a>解调</h3><ul>
<li>高频头把射频信号解调成中频信号  </li>
<li>中频解调把中频信号解调成视频信号  </li>
<li>声音解调把SIF解调成声音信号  </li>
</ul>
<h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p>Closed Caption：美国在VBI里面传输的字幕信息，帮助聋哑人看电视  </p>
<h3 id="MTS"><a href="#MTS" class="headerlink" title="MTS"></a>MTS</h3><p>一个通用称呼，所有多声道伴音均可称作MTS。  </p>
<ul>
<li>NICAM是数字多声道伴音广播  </li>
<li>BTSC是模拟多声道伴音广播  </li>
<li>A2  </li>
<li>EIAJ  </li>
</ul>
<h3 id="AGC"><a href="#AGC" class="headerlink" title="AGC"></a>AGC</h3><p>自动增益控制。自动对增益进行控制来得到稳定的输出幅度。  </p>
<ul>
<li>在高频头内部，有射频AGC和中频AGC，来针对从40dBuV到100dBuV的射频信号都得到相近的中频输出  </li>
<li>在视频解码芯片内部，有视频AGC来针对不同幅度的视频信号进行增益控制，得到相同的信号输出。也就是说，不论你输入300mVpp还是1.5Vpp的视频信号，得到的输出幅度都是相等的  </li>
<li>对色度信号处理时，有AGC来完成类似的处理  </li>
</ul>
<p>ADC内部是没有AGC的，所以RGB信号和色差信号都被认为是标准幅度而不会进行AGC控制。  </p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>复合视频信号：包含同步信号、亮度信号、色度信号  </li>
<li>CVBS：复合视频基带信号  </li>
<li>分量信号：通常在数字领域称作YCbCr(Digital color difference signals)，模拟领域称作YPbPr(Analog color difference signals)<br><img src="https://i.loli.net/2020/09/09/KRrwjhmNSOe3YJs.png" alt="差分信号.png">  </li>
</ul>
<h3 id="DDC"><a href="#DDC" class="headerlink" title="DDC"></a>DDC</h3><p>指主机与显示设备的通讯方式。包括DDC1/DDC2B/DDC2B+等方式。目前主要采用DDC2B方式：主机与显示设备双向通讯，基于I2C协议，只有主机向显示器发出需求信号，并得到显示器的响应后，显示器才送出EDID资料。  </p>
<h3 id="Auto-Color"><a href="#Auto-Color" class="headerlink" title="Auto Color"></a>Auto Color</h3><p>VGA和YPBPR通道需要人爲做AUTO COLOR， 其它AV/S-VIDEO/TV通道是通過Video Decode內的digital clamping和digital gain做實時調整，不需要用人爲AUTO COLOR的方式。  </p>
<p>原理：在三路R/G/B or Y/Pb/Pr 模拟信号输入到主芯片时，由于存在硬件上的偏差，导致进入到芯片的信号范围和标准值有一定的差别，所以需要对输入信号进行ADC 校正，校验需要使100% colorbar图像，以保证进到主芯片的模拟输入信号符合标准；共有R/G/B GAIN（增益量）和R/G/B OFFSET（偏移量）六个参数。  </p>
<h3 id="音频数据"><a href="#音频数据" class="headerlink" title="音频数据"></a>音频数据</h3><ul>
<li>PCM数据：指经过解码后的数据或未经编码的裸数据  </li>
<li>透传数据：指编码数据没经过解码，直接封装IEC61937协议后往端口输出，由外围设备解码。透传数据分为低码率透传数据（简称LBR，主要有DD、DTS）和高码率透传数据（简称HBR，主要有DDP、DTSHD）。  </li>
</ul>
<h3 id="电视机的同步范围"><a href="#电视机的同步范围" class="headerlink" title="电视机的同步范围"></a>电视机的同步范围</h3><p>电视机的同步范围是指同步信号能够控制扫描电路的频率范围，要求行同步保持范围（图像保持同步的范围）在正负400Hz之间，行同步引入范围（从断开至接入信号时，图像引入同步范围）在正负200Hz之间，帧同步范围为-4~2Hz，保持同步的电源电压变化范围不超过正负10%。  </p>
<p>对于电视机的行扫描电路来说，当电视机的行频fH在某一频率范围内时，只要有同步脉冲存在，即使由于干扰而失去同步，也还能被“拉回”到与同步脉冲相同步的状态，这个行频fH的范围叫捕捉范围；当电视机已处于同步状态时，慢慢改变行频，在失去同步之前能够保持同步的fH范围叫保持范围。由于电视机中设有行频自动控制（AFC）电路，所以它的行频保持范围大于捕捉范围，如果没有AFC系统，则电视机的行频捕捉范围和保持范围是相同的。我国广播电视接收机的标准规定，甲级和乙级电视机的行同步捕捉范围分别为不小于正负400Hz和正负200Hz，行同步的保持范围分别为不小于正负800Hz和正负400Hz。  </p>
<h3 id="丽音"><a href="#丽音" class="headerlink" title="丽音"></a>丽音</h3><p>属于立体音的一种。  </p>
<ul>
<li>单声道方式： 两个声道分别传送一路声音信号和一路数据  </li>
<li>双语言方式： 传两路声音信号，适合于多语言、语种地区  </li>
<li>立体音方式： 两个数字通道分别传送立体声左右两个声道的声音信号  </li>
</ul>
<h3 id="Overscan"><a href="#Overscan" class="headerlink" title="Overscan"></a>Overscan</h3><p>过扫描。在电视系统中，为避免元器件的老化或者参数变化导致的影响，必须有一定的过扫描。也就是说，扫描的大小超过显示屏的大小，四周有一小部分的图像看不到。  </p>
<p>如果没有过扫描，在图像亮度变化时，由于束流变化，会导致图像扫描的区域变化，从而导致图像变小或者变大，显像管四周出现黑边。为避免这种情况，就需要一定的过扫描。  </p>
<p>点对点比例模式不做Overscan。  </p>
<p>USB/DVI/VGA通道不做Overscan。VGA是接电脑的，不是看电视用的；相当于在用电脑；电脑信号也不会出现杂波干扰。  </p>
<p><a href="https://wenku.baidu.com/view/bbb35dafd0f34693daef5ef7ba0d4a7302766c32.html">什么是点对点显示</a></p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
      </tags>
  </entry>
  <entry>
    <title>HDMI相关</title>
    <url>/2020/09/08/hdmi/</url>
    <content><![CDATA[<p>简单记录相关知识点。  </p>
<span id="more"></span>


<h2 id="PIN"><a href="#PIN" class="headerlink" title="PIN"></a>PIN</h2><p>HDMI引脚定义如图：<br><img src="https://i.loli.net/2020/09/08/m68ojqtpgZ9Ifn4.jpg" alt="HDMI引脚定义.jpg"><br><img src="https://i.loli.net/2020/09/08/jxsLhZ5eEn68VaT.jpg" alt="HDMI端子.jpg">  </p>
<p>其中  </p>
<ul>
<li>1-9是TMDS数据传输实际上用到的引脚，一共3组  </li>
<li>10-12为TMDS时钟信号  </li>
<li>13为CEC控制引脚  </li>
<li>14为保留引脚  </li>
<li>15-16是I2C引脚，用于DDC传输  </li>
<li>17接地  </li>
<li>18为5V供电  </li>
<li>19为Hotplug引脚  </li>
</ul>
<h2 id="Hotplug"><a href="#Hotplug" class="headerlink" title="Hotplug"></a>Hotplug</h2><p>热插拔，当接上接口时就可以判断设备是否存在，以进行后续工作。  </p>
<p>当计算机通过HDMI接口与显示器相连接时，主机通过HDMI的18脚向显示器供电，显示器接收到+5V电压后，通过内部电路使HDMI接口第19脚HPD转变为高电平，主机检测到HPD为高电平后，认为主机与显示器已经连接上，于是通过I2C读取显示器的EDID，满足条件后（比如显示器支持主机当前设置的分辨率），做HDCP交互认证，然后TMDS发送电路开始工作，输出图像和声音。  </p>
<p>其中有两种Hotplug相关的情况会导致HDMI被识别为DVI：  </p>
<ul>
<li>Hotplug为High，不过EDID并没有准备好，那么信号源设备会由于无法读到EDID而认为接收设备为DVI，这样会导致HDMI有图像无声的问题。  </li>
<li>Hotplug为Low，也会导致信号源无法读到EDID而认为接收设备为DVI，从而导致HDMI有图无声。  </li>
</ul>
<p>在TV这种有多个HDMI通道的情况下，有时会在多个HDMI通道进行切换，切换后HDMI通道应当先初始化，即先把Hotplug拉低，通知HDMI source device之前所用的EDID已经改变，需要重新读取，那么source device在Hotplug被拉高的时候会去读取新的EDID，但是拉低这个过程至少需要100ms，否则source device有可能不会去读取新的EDID，从而输出DVI信号。  </p>
<h2 id="EDID"><a href="#EDID" class="headerlink" title="EDID"></a>EDID</h2><p>相当于一个身份证，告诉主机，此显示器的参数、支持的特征。包括基本EDID和扩展EDID。存在于程序，由系统初始化，或存在与EEPROM。    </p>
<ul>
<li><p>EDID中有一块数据是VSDB（Vendor-Specific Data Block），如果包含IEEE分配给HDMI的固定数值，则认为是HDMI，否则被认为是DVI。<br>HDMI1.4b 的 VSDB (H14b VSDB): 第一个Byte，Length至少是5，最多31；接下来3个Byte是IEEE分配给HDMI的固定数值：030C00h；随后2个Byte是物理地址。以上是至少包含的信息，后续内容为Extension Field。<br><img src="https://i.loli.net/2020/09/08/YramXM9hlvwRT5b.png" alt="vsdb1.4.png"><br>HDMI2.0 的 VSDB (HF-VSDB): 第1个Byte，Length至少是5，最多31；接下来3个Byte是IEEE分配给HDMI的固定数值：D85DC4h；随后1个Byte是物理地址。以上是至少包含的信息，后续内容为Extension Field。<br><img src="https://i.loli.net/2020/09/08/yx9krTW7vdwBAIe.png" alt="vsdb2.0.png"><br>注意HF—VSDB不能与H14b VSDB相混淆、即使接收端支持HDMI2.0版本，也必须包含H14b VSDB（由HDMI H1.4b）定义，在E-EDID中是否包含是可选的。<br><img src="https://i.loli.net/2020/09/08/58NWlSXLdgszGJh.png" alt="vsdb.png">  </p>
</li>
<li><p>EDID中有一块数据描述了CEC物理地址。  </p>
</li>
</ul>
<h2 id="CEC"><a href="#CEC" class="headerlink" title="CEC"></a>CEC</h2><p>允许用户控制HDMI接口上所连接的设备。  </p>
<p>在HDMI CEC最小系统里，所有通过HDMI连接在一起的设备（包括电视、DVD、机顶盒等）在物理连接上，各自的CEC是全部连接在一起，可以看做，在一条CEC线（标准HDMI接口的第13引脚）上挂着所有的设备。  </p>
<p>Youtube上的一堂CEC课，讲得很不错。  </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Q6S2FabX2WA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>  

<h3 id="Handshake"><a href="#Handshake" class="headerlink" title="Handshake"></a>Handshake</h3><p>当一个带CEC功能的设备得到一个新的物理地址时，它将进行如下处理：</p>
<ol>
<li>主动申请分配与之设备类型相应的逻辑地址；  </li>
<li>通过广播<report physical="" address="">来报告它的物理地址与逻辑地址的绑定。  </report></li>
</ol>
<p><img src="https://i.loli.net/2020/09/08/U2xWgmBi4ktYTue.png" alt="CEC Physical Address.png"><br><img src="https://i.loli.net/2020/09/08/mGKIQEc9rLuOwgB.png" alt="CEC Physical Address Discovery.png"><br>Physical Address: Root display(TV) is always 0.0.0.0<br>Logical Address: Root display(TV) is always 0<br><img src="https://i.loli.net/2020/09/08/Jr1HthQoIkSEyY3.png" alt="CEC addressing.png"></p>
<p>CEC设备的逻辑地址也是动态分配的，其分配方式如下：  </p>
<ol>
<li>根节点（通常是TV）直接设逻辑地址：0；  </li>
<li>当设备A插入后，该设备的类型是已知的，因此可以为该设备A预设一个逻辑地址（如DVD，其预设地址为DVD1，即是4），并通过<polling message="">广播此地址；  </polling></li>
<li>当该逻辑地址已经被占用时，对应的占用设备会应答确认信息。设备A收到确认后，重设其他逻辑地址（如：DVD1-&gt;DVD2），并广播<polling message="">；  </polling></li>
<li>当检测到没有确认时，此逻辑地址可用，因此设备A占用此逻辑地址；  </li>
<li>占用后，发送广播<report physical="" address="">，其中包含了其物理地址和逻辑地址，声明对地址的占用。若询问一圈后，逻辑地址均被占用，则设备A的逻辑地址为15。  </report></li>
</ol>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>总线保持高电平是闲态（IDLE）；<br>要发送消息，看总线是否空闲？如果是，则拉低总线电平，发送，否则，延迟发送；<br>一条CEC具体传输的指令：起始信号（一个3.7ms低电平+一个0.8ms高电平）+头部数据（起始设备的逻辑地址+接收设备的逻辑地址）+操作码+操作数。  </p>
<p>因为，所有设备的CEC都挂在一条线上，所以，大家都能看到所有指令。如果头部数据里的接收逻辑地址是和自己相关的，此设备就会对操作码进行响应，如果头部数据里的接收逻辑地址和自己无关，此设备就忽略这个指令。  </p>
<p>CEC通信信息结构模块包括：Header引导块和Data数据块。所有的Header块和Data块都是10bit大小。  </p>
<p>Header = 源逻辑地址(source) + 目的逻辑地址(destination) + 信息结束位(EOM) + 应答位(ACK)<br>Data = 操作码(opcode)/操作数(operand) + EOM(End of Message) + ACK(Acknowledge)<br>EOM: 0表示还有一个或更多的数据块，1表示消息已完整<br><img src="https://i.loli.net/2020/09/08/qz5T7dAIv9inhM3.png" alt="CEC Message Structure.png"><br><img src="https://i.loli.net/2020/09/08/gsplSfNFZCeovx3.png" alt="CEC Protocol.png">  </p>
<p>例子：Standby指令：起始信号+00FF+0x36；其中，00表示电视的逻辑地址，FF表示广播地址，这里表示所有接收设备的集合，36表示Standby待机操作。此条指令可以翻译为：电视告诉所有设备，大家都进入待机状态。  </p>
<h2 id="HDCP"><a href="#HDCP" class="headerlink" title="HDCP"></a>HDCP</h2><p>HDCP用于保护版权视频，通过DDC传输。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.znds.com/forum.php?mod=viewthread&amp;tid=825004&amp;page=1">干货知识：一篇文看懂HDMI1.0到HDMI2.1的规格变化</a><br><a href="https://www.cnblogs.com/TaigaCon/p/3840653.html">HDMI介绍与流程</a><br><a href="https://www.cnblogs.com/zhongguo135/p/9197995.html">HDMI之HPD</a><br><a href="https://www.cnblogs.com/zhongguo135/p/9458884.html">HDMI EDID 处理过程</a>  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>edid</tag>
        <tag>hdmi</tag>
        <tag>cec</tag>
      </tags>
  </entry>
  <entry>
    <title>新建分区</title>
    <url>/2020/08/05/new-android-partition/</url>
    <content><![CDATA[<p>可能有遗漏。  </p>
<span id="more"></span>


<p>添加分区，修改kernel/android/android-10/vendor/realtek/tool/image_file_creator/configs/Frigga_2851a.cfg，添加  </p>
<figure class="highlight apache"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">part14</span> = smarttv /smarttv ext<span class="number">4</span> package<span class="number">7</span>/smarttv.tar.bz<span class="number">2</span> <span class="number">67108864</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>编译系统升级测试，这个时候，执行cat /proc/partitions应该能看到新添加的分区，但是df -h却看不到这个分区有挂载上来；  </p>
<p>需要一个挂载点，文件系统根目录需要一个smarttv目录，用于挂载，  </p>
<p>修改system/core/rootdir/Android.mk文件，添加如下：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">LOCAL_POST_INSTALL_CMD += ; mkdir -p <span class="variable">$(TARGET_ROOT_OUT)</span>/smarttv</span><br></pre></td></tr></tbody></table></figure>

<p>添加目录权限，修改device/realtek/common/sepolicy/file_contexts，添加如下：  </p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#smarttv partition</span></span><br><span class="line"><span class="regexp">/smarttv(/</span>.*)?          u:object_r:rtk_data_file:s0</span><br></pre></td></tr></tbody></table></figure>

<p>光有挂载点还不够，挂载规则呢？需要修改device/realtek/common/root/rtd2851a/fstab.gsi<br>添加如下：  </p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="regexp">/dev/</span>block<span class="regexp">/by-name/</span>smarttv    /smarttv      ext4 noatime,defaults               defaults</span><br></pre></td></tr></tbody></table></figure>

<p>还需要挂载动作，这个在device/realtek/common/root/rtd2851a/init.gsi.rc已经做好了：  </p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line">on fs</span><br><span class="line">    mount_all <span class="regexp">/system/</span>etc/fstab.gsi</span><br></pre></td></tr></tbody></table></figure>

<p>系统起来需要执行一次restorecon_recursive /smarttv，用于重新加载sepolicy context，否则分区可能无法正常读写，会有  </p>
<blockquote>
<p>[2020/11/9 星期一 9:27:02] 01-01 00:00:19.826   338   338 D SmartTVService: SmartTvInit::SmartTvInit<br>[2020/11/9 星期一 9:27:02] 01-01 00:00:19.809   338   338 W vendor.realtek.: type=1400 audit(0.0:15): avc: denied { search } for name=”/“ dev=”mmcblk0p14” ino=2 scontext=u:r:hal_smarttv_default:s0 tcontext=u:object_r:unlabeled:s0 tclass=dir permissive=0  </p>
</blockquote>
<p>这种报错信息。  </p>
<p>修改device/realtek/common/root/rtd2851a/init.rtd2851a.rc  </p>
<figure class="highlight dart"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="keyword">late</span>-fs</span><br><span class="line">    restorecon_recursive /tvconfigs</span><br><span class="line">    restorecon_recursive /smarttv</span><br></pre></td></tr></tbody></table></figure>
<p>注意restorecon_recursive这个动作要做在mount之后。  </p>
<p>编译系统升级测试，df -h应该能看到新建的分区挂载信息。  </p>
<p>完。  </p>
<p>[参考]<br><a href="https://blog.csdn.net/ZC_25/article/details/104027721">[AOSP]Android 9.0添加分区unlabeled的原因分析及解决办法</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>HIDL demo</title>
    <url>/2020/08/04/hidl-demo/</url>
    <content><![CDATA[<p>简单记录，可以直接使用。</p>
<span id="more"></span>

<h3 id="1-添加hal目录、定义hal接口"><a href="#1-添加hal目录、定义hal接口" class="headerlink" title="1.添加hal目录、定义hal接口"></a>1.添加hal目录、定义hal接口</h3><figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ mkdir -p vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default</span><br><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/IHello.hal</span><br></pre></td></tr></tbody></table></figure>

<p>接口如下：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//IHello.hal</span></span><br><span class="line"></span><br><span class="line">package vendor.realtek.hello@<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">interface IHello {</span><br><span class="line">    <span class="built_in">helloWorld</span> (string name) <span class="built_in">generates</span> (string result);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-根据hal自动生成cpp实现"><a href="#2-根据hal自动生成cpp实现" class="headerlink" title="2.根据hal自动生成cpp实现"></a>2.根据hal自动生成cpp实现</h3><figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ source build/envsetup.sh</span><br><span class="line">foo@bar:~$ lunch</span><br><span class="line">foo@bar:~$ make hidl-gen</span><br><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/genImpHidl.sh</span><br><span class="line">foo@bar:~$ chmod u+x vendor/realtek/common/ATV/hardware/interfaces/hello/genImpHidl.sh</span><br><span class="line">foo@bar:~$ ./vendor/realtek/common/ATV/hardware/interfaces/hello/genImpHidl.sh</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">//genImpHidl.sh</span><br><span class="line"></span><br><span class="line">PACKAGE=vendor.realtek.hello@1.0</span><br><span class="line">LOC=vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default</span><br><span class="line"></span><br><span class="line">hidl-gen -o $LOC -Lc++-impl -rvendor.realtek:vendor/realtek/common/ATV/hardware/interfaces \</span><br><span class="line">    -randroid.hidl:system/libhidl/transport $PACKAGE</span><br><span class="line">hidl-gen -o $LOC -Landroidbp-impl -rvendor.realtek:vendor/realtek/common/ATV/hardware/interfaces \</span><br><span class="line">    -randroid.hidl:system/libhidl/transport $PACKAGE</span><br></pre></td></tr></tbody></table></figure>

<p>执行genImpHidl.sh后，default目录生成Android.bp、Hello.cpp和Hello.h文件。  </p>
<p><img src="https://i.loli.net/2020/08/04/KfyYMuRGtl16PSD.png" alt="1_genImplHidl.png">  </p>
<p>编写Hello.cpp  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default/Hello.cpp</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Hello.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> your file license if you have one</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> vendor {</span><br><span class="line"><span class="keyword">namespace</span> realtek {</span><br><span class="line"><span class="keyword">namespace</span> hello {</span><br><span class="line"><span class="keyword">namespace</span> V1_0 {</span><br><span class="line"><span class="keyword">namespace</span> implementation {</span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods from ::vendor::realtek::hello::V1_0::IHello follow.</span></span><br><span class="line"><span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">Hello::helloWorld</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, helloWorld_cb _hidl_cb)</span> </span>{</span><br><span class="line">    <span class="comment">// TODO implement</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    ::<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    ::<span class="built_in">snprintf</span>(buf, <span class="number">100</span>, <span class="string">"Hello World, %s"</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="function">hidl_string <span class="title">result</span><span class="params">(buf)</span></span>;</span><br><span class="line">    _hidl_cb(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IHello* HIDL_FETCH_IHello(const char* /* name */) {</span></span><br><span class="line">    <span class="comment">//return new Hello();</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">}  <span class="comment">// namespace implementation</span></span><br><span class="line">}  <span class="comment">// namespace V1_0</span></span><br><span class="line">}  <span class="comment">// namespace hello</span></span><br><span class="line">}  <span class="comment">// namespace realtek</span></span><br><span class="line">}  <span class="comment">// namespace vendor</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>HIDL的实现有两种方式，如果打开HIDL_FETCH的注释，就是passthrough，否则是Binderized方式，这里使用默认的Binderized方式。  </p>
<h3 id="3-开机启动服务"><a href="#3-开机启动服务" class="headerlink" title="3.开机启动服务"></a>3.开机启动服务</h3><p>添加service.cpp文件；  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default/service.cpp</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//service.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"vendor.realtek.hello@1.0-service"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vendor/realtek/hello/1.0/IHello.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/HidlTransportSupport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> android::hardware::configureRpcThreadpool;</span><br><span class="line"><span class="keyword">using</span> android::hardware::joinRpcThreadpool;</span><br><span class="line"><span class="keyword">using</span> vendor::realtek::hello::V1_0::IHello;</span><br><span class="line"><span class="keyword">using</span> vendor::realtek::hello::V1_0::implementation::Hello;</span><br><span class="line"><span class="keyword">using</span> android::sp;</span><br><span class="line"><span class="keyword">using</span> android::<span class="keyword">status_t</span>;</span><br><span class="line"><span class="keyword">using</span> android::OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> vendor::realtek::hello::V1_0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> tune the max thread count.</span></span><br><span class="line">    <span class="built_in">configureRpcThreadpool</span>(<span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">    sp&lt;IHello&gt; mHello = <span class="keyword">new</span> <span class="built_in">Hello</span>();</span><br><span class="line">    <span class="keyword">status_t</span> status = mHello-&gt;<span class="built_in">registerAsService</span>();</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(status != OK, <span class="string">"Could not register IHello"</span>);</span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">"IHello vendor.realtek.hello@1.0-service start\n"</span>);</span><br><span class="line">    <span class="comment">// other interface registration comes here</span></span><br><span class="line">    <span class="built_in">joinRpcThreadpool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>添加<a href="mailto:vendor.realtek.hello@1.0-service.rc">vendor.realtek.hello@1.0-service.rc</a>文件；  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default/vendor.realtek.hello@1.0-service.rc</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">//vendor.realtek.hello@1.0-service.rc</span><br><span class="line">service hello-1-0 /vendor/bin/hw/vendor.realtek.hello@1.0-service</span><br><span class="line">    class hal</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br></pre></td></tr></tbody></table></figure>

<p>修改Android.bp；  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default/Android.bp</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">//hello/1.0/default/Android.bp</span><br><span class="line"></span><br><span class="line">// FIXME: your file license if you have one</span><br><span class="line"></span><br><span class="line">cc_library_shared {</span><br><span class="line">    // FIXME: this should only be -impl for a passthrough hal.</span><br><span class="line">    // In most cases, to convert this to a binderized implementation, you should:</span><br><span class="line">    // - change '-impl' to '-service' here and make it a cc_binary instead of a</span><br><span class="line">    //   cc_library_shared.</span><br><span class="line">    // - add a *.rc file for this module.</span><br><span class="line">    // - delete HIDL_FETCH_I* functions.</span><br><span class="line">    // - call configureRpcThreadpool and registerAsService on the instance.</span><br><span class="line">    // You may also want to append '-impl/-service' with a specific identifier like</span><br><span class="line">    // '-vendor' or '-&lt;hardware identifier&gt;' etc to distinguish it.</span><br><span class="line">    name: <span class="string">"vendor.realtek.hello@1.0-impl"</span>,</span><br><span class="line">    relative_install_path: <span class="string">"hw"</span>,</span><br><span class="line">    // FIXME: this should be 'vendor: true' for modules that will eventually be</span><br><span class="line">    // on AOSP.</span><br><span class="line">    proprietary: true,</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">"Hello.cpp"</span>,</span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">"libhidlbase"</span>,</span><br><span class="line">	<span class="string">"libhidltransport"</span>,</span><br><span class="line">	<span class="string">"libutils"</span>,</span><br><span class="line">	<span class="string">"vendor.realtek.hello@1.0"</span>,</span><br><span class="line">    ],</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cc_binary {</span><br><span class="line">    name: <span class="string">"vendor.realtek.hello@1.0-service"</span>,</span><br><span class="line">    defaults: [<span class="string">"hidl_defaults"</span>],</span><br><span class="line">    proprietary: true,</span><br><span class="line">    relative_install_path: <span class="string">"hw"</span>,</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">"Hello.cpp"</span>,</span><br><span class="line">	<span class="string">"service.cpp"</span></span><br><span class="line">    ],</span><br><span class="line">    init_rc: [<span class="string">"vendor.realtek.hello@1.0-service.rc"</span>],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">"liblog"</span>,</span><br><span class="line">	<span class="string">"libhidlbase"</span>,</span><br><span class="line">	<span class="string">"libhidltransport"</span>,</span><br><span class="line">	<span class="string">"libutils"</span>,</span><br><span class="line">	<span class="string">"libcutils"</span>,</span><br><span class="line">	<span class="string">"libbinder"</span>,</span><br><span class="line">	<span class="string">"vendor.realtek.hello@1.0"</span>,</span><br><span class="line">    ],</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-生成hal接口的Android-bp"><a href="#4-生成hal接口的Android-bp" class="headerlink" title="4.生成hal接口的Android.bp"></a>4.生成hal接口的Android.bp</h3><p>看下update-makefiles.sh内容是什么：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">source system/tools/hidl/update-makefiles-helper.sh</span><br><span class="line"></span><br><span class="line">do_makefiles_update \</span><br><span class="line">    "vendor.realtek:vendor/realtek/common/ATV/hardware/interfaces" \</span><br><span class="line">    "android.hidl:system/libhidl/transport"</span><br></pre></td></tr></tbody></table></figure>

<p>执行该脚本：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ ./vendor/realtek/common/ATV/hardware/interfaces/update-makefiles.sh</span><br></pre></td></tr></tbody></table></figure>

<p>1.0目录就生成了Android.bp文件。  </p>
<p><img src="https://i.loli.net/2020/08/04/zIsYiW4gtxKh5Ue.png" alt="2_update-makefiles.png">  </p>
<h3 id="5-更新哈希值"><a href="#5-更新哈希值" class="headerlink" title="5.更新哈希值"></a>5.更新哈希值</h3><p>编写genHash.sh  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/genHash.sh</span><br><span class="line">foo@bar:~$ chmod u+x vendor/realtek/common/ATV/hardware/interfaces/hello/genHash.sh</span><br><span class="line">foo@bar:~$ ./vendor/realtek/common/ATV/hardware/interfaces/hello/genHash.sh</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">PACKAGE=vendor.realtek.hello@1.0::IHello</span><br><span class="line"></span><br><span class="line">hidl-gen -L hash -rvendor.realtek:vendor/realtek/common/ATV/hardware/interfaces/ -randroid.hidl:system/libhidl/transport $PACKAGE</span><br></pre></td></tr></tbody></table></figure>

<p>把输出的hash添加到current.txt  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim ./vendor/realtek/common/ATV/hardware/interfaces/current.txt</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-添加client测试"><a href="#6-添加client测试" class="headerlink" title="6.添加client测试"></a>6.添加client测试</h3><p>添加如下目录和文件：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ mkdir -p vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/vts/functional</span><br><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/vts/functional/VtsHalHelloV1_0TargetTest.cpp</span><br><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/vts/functional/Android.bp</span><br></pre></td></tr></tbody></table></figure>

<p>以下是其内容：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">cc_test {</span><br><span class="line">    name: <span class="string">"VtsHalHelloV1_0TargetTest"</span>,</span><br><span class="line">    defaults: [<span class="string">"hidl_defaults"</span>],</span><br><span class="line">    srcs: [<span class="string">"VtsHalHelloV1_0TargetTest.cpp"</span>],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">"libbase"</span>,</span><br><span class="line">	<span class="string">"libhidlbase"</span>,</span><br><span class="line">	<span class="string">"liblog"</span>,</span><br><span class="line">	<span class="string">"libutils"</span>,</span><br><span class="line">	<span class="string">"vendor.realtek.hello@1.0"</span>,</span><br><span class="line">    ],</span><br><span class="line">    static_libs: [<span class="string">"VtsHalHidlTargetTestBase"</span>],</span><br><span class="line">    cflags: [</span><br><span class="line">        <span class="string">"-O0"</span>,</span><br><span class="line">	<span class="string">"-g"</span>,</span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//VtsHalHelloV1_0TargetTest.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"HelloHidlHalTest"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;VtsHalHidlTargetTestBase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android-base/logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vendor/realtek/hello/1.0/IHello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> vendor::realtek::hello::V1_0::IHello;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_string;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_vec;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::Return;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::Void;</span><br><span class="line"><span class="keyword">using</span> ::android::sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    sp&lt;IHello&gt; hello = IHello::<span class="built_in">getService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hello == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">"Failed to get hello service\n"</span>);</span><br><span class="line">	ret = <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        hello-&gt;<span class="built_in">helloWorld</span>(<span class="string">"Hikari"</span>, [&amp;](hidl_string result) {</span><br><span class="line">	    <span class="built_in">ALOGD</span>(<span class="string">"%s\n"</span>,result.<span class="built_in">c_str</span>());</span><br><span class="line">	});</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-添加hello目录的Android-bp"><a href="#7-添加hello目录的Android-bp" class="headerlink" title="7.添加hello目录的Android.bp"></a>7.添加hello目录的Android.bp</h3><p><span style="color:red"> 跑update-makefiles.sh的时候为啥没有生成这个？ </span> 跟rtk代码makefile架构有关吗。</p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/Android.bp</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">// This is an autogenerated file, do not edit.</span><br><span class="line">subdirs = [</span><br><span class="line">    <span class="string">"1.0"</span>,</span><br><span class="line">    <span class="string">"1.0/vts/functional"</span>,</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-小编"><a href="#8-小编" class="headerlink" title="8.小编"></a>8.小编</h3><p>hello最终文件架构如下：<br><img src="https://i.loli.net/2020/08/04/jSbq4dc63CHeI7D.png" alt="3_end.png">  </p>
<p>小编试试添加的hello能不能编过：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ mmm vendor/realtek/common/ATV/hardware/interfaces/hello/</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-注册hello并添加进编译"><a href="#9-注册hello并添加进编译" class="headerlink" title="9.注册hello并添加进编译"></a>9.注册hello并添加进编译</h3><p>注册：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/manifest.xml</span><br></pre></td></tr></tbody></table></figure>

<p>添加内容如下：  </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hal</span> <span class="attr">format</span>=<span class="string">"hidl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>vendor.realtek.hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>IHello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>编译：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/product/rtk_base.mk</span><br></pre></td></tr></tbody></table></figure>

<p>添加内容如下：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">PRODUCT_PACKAGES += \</span><br><span class="line">    vendor.realtek.hello@1.0 \</span><br><span class="line">    vendor.realtek.hello@1.0-impl \</span><br><span class="line">    vendor.realtek.hello@1.0-impl \</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-添加seLinux规则"><a href="#10-添加seLinux规则" class="headerlink" title="10.添加seLinux规则"></a>10.添加seLinux规则</h3><p>如果没有此步骤，开机之后<a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a>会跑不起来。<br>修改file_contexts文件  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/sepolicy/file_contexts</span><br></pre></td></tr></tbody></table></figure>
<p>补充如下：</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="regexp">/(vendor|system/</span>vendor)<span class="regexp">/bin/</span>hw/vendor\.realtek\.hello@<span class="number">1</span>\.<span class="number">0</span>-service        u:object_r:hal_hello_default_exec:s0</span><br></pre></td></tr></tbody></table></figure>

<p>修改hwservice_contexts文件  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/sepolicy/hwservice_contexts</span><br></pre></td></tr></tbody></table></figure>
<p>补充如下：  </p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">vendor<span class="selector-class">.realtek</span><span class="selector-class">.hello</span>::IHello        u:object_r:hal_hello_service:s0</span><br></pre></td></tr></tbody></table></figure>

<p>修改hwservice.te文件  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/sepolicy/hwservice.te</span><br></pre></td></tr></tbody></table></figure>
<p>补充如下：  </p>
<figure class="highlight ada"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">hal_hello_service,   </span>hwservice_manager_type;</span><br></pre></td></tr></tbody></table></figure>

<p>添加hal_hello_default.te文件  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/sepolicy/hal_hello_default.te</span><br></pre></td></tr></tbody></table></figure>
<p>内容如下：  </p>
<figure class="highlight ceylon"><table><tbody><tr><td class="code"><pre><span class="line">type hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span>, domain;</span><br><span class="line">type hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span><span class="number">_</span>exec, exec<span class="number">_</span>type, vendor<span class="number">_f</span>ile<span class="number">_</span>type, file<span class="number">_</span>type;</span><br><span class="line"></span><br><span class="line">init<span class="number">_</span>daemon<span class="number">_</span>domain(hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span>);</span><br><span class="line"></span><br><span class="line">hwbinder<span class="number">_u</span>se(hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span>)</span><br><span class="line">add<span class="number">_</span>hwservice(hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span>, hal<span class="number">_</span>hello<span class="number">_</span>service)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hwservicemanager<span class="number">_p</span>rop:file r<span class="number">_f</span>ile<span class="number">_p</span>erms;</span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hwservicemanager:binder { transfer call };</span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hal<span class="number">_</span>hello<span class="number">_</span>service:binder call;</span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hal<span class="number">_</span>hello<span class="number">_</span>service:hwservice<span class="number">_m</span>anager { add find };</span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hidl<span class="number">_</span>base<span class="number">_</span>hwservice:hwservice<span class="number">_m</span>anager add;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>到此为止，开机之后服务依然有可能跑不起来，可以dmesg查看权限相关的avc报错，把相关的报错修掉之后，还有可能跑不起来，直接运行./vendor/bin/hw/<a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a>，把avc denied修掉，应该就可以了。如果不确定是不是权限问题引起，可以先setenforce 0后直接运行服务，如果能跑起来，那么就是权限有问题。另外，客户端调用的时候如果看不到效果，可以先用client（参考第6点）调试。  </p>
<h3 id="11-全编代码验证"><a href="#11-全编代码验证" class="headerlink" title="11.全编代码验证"></a>11.全编代码验证</h3><p>开机可以看到<a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a>的log：  </p>
<blockquote>
<p>01-01 01:01:03.490   328   328 I ServiceManagement: Registered <a href="mailto:vendor.realtek.hello@1.0">vendor.realtek.hello@1.0</a>::IHello/default (start delay of 261ms)<br>01-01 01:01:03.491   328   328 I ServiceManagement: Removing namespace from process name <a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a> to <a href="mailto:hello@1.0-service">hello@1.0-service</a>.<br>01-01 01:01:03.491   328   328 D <a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a>: IHello <a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a> start  </p>
</blockquote>
<p>在data/nativetest/VtsHalHelloV1_0TargetTest目录可以找到VtsHalHelloV1_0TargetTest文件，这个就是测试client，执行这个程序：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ ./data/nativetest/VtsHalHelloV1_0TargetTest/VtsHalHelloV1_0TargetTest</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到：  </p>
<blockquote>
<p>08-04 10:06:24.211  2063  2063 D HelloHidlHalTest: Hello World, Hikari  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>demo</tag>
        <tag>hidl</tag>
      </tags>
  </entry>
  <entry>
    <title>boot到kernel的传递</title>
    <url>/2020/08/03/uboot-kernel/</url>
    <content><![CDATA[<p>理解不深，简单记录一下。</p>
<span id="more"></span>


<p>新IC出来了，要移植配置，有个问题是，增减遥控器，无作用。遥控解码是在内核处理的，debug发现：配置里没有选上的遥控器，内核也有在解析，因为ir_table用的是内核里配置的，新ir_table不是在内核里面配置的，所以我们分离出来的定制配置没有效果，所以要把内核的ir_table改成由我们定制的配置的ir_table，那要怎么做呢？定制的新ir_table在上电的时候，在boot被解析，然后被填到<code>arch/arm/include/asm/arch-rtk/system.h</code>的这个地址<code>POWER_ON_IR_TABLE_ADDR</code>。这个地址出干嘛的：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* Memory for power on music, video, and image. Include stream buffer and decode buffer */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_ON_IR_TABLE_ADDR                  (0x1ffff000)    <span class="comment">// 0x1ffff000 ~ 0x20000000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_ON_IR_TABLE_SIZE                  (0x1000 - 128 - 8)              <span class="comment">// 4k</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_ON_KEYPAD_TABLE_ADDR              (POWER_ON_IR_TABLE_ADDR + POWER_ON_IR_TABLE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_ON_KEYPAD_TABLE_SIZE              (128 + 8)</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个是共享内存的物理地址，内核可以从这里拿到东西。  </p>
<p>但是内核怎么知道地址是多少？强制定义也可以（感觉不会有问题）。这里是通过<code>cmdline</code>把东西传给内核，看看boot的启动参数：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">console:/ # cat /proc/cmdline                                                  </span><br><span class="line">androidboot.console=ttyS1 console=ttyS1,115200 androidboot.dtbo_idx=0 bufsize=80000  envp=e4100 wdt=&lt;NULL&gt;  flashtype=emmc mmcparts=rtkemmc:304927k,2097152k(/super),4718592k(/userdata),281808k(/cache),1024k(/persist),1024k(/misc),16384k(/metadata),32768k(/boot),32768k(/recovery),8192k(/dtbo),16384k(/tvconfigs),32768k(/tvdata),24576k(/impdata),1024k(/vbmeta),65536k(/smarttv)  androidboot.boot_devices=18010800.emmc loop.max_part=7 buildvariant=userdebug initrd=0x10000000,0xbd000 keepinitrd reclaim=54M@40M last_image=8M@160M VIP=2M@766M OD=8M@768M bootcode_git_version=c422e6b no_console_suspend androidboot.vbmeta.device=179:13 androidboot.vbmeta.avb_version=1.1 androidboot.vbmeta.device_state=locked androidboot.vbmeta.hash_alg=sha256 androidboot.vbmeta.size=3968 androidboot.vbmeta.digest=7d27ba8f742e398b5827d4a1ab61aec26e4f0ee5192105877cad1e8ebb960359 androidboot.vbmeta.invalidate_on_error=yes androidboot.veritymode=enforcing androidboot.verifiedbootstate=green androidboot.hardware.sku=ATV00003919R01 loglevel=4 earlyprintk androidboot.bootreason=watchdog chip=RTD2851A chip_model=4K androidboot.serialno=001020304050 irda=1-hk irda_powerup=74,221,189,16e,2f5,2f6 irda1=7-hk dvfs_low=0xC6 dvfs_high=0xFD rtk_rcs=0x4eff000 ir_table=0x1ffff000</span><br></pre></td></tr></tbody></table></figure>

<p>可以找到ir_table=0x1ffff000，内核怎么做？<br>通过<code>early_param</code>解析拿到地址：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">venus_ir_input_table_addr_parse</span><span class="params">(<span class="keyword">char</span> *options)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ir_table_phy_address = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(options == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(options, <span class="string">"%lx"</span>, &amp;ir_table_phy_address) != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    g_ir_boot_memory_address = ir_table_phy_address;</span><br><span class="line">    IR_INFO(<span class="string">"g_ir_boot_memory_address == %lx\n"</span>, g_ir_boot_memory_address);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">early_param(<span class="string">"ir_table"</span>, venus_ir_input_table_addr_parse);</span><br></pre></td></tr></tbody></table></figure>

<p>把物理地址转换成虚拟地址，并拿到ir_table：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">venus_ir_input_early_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *ir_boot_table = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//carvedout_buf_query(CARVEDOUT_IR_TABLE, &amp;ir_boot_table);</span></span><br><span class="line">    <span class="keyword">if</span>(g_ir_boot_memory_address) {</span><br><span class="line">        ir_boot_table = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)phys_to_virt (g_ir_boot_memory_address);</span><br><span class="line">	<span class="keyword">if</span>(!ir_boot_table) {</span><br><span class="line">	    g_ir_boot_memory_address = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	IR_INFO(<span class="string">"venus_ir_input__table_parse: %px, %x,%d\n"</span>, ir_boot_table, ir_boot_table[<span class="number">0</span>], ir_boot_table[<span class="number">1</span>]);</span><br><span class="line">	rwlock_init(&amp;g_ir_user_key_table.lock);</span><br><span class="line">	g_ir_user_key_table.keys = (IR_USER_KEY *)(ir_boot_table + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ir_boot_table[<span class="number">0</span>] == <span class="number">0x49525442</span> &amp;&amp;  ir_boot_table[<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; ir_boot_table[<span class="number">1</span>] &lt;= MAX_IR_USER_KEY_NUM) {</span><br><span class="line">	    g_ir_user_key_table.size = ir_boot_table[<span class="number">1</span>];</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">	    g_ir_user_key_table.size = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	g_ir_user_key_table.is_init = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/RyanLiu_/article/details/78925515">高通平台aboot通过shared memory保存uart log到kernel</a>  </li>
<li><a href="https://blog.csdn.net/sgmenghuo/article/details/41251739?utm_source=copy">linux驱动——cmdline原理及利用</a>  </li>
<li><a href="https://www.cnblogs.com/tlnshuju/p/6851812.html">linux kernel的cmdline參数解析原理分析</a>  </li>
<li><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/46711601">谈高端内存和低端内存</a>  </li>
<li><a href="https://blog.csdn.net/tienham/article/details/9493615">ioremap 和 phys_to_virt区别</a>  </li>
<li><a href="https://blog.csdn.net/angle_birds/article/details/8804033">Linux驱动修炼之道-内存映射 mmap()/phys_to_virt()</a>  </li>
<li><a href="https://wenku.baidu.com/view/0319a8c408a1284ac85043d4.html">虚拟地址转换为物理地址</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>boot</tag>
        <tag>kernel</tag>
        <tag>cmdline</tag>
      </tags>
  </entry>
  <entry>
    <title>dlopen failed处理</title>
    <url>/2020/07/15/dlopen-failed/</url>
    <content><![CDATA[<p>如题</p>
<span id="more"></span>


<p>使用的是Android7.1平台。<br>应用本来是系统预置的，但是有些客户需要做推送。使用U盘安装测试的时候，闪退。AndroidRuntime报错：  </p>
<blockquote>
<p>java.lang.UnsatisfiedLinkError: dlopen failed: library “/system/lib/librtk-mediaplayer_jni.so” needed<br>or dlopened by “/system/lib/libnativeloader.so” is not accessible for the namespace “classloader-namespace”  </p>
</blockquote>
<p>找到librtk-mediaplayer_jni.so在系统中的/system/lib目录，修改代码/system/core/libnativeloader/native_loader.cpp文件，把  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kWhitelistedDirectories = <span class="string">"/data:/mnt/expand"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>改成  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kWhitelistedDirectories = <span class="string">"/data:/mnt/expand:/system/lib"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>编译、升级、测试，运行时有新的报错提示：  </p>
<blockquote>
<p>java.lang.UnsatisfiedLinkError: dlopen failed: library “libutils.so” not found  </p>
</blockquote>
<p>找到系统的/system/etc/public.libraries.txt文件，发现其中没有libutils.so，通过  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ su</span><br><span class="line">foo@bar:~$ mount -o rw,remount /</span><br><span class="line">foo@bar:~$ mount -o rw,remount /system</span><br><span class="line">foo@bar:~$ sed -i '1alibutils.so' /system/etc/public.libraries.txt</span><br><span class="line">foo@bar:~$ sync</span><br><span class="line">foo@bar:~$ reboot</span><br></pre></td></tr></tbody></table></figure>
<p>修改测试，继续有libnativehelper.so、librtk-mediaplayer.so找不到的报错，依次添加到public.libraries.txt，最后应用能正常使用了。<br>接着修改代码/system/core/rootdir/etc/public.libraries.android.txt，添加libutils.so、libnativehelper.so和librtk-mediaplayer.so，重新编译、升级、测试，运行OK。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://stackoverflow.com/questions/54234905/how-to-modify-vendor-etc-public-libraries-txt-when-building-pure-aosp">How to modify “vendor/etc/public.libraries.txt” when building pure AOSP</a>  </li>
<li><a href="https://www.cnblogs.com/Qunter/p/7485090.html">【Android N兼容问题】Android N上系统预置应用调用so库失败问题的看法</a>  </li>
<li><a href="https://www.jianshu.com/p/a4af2bdcc3c0">android N : java.lang.UnsatisfiedLinkError</a>  </li>
<li><a href="https://www.jianshu.com/p/4be3d1dafbec">Framework基础：Android N 公共so库怎么定义呢？</a>  </li>
<li><a href="https://blog.csdn.net/duan_xiaosu/article/details/81031174">Android 7.0以后 .so link 加载链接过程中 dlopen failed 问题</a>  </li>
<li><a href="https://segmentfault.com/a/1190000021461854">Android 动态链接库隔离</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>SELinux的问题</title>
    <url>/2020/05/27/selinux/</url>
    <content><![CDATA[<p>如题</p>
<span id="more"></span>


<h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><p>在setenforce 0和配置了allow system_app self:udp_socket ioctl;后操作依然被denied，log信息如下：  </p>
<blockquote>
<p>08-07 10:49:20.149 4795 4795 I iwpriv: type=1400 audit(0.0:3457): avc: denied {ioctl} for path=”socket:[1607798]” dev=”sockfs” ino=1607798 ioctlcmd=8bfc scontext=u:r:system_app:s0 tcontext=u:r:system_app:s0 tclass=udp_socket permissive=1  </p>
</blockquote>
<p>这是由于ioctl的控制在底层划分得更细，需要允许对应ioctlcmd的操作。  </p>
<p>具体方法是：  </p>
<ol>
<li>查找对应的ioctlcmd在ioctl_defines(system/sepolicy/public/ioctl_defines)中的定义，如上文的8bfc，对应的是SIOCIWFIRSTPRIV_1C  </li>
<li>在对应的文件中加入如下的配置：<br> allowxperm system_app self:udp_socket ioctl SIOCIWFIRSTPRIV_1C;  </li>
</ol>
<p>这样，在ioctl操作时，对应的ioctlcmd就会被允许了。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.jianshu.com/p/66062e509d13">android selinux-170821</a>  </li>
<li><a href="https://blog.csdn.net/zxlworking1/article/details/85249796">Android SELinux配置</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>android</tag>
        <tag>selinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开机任务和定时任务</title>
    <url>/2020/05/27/linux-task/</url>
    <content><![CDATA[<p>如题</p>
<span id="more"></span>


<h3 id="开机任务"><a href="#开机任务" class="headerlink" title="开机任务"></a>开机任务</h3><p>编辑<code>/etc/rc.local</code>文件，加上需要执行的命令。  </p>
<p>但是有的Linux版本没有这个文件，添加这个文件，依然能够生效：  </p>
<ol>
<li><p>添加这个文件  </p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></tbody></table></figure>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ifconfig ens33 192.168.52.128 netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>添加权限  </p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod 755 /etc/rc.local</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置启动  </p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart rc-local</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>重启，开机任务有被执行  </p>
</li>
</ol>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">crontab -l #列出工作表里的命令</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">crontab -e #编辑定时工作表</span><br></pre></td></tr></tbody></table></figure>

<p><code>crontab</code>命令构成为<code>时间</code>+<code>动作</code>，时间有：  </p>
<ul>
<li>分(0-59)</li>
<li>时(0-23)</li>
<li>日(1-31)</li>
<li>月(1-12)</li>
<li>周(0-6，其中0代表星期日)</li>
</ul>
<p>操作符有：  </p>
<ul>
<li>* 取值范围内的所有数字  </li>
<li>/ 每过多少个数字，表示频率  </li>
<li>- 表示范围  </li>
<li>, 散列数字  </li>
</ul>
<p>举个例子：  </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">*/360 * * * * /usr/sbin/ntpdate time.nist.gov # 时间同步，每隔六小时同步一次</span><br><span class="line">2 * * * * /home/foo/test.sh # 这个cron作业会在每天各小时的第2分钟执行脚本test.sh</span><br><span class="line">0 5,6,7 * * * /home/foo/test.sh # 每天的第5、6、7小时执行脚本</span><br><span class="line">0 2 * * * /sbin/shutdown -h # 在每天凌晨2点钟关闭计算机</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统属性</title>
    <url>/2020/05/27/android-system-property/</url>
    <content><![CDATA[<p>来源网络</p>
<span id="more"></span>


<h3 id="属性的分类"><a href="#属性的分类" class="headerlink" title="属性的分类"></a>属性的分类</h3><p>ro开头的属性，表明该属性是只读的，一旦设置，不能更改。<br>persist开头的属性，表明该属性是可修改的，以persist开始的属性会在/data/property存一个副本。也就是说，如果程序调property_set设了一个以persist为前缀的属性，系统会在/data/property/persistent_properties记录这个属性，重启之后这个属性还会存在。<br>ctl.start和ctl.stop属性。用来启动和停止init.rc中定义的服务。<br>其他格式的属性都可修改，重启不保存，因为属性是在内存里存的，所以重启后这个属性就没有了。  </p>
<h3 id="属性的设置和获取"><a href="#属性的设置和获取" class="headerlink" title="属性的设置和获取"></a>属性的设置和获取</h3><p>Java  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.SystemProperties;</span><br><span class="line"></span><br><span class="line">SystemProperties.set(<span class="string">"persist.sys.miracast.hdcp2"</span>,”<span class="number">1</span>”);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SystemProperties.get(<span class="string">"persist.sys.miracast.hdcp2"</span>).equals(<span class="string">"1"</span>)) {</span><br><span class="line">    Log.d(TAG, <span class="string">"666"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Native  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cutils/properties.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">property_get(<span class="string">"persist.sys.miracast.hdcp2"</span>, value, <span class="string">"1"</span>);</span><br><span class="line">property_set(<span class="string">"persist.sys.miracast.hdcp2"</span>, value);</span><br></pre></td></tr></tbody></table></figure>

<p>Shell  </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">setprop persist.sys.miracast.hdcp2 0</span><br><span class="line">getprop persist.sys.miracast.hdcp2</span><br></pre></td></tr></tbody></table></figure>

<h3 id="属性的权限"><a href="#属性的权限" class="headerlink" title="属性的权限"></a>属性的权限</h3><p>程序要正确获取/设置权限，需要有system权限。  </p>
<ol>
<li>在AndroidManifest.xml中，在manifest加入android:sharedUserId=”android.uid.system”  </li>
<li>在Android.mk中，將LOCAL_CERTIFICATE := XXX修改成LOCAL_CERTIFICATE := platform  </li>
</ol>
<p>运行时候可能还会有“libc access denied finding property android”的问题，需要把相关avc denied的报错信息修掉  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>WiFi扫描demo</title>
    <url>/2020/04/23/scan-wifi-demo/</url>
    <content><![CDATA[<p>安卓扫描WiFi。  </p>
<span id="more"></span>


<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.wifitest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.net.wifi.ScanResult;</span><br><span class="line"><span class="keyword">import</span> android.net.wifi.WifiManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.ActivityCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.content.ContextCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> WifiManager mWifiManager;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ScanResult&gt; mWifiList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) {</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {</span><br><span class="line">		<span class="comment">//需要动态申请权限</span></span><br><span class="line">                ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]{Manifest.permission.ACCESS_COARSE_LOCATION}, <span class="number">10</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        mWifiManager = (WifiManager) <span class="keyword">this</span>.getSystemService(Context.WIFI_SERVICE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mWifiManager.isWifiEnabled()) {</span><br><span class="line">            mWifiManager.setWifiEnabled(<span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">        mWifiList.clear();</span><br><span class="line">        mWifiManager.startScan();</span><br><span class="line">        mWifiList = mWifiManager.getScanResults();</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"mWifiList.size(): "</span> + mWifiList.size());</span><br><span class="line">        <span class="keyword">if</span>(mWifiList.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mWifiList.size(); ++i) {</span><br><span class="line">                Log.d(TAG, <span class="string">"mWifiList["</span> + i + <span class="string">"].SSID : "</span> + mWifiList.get(i).SSID);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>AndroidManifest.xml</code>需要添加如下权限：  </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_WIFI_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_NETWORK_STATE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上。  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>demo</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝牙扫描demo</title>
    <url>/2020/04/23/scan-bluetooth-device-demo/</url>
    <content><![CDATA[<p>安卓扫描附近的蓝牙设备。  </p>
<span id="more"></span>


<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.bluetoothtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.bluetooth.BluetoothAdapter;</span><br><span class="line"><span class="keyword">import</span> android.bluetooth.BluetoothDevice;</span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.net.ConnectivityManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.ActivityCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.content.ContextCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"SystemInfoFragment"</span>;</span><br><span class="line">    <span class="keyword">private</span> ConnectivityManager mConnectivityManager;</span><br><span class="line">    <span class="keyword">private</span> BluetoothAdapter btAdapt;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mBluetoothList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mBluetoothList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        btAdapt = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(btAdapt.getState() != BluetoothAdapter.STATE_ON) {</span><br><span class="line">            btAdapt.enable();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        mBluetoothList.clear();</span><br><span class="line">        <span class="keyword">if</span> (btAdapt.isDiscovering()) {</span><br><span class="line">            btAdapt.cancelDiscovery();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) {</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {</span><br><span class="line">                <span class="comment">//需要动态申请权限</span></span><br><span class="line">                ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]{Manifest.permission.ACCESS_COARSE_LOCATION}, <span class="number">10</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        btAdapt.startDiscovery();</span><br><span class="line"></span><br><span class="line">        IntentFilter intent = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        intent.addAction(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">        intent.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED);</span><br><span class="line">        intent.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class="line">        registerReceiver(scanBluetoothDevices, intent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(scanBluetoothDevices != <span class="keyword">null</span>) {</span><br><span class="line">            unregisterReceiver(scanBluetoothDevices);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (btAdapt.isDiscovering()) {</span><br><span class="line">            btAdapt.cancelDiscovery();</span><br><span class="line">        }</span><br><span class="line">        mBluetoothList.clear();</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BroadcastReceiver scanBluetoothDevices = <span class="keyword">new</span> BroadcastReceiver() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>{</span><br><span class="line">            String action = intent.getAction();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (action.equals(BluetoothDevice.ACTION_FOUND)) {</span><br><span class="line">                <span class="comment">//found device</span></span><br><span class="line">                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class="line">                <span class="keyword">int</span> deviceType = device.getType();</span><br><span class="line">                String str = device.getName() + <span class="string">"("</span> + device.getAddress() + <span class="string">")"</span>;</span><br><span class="line">                Log.d(TAG, <span class="string">"found bluetooth device: "</span> + deviceType + <span class="string">" - "</span> + str);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mBluetoothList.indexOf(str) == -<span class="number">1</span>) {</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(deviceType == BluetoothDevice.DEVICE_TYPE_CLASSIC)</span><br><span class="line">                        Log.d(TAG, <span class="string">"deviceType: DEVICE_TYPE_CLASSIC"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(deviceType == BluetoothDevice.DEVICE_TYPE_LE)</span><br><span class="line">                        Log.d(TAG, <span class="string">"deviceType: DEVICE_TYPE_LE"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(deviceType == BluetoothDevice.DEVICE_TYPE_DUAL)</span><br><span class="line">                        Log.d(TAG, <span class="string">"deviceType: DEVICE_TYPE_DUAL"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(deviceType == BluetoothDevice.DEVICE_TYPE_UNKNOWN)</span><br><span class="line">                        Log.d(TAG, <span class="string">"deviceType: DEVICE_TYPE_UNKNOWN"</span>);</span><br><span class="line"></span><br><span class="line">                    mBluetoothList.add(str);</span><br><span class="line">                    Log.d(TAG, <span class="string">"add bluetooth device: "</span> + str);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {</span><br><span class="line">                <span class="comment">//Scanning</span></span><br><span class="line">                Log.d(TAG, <span class="string">"start scanning bluetooth devices... "</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {</span><br><span class="line">                <span class="comment">//Scan Finished</span></span><br><span class="line">                Log.d(TAG, <span class="string">"scan bluetooth devices finished"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"mBluetoothList size = "</span> + mBluetoothList.size());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>AndroidManifest.xml</code>需要添加如下权限：  </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH_ADMIN"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>


<p>简单总结就是：先<code>startDiscovery()</code>，然后注册一个搜索监听广播<code>scanBluetoothDevices</code>。<br><code>startDiscovery()</code>这个接口能扫所有设备，包括经典蓝牙和BLE。<br>网上资料说，不设定扫描周期的话，默认12秒，但是实测并不都是12秒。<br>顺便一提，BLE最大的广播间隔是10.25秒。<br>顺便再提，蓝牙耳机都是经典蓝牙，BLE目前的协议是不支持音频传输的。  </p>
<p>遇到的问题：  </p>
<ol>
<li>编译不过。”error: cannot find symbol registerReceiver/unregisterReceiver”，当时是写在<code>Fragment</code>中，但是<code>Fragment</code>是没有这个方法的。最终在<code>onAttach(Activity activity)</code>中<code>activity.registerReceiver(scanBluetoothDevices, intent);</code>，在<code>onDetach()</code>中<code>getActivity().unregisterReceiver(scanBluetoothDevices);</code>。  </li>
<li>菜单上看到一些空白设备。当时以为是扫不到设备，检查打印才知道有扫到了，只是设备没有名字，所以就空白了，但是打印能看到有<code>mac</code>地址。  </li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>demo</tag>
        <tag>bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title>USB Port Status</title>
    <url>/2020/04/22/usb-port-status/</url>
    <content><![CDATA[<p>需要检测平台的两路USB端口是否接入了设备。不太明白。  </p>
<span id="more"></span>


<p>网上翻了一遍，没找到安卓上层接口可以直接判断USB端口的状态，只能简单地获得USB设备的数量。类似这种:  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFirstUsbStoragePath</span><span class="params">(Context mContext)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> StorageVolume[] volumes = StorageManager.getVolumeList(mContext.getUserId(), StorageManager.FLAG_FOR_WRITE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; volumes.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (volumes[i].getPathFile().getAbsolutePath().contains(<span class="string">"emulated"</span>)) {</span><br><span class="line">            <span class="comment">// ignore internal path</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            DebugLog.d(<span class="string">"USB storage path:"</span> + volumes[i].getPathFile() + <span class="string">"; index:"</span> + i);</span><br><span class="line">            <span class="keyword">return</span> volumes[i].getPathFile().getAbsolutePath();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>sda1</code>和<code>sdb1</code>也不能跟板卡的物理端口对应上，不知道怎么做。  </p>
<p>后来获悉原厂有如下做法：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getUsb1StorageState</span><span class="params">()</span> </span>{</span><br><span class="line">	File checkfile = <span class="keyword">null</span>;</span><br><span class="line">	checkfile = <span class="keyword">new</span> File(<span class="string">"/sys/bus/usb/devices/1-1:1.0"</span>);</span><br><span class="line">	<span class="keyword">if</span>(checkfile != <span class="keyword">null</span> &amp;&amp; checkfile.exists() &amp;&amp; checkfile.isDirectory())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getUsb2StorageState</span><span class="params">()</span> </span>{</span><br><span class="line">	File checkfile = <span class="keyword">null</span>;</span><br><span class="line">	checkfile = <span class="keyword">new</span> File(<span class="string">"/sys/bus/usb/devices/1-2:1.0"</span>);</span><br><span class="line">	<span class="keyword">if</span>(checkfile != <span class="keyword">null</span> &amp;&amp; checkfile.exists() &amp;&amp; checkfile.isDirectory())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际拔插U盘：<br>当板卡两路USB都没有接上U盘时：  </p>
<blockquote>
<p>console:/ $ ls sys/bus/usb/devices/ -l<br>total 0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-0:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-0:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.2 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.2<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 2-0:1.0 -&gt; ../../../devices/platform/usb/18013400.ohci_top/usb2/2-0:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 usb1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 usb2 -&gt; ../../../devices/platform/usb/18013400.ohci_top/usb2</p>
</blockquote>
<p>当板卡两路USB都接上U盘时：  </p>
<blockquote>
<p>console:/ $ ls sys/bus/usb/devices/ -l<br>total 0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-0:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-0:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-1:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-1/1-1:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-2 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-2<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-2:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-2/1-2:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.2 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.2<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 2-0:1.0 -&gt; ../../../devices/platform/usb/18013400.ohci_top/usb2/2-0:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 usb1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 usb2 -&gt; ../../../devices/platform/usb/18013400.ohci_top/usb2</p>
</blockquote>
<p>可看到两路USB分别对应<code>sys/bus/usb/devices/1-1</code>、<code>sys/bus/usb/devices/1-1:1.0</code>和<code>sys/bus/usb/devices/1-2</code>、<code>sys/bus/usb/devices/1-2:1.0</code>，并且能跟物理地址对应上。所以可以认为当U盘接入时，对应的文件就生成了。因此通过这个文件判断对应的USB Port是否有接上设备。  </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>android</tag>
        <tag>usb</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓生成二维码demo</title>
    <url>/2020/04/15/android-qrcode-demo/</url>
    <content><![CDATA[<p>举个栗子。  </p>
<span id="more"></span>

<ol>
<li><p>需要用到<code>zxing</code>这个库。<br>下载<code>core-3.4.0.jar</code>这个东西，修改<code>Android.mk</code>,将<code>core-3.4.0.jar</code>写到<code>LOCAL_STATIC_JAVA_LIBRARIES</code>和<code>LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES</code>，用于编译。  </p>
</li>
<li><p>添加二维码工具类<code>QRCodeUtils.java</code>  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.menu.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.WriterException;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.QRCodeWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QRCodeUtils</span> </span>{</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"QRCodeUtil"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">createQRImage</span><span class="params">(String url, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">if</span> (url == <span class="keyword">null</span> || <span class="string">""</span>.equals(url) || url.length() &lt; <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            Hashtable&lt;EncodeHintType, String&gt; hints = <span class="keyword">new</span> Hashtable&lt;EncodeHintType, String&gt;();</span><br><span class="line">            hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>);</span><br><span class="line">            hints.put(EncodeHintType.MARGIN, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">            BitMatrix bitMatrix = <span class="keyword">new</span> QRCodeWriter().encode(url,</span><br><span class="line">                    BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class="line">            <span class="keyword">int</span>[] pixels = <span class="keyword">new</span> <span class="keyword">int</span>[width * height];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) {</span><br><span class="line">                    <span class="keyword">if</span> (bitMatrix.get(x, y)) {</span><br><span class="line">                        pixels[y * width + x] = <span class="number">0xff000000</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        pixels[y * width + x] = <span class="number">0xffffffff</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Bitmap bitmap = Bitmap.createBitmap(width, height,</span><br><span class="line">                    Bitmap.Config.ARGB_8888);</span><br><span class="line">            bitmap.setPixels(pixels, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        } <span class="keyword">catch</span> (WriterException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>制作菜单<br>略  </p>
</li>
<li><p>把二维码图片设置到菜单<br>二维码图片的内容是往<code>createQRImage</code>传入的字符串。  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String allString = <span class="string">"helloworld"</span>;</span><br><span class="line">mImageView.setImageBitmap(QRCodeUtils.createQRImage(allString, <span class="number">128</span>, <span class="number">128</span>));</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>qrcode</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Thread使用demo</title>
    <url>/2020/04/15/linux-thread-demo/</url>
    <content><![CDATA[<p>这里的场景是串口自发自收。  </p>
<span id="more"></span>


<p>先贴代码：  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readRet = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">CH_Factory_Uart_Selfcheck_Reading_Thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">	SINT32 count = <span class="number">0</span>;</span><br><span class="line">	SINT32 port_id = <span class="number">0</span>;<span class="comment">// use uart 0</span></span><br><span class="line">	SINT32 read_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[] = <span class="string">"changhong"</span>;</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">RHAL_UART_ReadUart</span>(port_id,(UINT8 *)buf,&amp;read_len,<span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">if</span>(read_len &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(buf,<span class="string">"changhong"</span>) == <span class="number">0</span>) {</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]: count = %d, buf = %s, read_len = %d\n"</span>,__func__,__LINE__,count,buf,read_len);</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]: OOOOOOOOOOOOOOOOK!\n"</span>,__func__,__LINE__);</span><br><span class="line">			readRet = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(count &gt; <span class="number">20</span>) {</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]: ERRORRRRRRRRRRRR!\n"</span>,__func__,__LINE__);</span><br><span class="line">			readRet = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CSystemControl::CH_Factory_Uart_Check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]\n"</span>,__func__,__LINE__);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    SINT32 read_len = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"changhong"</span>;</span><br><span class="line">    SINT32 port_id = <span class="number">0</span>;<span class="comment">// use uart 0</span></span><br><span class="line">    <span class="keyword">pthread_t</span> readThreadId;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"stop console"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">RHAL_UART_SelectUart</span>(port_id)!=<span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">"start console"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;readThreadId, <span class="literal">NULL</span>, CH_Factory_Uart_Selfcheck_Reading_Thread, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    ret = <span class="built_in">RHAL_UART_WriteUart</span>(port_id,(UINT8 *)buf,<span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ret) </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]: write uart fail\n"</span>,__func__,__LINE__);</span><br><span class="line">		<span class="built_in">pthread_join</span>(readThreadId, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">RHAL_UART_SelectUart</span>(<span class="number">1</span>); <span class="comment">//switch back to UART1</span></span><br><span class="line">		<span class="built_in">system</span>(<span class="string">"start console"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">pthread_join</span>(readThreadId, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RHAL_UART_SelectUart</span>(<span class="number">1</span>); <span class="comment">//switch back to UART1</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"start console"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!readRet)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码线程的点在于：  </p>
<ol>
<li><p>创建一个<code>ID</code>  </p>
<blockquote>
<p>pthread_t readThreadId;  </p>
</blockquote>
</li>
<li><p>创建了线程，<code>ID</code>与实际的线程函数匹配了  </p>
<blockquote>
<p>pthread_create(&amp;readThreadId, NULL, CH_Factory_Uart_Selfcheck_Reading_Thread, NULL);  </p>
</blockquote>
<p> <code>CH_Factory_Uart_Selfcheck_Reading_Thread</code>就是被创建的线程，<code>ID</code>是<code>readThreadId</code>  </p>
</li>
<li><p>退出线程  </p>
<blockquote>
<p>pthread_join(readThreadId, NULL);  </p>
</blockquote>
<p> <code>pthread_join</code>会阻塞主线程，等待<code>CH_Factory_Uart_Selfcheck_Reading_Thread</code>结束。<code>CH_Factory_Uart_Selfcheck_Reading_Thread</code>是一个<code>while(1)</code>循环，当串口读到需要的数据时，通过<code>pthread_exit(0)</code>使线程内部结束，这个时候跳到主线程的<code>pthread_join</code>，<code>pthread_join</code>终于等到了<code>CH_Factory_Uart_Selfcheck_Reading_Thread</code>结束，主线程就可以继续跑下去了。  </p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>coding</tag>
        <tag>demo</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐</title>
    <url>/2020/03/28/kuai-le/</url>
    <content><![CDATA[<blockquote>
<p>连梦里也会觉得快乐难求<br>连泪光都光不过黑夜尽头<br>不过 不过我不用难受  </p>
</blockquote>
<span id="more"></span>


<blockquote>
<p>快乐在人生里，好比引诱小孩子吃药的方糖，更像跑狗场里引诱狗赛跑的电兔子。几分钟或者几天的快乐赚我们活了一世，忍受着许多痛苦。我们希望它来，希望它留，希望它再来——这三句话概括了整个人类努力的历史。在我们追求和等候的时候，生命又不知不觉地偷度过去。也许我们只是时间消费的筹码，活了一世不过是为那一世的岁月充当殉葬品，根本不会想到快乐。但是我们到死也不明白是上了当，我们还理想死后有个天堂，在那里——谢上帝，也有这一天！我们终于享受到永远的快乐。你看，快乐的引诱，不仅像电兔子和方糖，使我们忍受了人生，而且彷佛钓钩上的鱼饵，竟使我们甘心去死。这样说来，人生虽痛苦，却不悲观，因为它终抱着快乐的希望；现在的账，我们预支了将来去付。为了快活，我们甚至于愿意慢死。  </p>
</blockquote>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>happiness</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的Android功能需求</title>
    <url>/2020/03/04/android-simple-hard/</url>
    <content><![CDATA[<p>菜鸡历险记。  </p>
<span id="more"></span>



<p>需要加一个功能，包含两部分，一是工厂菜单也可以手动检索U盘中的OTA包，并且进行升级，二是插入U盘的时候，平台能自动识别U盘中的OTA包，并且可以升级。  </p>
<p>第一部分，具体就是，按菜单上升级选项的时候，去确认U盘是否存在指定文件名的文件，如果存在，把这个文件拷贝到系统目录<code>/data</code>，拷贝的时候弹出一个进度条<code>ProgressDialog</code>，等拷贝完成，进度条消失，最后调用系统接口<code>RecoverySystem.installPackage</code>升级OTA包。以上的动作基本都在Fragment菜单页通过Handler<code>sendEmptyMessageDelayed</code>的方式处理，验证也OK。  </p>
<p>第二部分：  </p>
<ul>
<li><p>阶段A<br>做插U盘识别的，在广播接收器里面，如果有U盘mount上了，就去查这个东西，然后调用Fragment的函数，最后也想通过Fragment的Handler把这些事情处理完。<br>本想通过这样，可以达到Fragment上一样的效果，既能执行拷贝等动作也能刷新进度条菜单。但是发生了很多<code>CRASH</code>，比如调用的很多函数里需要用到<code>Context</code>，所以我又在<code>BootCompleteReceiver</code>（名字是这样写，但是其实里面有判断<code>android.intent.action.MEDIA_MOUNTED</code>的）把<code>Context</code>传到<code>Fragment</code>，这都还好，最麻烦的就是，我在<code>BootCompleteReceiver</code>里无论通过静态的方式还是new的方式调用<code>Fragment</code>的方法，都用不了控件<code>ProgressDialog</code>，提示<code>Unable to add window</code>，<code>Dialog</code>只能在<code>Activity</code>中显示！到这，不知道怎么在广播里更新UI了。这样的话，就只有COPY和升级的功能，但是看不到整个过程的进度条，这样看起来很奇怪。要不在<code>BootCompleteReceiver</code>先把<code>Activity</code>启动起来，再接着做事情？感觉越来越奇怪了。还有遇到的就是调用<code>Fragment</code>方法的时候，报错<code>Attempt to invoke virtual method on a null object reference</code>，感觉也是没有对象，所以一些方法用了会有问题之类的问题，麻烦啊。  </p>
</li>
<li><p>阶段B<br>那咋搞？我就把<code>Fragment</code>里面的<code>Handler</code>处理方式差不多复制一份搞到<code>BootCompleteReceiver</code>里面，动作都写在<code>BootCompleteReceiver</code>，不通过别的地方调用了，<code>ProgressDialog</code>也是，但是操作控件的时候还是没有<code>Activity</code>啊。但是插入U盘之后<code>AlertDialog</code>是怎么出来的呢？原来<code>AlertDialog</code>有<code>WindowManager.LayoutParams.TYPE_SYSTEM_ALERT</code>属性，这应该是系统层面的东西吧，不依赖<code>Activity</code>。那有没有系统层面的进度条？好像没有。但是网上有说把<code>ProgressDialog</code>设置成<code>TYPE_SYSTEM_ALERT</code>或者<code>TYPE_TOAST</code>，一试确实OK。但是，这只是菜单而已。菜单运行良好了，但是实际上，OTA包体积很大，在<code>BootCompleteReceiver</code>跑拷贝动作的时候，发生<code>ANR</code>，最终没有跑到<code>RecoverySystem.installPackage</code>那里去，为啥，拷贝是在<code>BootCompleteReceiver</code>里面的<code>Handler</code>做的，网上查，说没有<code>new Thread</code>直接创建的<code>new handler</code>是<code>UI线程</code>，<code>UI线程</code>不能做耗时操作，但是为啥在阶段A的时候，在<code>Fragment</code>的<code>Handler</code>里面拷贝OTA包却没有问题？在广播里的<code>Handler</code>却有问题？不明白。查到说<a href="https://www.jianshu.com/p/34c8d5384f94">一个进程如果正在执行BroadcastReceiver的 onReceive() 方法，就会被当做一个前台进程，不易被系统杀死。当 onReceive() 执行完毕，BroadcastReceiver 就不再活跃，其所在进程会被系统当做一个空进程，随时有可能被系统杀死。</a>可能就是这个原因吧。<code>onReceive</code>都跑完了，<code>Handler</code>的拷贝动作还没有跑完。但是<code>Fragment</code>的话，一直在前台，所以不会被杀死。  </p>
</li>
<li><p>阶段C<br>改成<code>new Thread</code>行不行呢，没有尝试，估计不行。<code>Fragment</code>写一次，<code>BootCompleteReceiver</code>写一次，太蠢了。按照<a href="https://www.jianshu.com/p/34c8d5384f94">《如何在BroadcastReceiver中执行耗时操作》</a>这里说的，用<code>IntentService</code>，很好用，但是操作<code>ProgressDialog</code>还是用了<code>TYPE_SYSTEM_ALERT</code>属性。  </p>
</li>
</ul>
<p>但是如果启动了一个服务，这个服务没有对应的<code>Activity</code>，而服务需要刷新UI，怎么搞比较好呢？不能都用<code>TYPE_SYSTEM_ALERT</code>吧。  </p>
<p>纯小白，真惨啊。  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>冥想</title>
    <url>/2020/02/28/ming-xiang/</url>
    <content><![CDATA[<p>贪婪地呼吸？    </p>
<span id="more"></span>


<ol>
<li>舒适地落座。你不一定非得盘腿。坐在椅子上、垫子上，或者地板上，哪里都可以。只要你保证脊柱直立。  </li>
<li>呼吸时感受气息的进出。选择一个身体部位–鼻腔，胸口，或者内脏，将你的注意力集中在那里，认真地尝试感觉你的呼吸。你可以使用一些柔和的提示，比如“吸气”、“吐气”，只要这样有助于引导你的注意力。  </li>
<li>根据我阅读过的所有书籍，这一步是重头戏。不管什么时候，如果你的注意力跑偏，只要原谅自己，恢复呼吸节奏就可以了。你不需要勉强自己的大脑一片空白，因为这基本是不可能的。（当然，当你的注意力集中在感受呼吸时，脑袋里的叽叽喳喳会暂停，但这种宁静不会持续太久。）这就是个训练，目的在于抓住你游荡的思绪，然后重寻你的呼吸，一遍遍地重复。  </li>
</ol>
<p>此刻，我终于明白了。奋斗无可厚非，只要奋斗者能够意识到在这广袤的宇宙中，一切事物的结果都不由我们掌控，与其在自己无法控制的变量上浪费精力，还不如专注于能够改变的东西。当你的雄心壮志带上了这一层智慧，那么你既能千方百计地谋求成功，又能洒脱地看待结果。因此，即使遭遇失败，也能迅速振作起来，掸掸满身的尘土，重新面对挫折。  </p>
<p>如果结果不尽如人意，我只需要鼓起勇气重新开始就好了。  </p>
<p>因你无法改变的事情而郁郁寡欢是毫无意义的，因你能够改变的事物而愁容满面同样没有帮助。  </p>
<p>静心冥想基础练习：  </p>
<ol>
<li>保持舒适的坐姿。  </li>
<li>感受自己的呼吸。  </li>
<li>当你走神的时候，只需要温柔地将意识带回到呼吸上就可以了。  </li>
</ol>
<hr>
<ul>
<li>来源<br><a href="https://book.douban.com/subject/26434953/">一个冥想者的觉知书</a></li>
</ul>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>DVB-T自动搜台流程跟踪</title>
    <url>/2020/01/16/rtk-dvbt-auto-scan/</url>
    <content><![CDATA[<p>已经有点烦了。  </p>
<span id="more"></span>



<p><code>kernel/android/pie/vendor/realtek/app/dtvinput/src/com/realtek/dtv/digitalsetup/dvb/DVBScanChannelFragment.java</code>，菜单上的最后一步，是创建一个<code>DigitalScanTask</code>：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">mDigitalScanTask = <span class="keyword">new</span> DigitalScanTask((DigitalChannelSetupActivity)getActivity());</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> mDigitalScanTask.sendMessageDelayed(DigitalScanTask.MSG_CHANNEL_SACN, scanParam, <span class="number">500</span>);</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHANNEL_SACN:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_CHANNEL_TABLE_SACN);</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHANNEL_TABLE_SACN:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    startTableScan();</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">success = mTvServiceHelper.startAutoScan(mScanChannelList,mModeType);<span class="comment">//auto table scan</span></span><br></pre></td></tr></tbody></table></figure>
<p>向下传进一个频点表<code>mScanChannelList</code>。  </p>
<p>调到了<code>kernel/android/pie/vendor/realtek/app/dtvinput/src/com/realtek/dtv/TvServiceHelper.java</code>的<code>startAutoScan</code>  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startAutoScan</span><span class="params">(ArrayList&lt;FreqTable&gt; freqtable,String type)</span></span>{</span><br><span class="line">	<span class="keyword">if</span> (mTv != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> mTv.StartDtvAutoScan(freqtable.size(),freqtable,-<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着通过JNI，HIDL（依次调用了以下文件）<br><code>kernel/android/pie/vendor/realtek/frameworks/base/core/java/com/realtek/tv/Tv.java</code><br><code>kernel/android/pie/vendor/realtek/frameworks/base/core/jni/com_realtek_tv_Tv.cpp</code><br><code>kernel/android/pie/vendor/realtek/hardware/interfaces/tv/1.0/IRtkTv.hal</code><br><code>kernel/android/pie/vendor/realtek/hardware/interfaces/tv/1.0/default/RtkTv.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/tv/libtvsystem/tv/TvClient.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/tv/libtvservice/TvService.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/tv/libtvservice/Tv.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/tvapi/dtvcontrol/CDTVControl.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/channel/scan/TableScanner.cpp</code>  </p>
<p>终于创建一个<code>ScanThread</code>线程  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTableScanner::AutoScanStart</span><span class="params">(<span class="keyword">int</span> tvsubtype, <span class="keyword">int</span> satelliteIndex,<span class="keyword">bool</span> bSkipPMT,<span class="keyword">bool</span> bSSUScan)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	RT_FRONTEND_TYPE feType = m_pFreqScanDetector-&gt;<span class="built_in">Mf_GetFrontendType</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_threadIsRunning == <span class="literal">true</span> || (feType != RT_FRONTEND_DVB_SATELLITE &amp;&amp; m_freqListSize == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_scanMode != CH_SCAN_MODE_IDLE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	m_bRemoveAll = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">	<span class="keyword">if</span>(feType == RT_FRONTEND_DVB_SATELLITE &amp;&amp; m_pFreqList == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">xLoadTable</span>(satelliteIndex);</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	m_serviceID=<span class="number">0</span>;</span><br><span class="line">	m_scanMode = CH_SCAN_MODE_AUTO;</span><br><span class="line">	m_bSSUScan = bSSUScan;</span><br><span class="line">	m_bDelNosignalMux = <span class="literal">true</span>;</span><br><span class="line">	m_satelliteIndex = satelliteIndex;</span><br><span class="line">	m_bQuickScan=<span class="literal">false</span>;</span><br><span class="line">	m_bSkipPMT=bSkipPMT;</span><br><span class="line">	m_curFreqIndex = <span class="number">0</span>;</span><br><span class="line">	m_uiScanProgress = <span class="number">0</span>;</span><br><span class="line">	m_lastScanedFreqIndex =<span class="number">0</span>;</span><br><span class="line">	m_curFreq = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].frequency:<span class="number">0</span>;</span><br><span class="line">	m_curBandwidth = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].bandwidth:<span class="number">0</span>;</span><br><span class="line">	m_curChNum = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].channelNum:<span class="number">0</span>;</span><br><span class="line">	m_curModulation = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].modulation:RT_MOD_UNKNOWN;</span><br><span class="line">	m_curSymbolRate = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].symbolRate:<span class="number">0</span>;</span><br><span class="line">	m_curPolarization = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].polarization:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;m_thread, <span class="literal">NULL</span>, ScanThread, (<span class="keyword">void</span> *)<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Quick sleep to cause thread to be created.</span></span><br><span class="line">	<span class="keyword">while</span> (m_threadIsRunning == <span class="literal">false</span>)</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="准备搜台"><a href="#准备搜台" class="headerlink" title="准备搜台"></a>准备搜台</h3><p><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/channel/scan/ChScanner.cpp</code><br><code>ScanThread</code>线程首先将<code>CH_SCAN_STATE</code>设定为<code>CH_SCAN_STATE_INIT</code>，然后进入一个<code>xWorkerThread</code>循环  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CChScanner::ScanThread</span><span class="params">(<span class="keyword">void</span> *pParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	CChScanner *pThis = (CChScanner *)pParam;</span><br><span class="line">	pThis-&gt;m_scanState = CH_SCAN_STATE_INIT;</span><br><span class="line">	pThis-&gt;m_threadIsRunning = <span class="literal">true</span>;</span><br><span class="line">	pThis-&gt;m_runThread = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pThis-&gt;m_runThread == <span class="literal">true</span>)</span><br><span class="line">		pThis-&gt;<span class="built_in">xWorkerThread</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Manual/seekscan needs to set this variable before ending scan message is sent out.</span></span><br><span class="line">	pThis-&gt;m_threadIsRunning = <span class="literal">false</span>;</span><br><span class="line">	pThis-&gt;m_cancelScan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/channel/scan/TableScanner.cpp</code><br><code>xWorkerThread</code>循环中首先处理了<code>case``CH_SCAN_STATE_INIT</code>  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTableScanner::xWorkerThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Verify scan mode is valid.</span></span><br><span class="line">	<span class="keyword">if</span> ((m_scanMode == CH_SCAN_MODE_IDLE) || (m_scanMode &gt;= CH_SCAN_MODE_MAX))</span><br><span class="line">		<span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (m_scanState)</span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_INIT:</span><br><span class="line">		<span class="built_in">xStageInit</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_BEGIN_FREQ:</span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_BEGIN_FREQ start\n"</span>, __func__, __LINE__);</span><br><span class="line">		<span class="built_in">xStageBeginFreq</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_SCANNING:</span><br><span class="line">		<span class="comment">// wait scan done</span></span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_SCANNING start\n"</span>, __func__, __LINE__);</span><br><span class="line">		<span class="keyword">while</span> (!m_pFreqScanDetector-&gt;<span class="built_in">Mf_IsScanDone</span>()) {</span><br><span class="line">			<span class="keyword">if</span> (m_cancelScan == <span class="literal">true</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			m_pFreqScanDetector-&gt;<span class="built_in">RunStateProc</span>();</span><br><span class="line">			<span class="keyword">if</span> (m_cancelScan != <span class="literal">true</span> &amp;&amp; !m_pFreqScanDetector-&gt;<span class="built_in">Mf_IsScanDone</span>()) {</span><br><span class="line">				<span class="keyword">if</span>(m_scanMode == CH_SCAN_MODE_BLIND_SCAN||m_scanMode == CH_SCAN_MODE_BLIND_SCAN_NETWORK)</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">int</span> Index = <span class="number">0</span>, Total = <span class="number">0</span>;</span><br><span class="line">					UINT32 freq = m_pFreqScanDetector-&gt;<span class="built_in">Mf_GetFrequency</span>(&amp;Index,&amp;Total);</span><br><span class="line">					<span class="keyword">if</span>(freq&gt;<span class="number">0</span>)</span><br><span class="line">					{</span><br><span class="line">						m_curFreqIndex = Index;</span><br><span class="line">						m_freqListSize = Total;</span><br><span class="line">						m_curFreq = freq;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">				<span class="built_in">usleep</span>(SCAN_THREAD_CS_TIME*<span class="number">1000</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_SCANNING end\n"</span>, __func__, __LINE__);</span><br><span class="line">		m_scanState = CH_SCAN_STATE_END_FREQ;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_END_FREQ:</span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_END_FREQ begin\n"</span>, __func__, __LINE__);</span><br><span class="line">		<span class="built_in">xStageEndFreq</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_SCAN_FAILED:</span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_EXIT:</span><br><span class="line">		<span class="built_in">xStageExit</span>();</span><br><span class="line">		<span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_IDLE:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_cancelScan == <span class="literal">true</span>)</span><br><span class="line">		m_scanState = CH_SCAN_STATE_EXIT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXIT_SCANNING:</span><br><span class="line">	m_runThread = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>跑的是<code>xStageInit()</code>函数，主要做了一件事  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">m_pFreqScanDetector-&gt;<span class="built_in">Mf_ScanInit</span>(scanMode, param, m_bDelNosignalMux,scanModeEx);</span><br></pre></td></tr></tbody></table></figure>
<p>这件事会跳到<code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/channel/scan/DtvFreqDetector.cpp</code>  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::Mf_ScanInit</span><span class="params">(CH_SCAN_MODE scanMode, UINT32 param, <span class="keyword">bool</span> bDelNoSignalMux, CH_SCAN_MODE_EX modeEx)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanInit</span>(<span class="built_in">getSiScanType</span>(scanMode), param, typeEx);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接着跳到<code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/si/DvbSiMgr.cpp</code>  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDvbSiMgr::ScanInit</span><span class="params">(SI_MGR_SCAN_TYPE type, <span class="keyword">int</span> antennaIndex, SI_MGR_SCAN_TYPE_EX typeEx)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (type == SI_MGR_SCAN_TYPE_AUTO||type==SI_MGR_SCAN_TYPE_AUTO_QUICK) {</span><br><span class="line">	<span class="built_in">SI_SetState</span>(siHandle, SI_STATE_AUTOSCAN);</span><br><span class="line">	<span class="built_in">SI_AutoScanInit</span>(siHandle,antennaIndex,type==SI_MGR_SCAN_TYPE_AUTO_QUICK?TRUE:FALSE,FALSE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined ENABLE_CI &amp;&amp; defined ENABLE_CIPLUS_1_4)</span></span><br><span class="line">	<span class="keyword">if</span>(m_CiCallbackObj.NotifyChannelErase != <span class="literal">NULL</span>) {</span><br><span class="line">		m_CiCallbackObj.<span class="built_in">NotifyChannelErase</span>();</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>xStageInit</code>最后把<code>CH_SCAN_STATE</code>状态设定为<code>CH_SCAN_STATE_BEGIN_FREQ</code>  </p>
<h3 id="开始搜台"><a href="#开始搜台" class="headerlink" title="开始搜台"></a>开始搜台</h3><p><code>xWorkerThread``case``CH_SCAN_STATE_BEGIN_FREQ</code>执行<code>CTableScanner::xStageBeginFreq()</code><br>执行<code>m_pFreqScanDetector-&gt;Mf_ScanFrequency(param)</code><br>这里<code>FREQ_SCAN_STATE</code>被设置成状态<code>FREQ_SCAN_STATE_BEGIN_FREQ</code><br><code>CTableScanner::xStageBeginFreq()</code>的最后，<code>CH_SCAN_STATE</code>被设置成<code>CH_SCAN_STATE_SCANNING</code>  </p>
<h3 id="正在搜台"><a href="#正在搜台" class="headerlink" title="正在搜台"></a>正在搜台</h3><p>搜台过程就是<code>CTableScanner::xWorkerThread()``case``CH_SCAN_STATE_SCANNING</code>，是一个<code>while</code>循环<br>先判断是否搜台结束  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">m_pFreqScanDetector-&gt;<span class="built_in">Mf_IsScanDone</span>()</span><br></pre></td></tr></tbody></table></figure>
<p>否则，跑  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">m_pFreqScanDetector-&gt;<span class="built_in">RunStateProc</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>因为刚才<code>FREQ_SCAN_STATE</code>被设置为<code>FREQ_SCAN_STATE_BEGIN_FREQ</code>,所以跑<code>CDtvFreqDetector::xStageBeginFreq()</code>。在某一频点的搜台基本都是在<code>CDtvFreqDetector</code>这里处理啦。  </p>
<p><code>m_pFreqScanDetector-&gt;RunStateProc()</code>做了什么？  </p>
<ol>
<li>Stop SI  </li>
<li>Set tuner param  </li>
<li>Notify demod to lock  </li>
<li>Check frontend(Update modulation, bandwidth, and symbol rate)  </li>
<li>Check SI  </li>
</ol>
<h4 id="FREQ-SCAN-STATE-BEGIN-FREQ"><a href="#FREQ-SCAN-STATE-BEGIN-FREQ" class="headerlink" title="FREQ_SCAN_STATE_BEGIN_FREQ"></a><code>FREQ_SCAN_STATE_BEGIN_FREQ</code></h4><p>跟下去能看到<code>tuner-&gt;tune(param)</code>和<code>tuner-&gt;isLocked()</code>都是在<code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/driverbaseddtvapp/TunerMgr.cpp</code>处理的  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TunerMgr::tune</span><span class="params">(UINT32 frequency, UINT32 bandwidth, RT_FRONTEND_TYPE feType, RT_MODULATION modulation, RT_SPECTRAL_INVERSION inversion, <span class="keyword">bool</span> isScanMode, UINT32 symbolRate, SatelliteInfo *pSatelliteInfo)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	mFreq = frequency;</span><br><span class="line">	mBandwidth = bandwidth;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FrontendLib_SetTuner</span>(frequency, bandwidth, mTunerId, feType, modulation, inversion, isScanMode, symbolRate, pSatelliteInfo);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TunerMgr::isLocked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">uint8_t</span> lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">TunerControlGetLockStatus</span>(mTunerId, &amp;lock) == TUNER_CTRL_OK)</span><br><span class="line">		<span class="keyword">return</span> lock;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="FREQ-SCAN-STATE-CHECK-FRONTEND"><a href="#FREQ-SCAN-STATE-CHECK-FRONTEND" class="headerlink" title="FREQ_SCAN_STATE_CHECK_FRONTEND"></a><code>FREQ_SCAN_STATE_CHECK_FRONTEND</code></h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageCheckFrontend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    m_modulation = <span class="built_in">getRtModVal</span>(m_feType, info);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanStart</span>(m_curFreq, m_modulation, m_curBandwidth, symbolrate,  m_curPhyChNum, tuner-&gt;<span class="built_in">getRFStrength</span>(), tuner-&gt;<span class="built_in">getSignalSNR</span>(), m_serviceID);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDvbSiMgr::ScanStart</span><span class="params">(UINT32 frequency, RT_MODULATION modulation, UINT32 bandwidth, UINT32 symbolrate, UINT32 phyChNum,UINT32 strength,<span class="keyword">float</span> snr, UINT16 serviceID)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI* siHandle = (SI*)m_pTvMedia-&gt;<span class="built_in">GetDtvFlow</span>()-&gt;<span class="built_in">GetSiHandle</span>();</span><br><span class="line">    SI_DVB_MODULATION siModulation;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(modulation)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM16:</span><br><span class="line">        siModulation=SI_DVB_16_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM32:</span><br><span class="line">        siModulation=SI_DVB_32_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM64:</span><br><span class="line">        siModulation=SI_DVB_64_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM128:</span><br><span class="line">        siModulation=SI_DVB_128_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM256:</span><br><span class="line">        siModulation=SI_DVB_256_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SI_SetState</span>(siHandle, SI_STATE_SCAN);</span><br><span class="line">    <span class="built_in">SI_ScanChannelEx</span>(siHandle, frequency, <span class="number">0</span>, bandwidth,siModulation,symbolrate, strength,snr,serviceID,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)phyChNum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>SI_ScanChannelEx</code>路径在<code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/si/livetv_sidvb/librtd/si4/api/SI_Api.c</code>！  </p>
<h4 id="FREQ-SCAN-STATE-CHECK-SI"><a href="#FREQ-SCAN-STATE-CHECK-SI" class="headerlink" title="FREQ_SCAN_STATE_CHECK_SI"></a><code>FREQ_SCAN_STATE_CHECK_SI</code></h4><p><code>CDtvFreqDetector::xStageCheckSi()</code>：Wait for SI to finish gathering tables  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageCheckSi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">RETRY:</span><br><span class="line">	<span class="keyword">if</span> (m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanIsDone</span>(&amp;m_bIsGetService) == <span class="literal">false</span>)</span><br><span class="line">	{</span><br><span class="line">		m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetSignalInfo</span>(tuner-&gt;<span class="built_in">getRFStrength</span>(), tuner-&gt;<span class="built_in">getSignalSNR</span>());</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetModulation</span>(m_curFreq, m_modulation);</span><br><span class="line">    m_scanState = FREQ_SCAN_STATE_END_FREQ;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CDvbSiMgr::ScanIsDone</span><span class="params">(<span class="keyword">bool</span> *bGetCh)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_MESSAGE message;</span><br><span class="line">    UINT32 data = <span class="number">0</span>;</span><br><span class="line">    DriverBasedDtvApp *pDvbApp = m_pTvMedia-&gt;<span class="built_in">GetDtvFlow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pDvbApp-&gt;<span class="built_in">GetSiMessage</span>(&amp;message, &amp;data) == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message == SI_MESSAGE_RESET_CHANNEL &amp;&amp; data&gt;<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">xResetChannel</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(message == SI_MESSAGE_CHANNEL_UPDATE &amp;&amp; data&gt;<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">xUpdateChannelMgr</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message == SI_MESSAGE_CH_INFO_READY)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(bGetCh!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            *bGetCh = data == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message == SI_MESSAGE_SSU_SW_NOT_FOUND||message == SI_MESSAGE_SSU_SWINFO_READY)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(bGetCh!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            *bGetCh = message == SI_MESSAGE_SSU_SWINFO_READY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span><span class="comment">/* if (message != SI_MESSAGE_CH_INFO_READY)*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="完成搜台"><a href="#完成搜台" class="headerlink" title="完成搜台"></a>完成搜台</h3><h4 id="FREQ-SCAN-STATE-END-FREQ"><a href="#FREQ-SCAN-STATE-END-FREQ" class="headerlink" title="FREQ_SCAN_STATE_END_FREQ"></a><code>FREQ_SCAN_STATE_END_FREQ</code></h4><p>如果搜台完成了，<code>CDtvFreqDetector::xStageCheckSi()</code>之后会把<code>FREQ_SCAN_STATE</code>状态设定成<code>FREQ_SCAN_STATE_END_FREQ</code>，在<code>CTableScanner::xWorkerThread()</code>中，<code>CH_SCAN_STATE``CH_SCAN_STATE_SCANNING</code>会退出，变成<code>CH_SCAN_STATE_END_FREQ</code><br>接着跑<code>CTableScanner::xStageEndFreq()</code>,如果频点没搜完，接着搜下一个频点，否则，<code>CH_SCAN_STATE</code>设定为<code>CH_SCAN_STATE_SCAN_FAILED</code>，跑<code>CTableScanner::xStageExit()</code>，这里面跑<code>m_pFreqScanDetector-&gt;Mf_ScanDeInit()</code>以及把一些标志清空。  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::Mf_ScanDeInit</span><span class="params">(<span class="keyword">bool</span> bNoSaveInNoCh)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetMode</span>(SI_MGR_MODE_INACTIVE);</span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanEnd</span>(bNoSaveInNoCh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Flush SI queue.</span></span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">FlushMessageQueue</span>();</span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SaveChannelToFile</span>(bNoSaveInNoCh);</span><br><span class="line"></span><br><span class="line">	DTV_STACK::TunerMgr* tuner = DTV_STACK::TunerMgr::<span class="built_in">getInstance</span>();</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> tunerId = <span class="number">-1</span>;</span><br><span class="line">	tuner-&gt;<span class="built_in">getTunerId</span>(tunerId);</span><br><span class="line">	<span class="built_in">TunerControlChannelScanModeEnable</span>(tunerId, <span class="number">0</span>);</span><br><span class="line">	tuner-&gt;<span class="built_in">reset</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>dvb</tag>
        <tag>si</tag>
        <tag>scan</tag>
        <tag>dvb-t</tag>
      </tags>
  </entry>
  <entry>
    <title>电视信号大致流程</title>
    <url>/2019/12/30/tv-block-diagram/</url>
    <content><![CDATA[<p>如下：  </p>
<span id="more"></span>



<p>图像：<br>一般称Demod及其之前的部分为前端，Decoder及其之后的部分为后端。<br><img src="https://i.loli.net/2019/12/30/obZB2aPhHzECQAp.jpg" alt="video_block_diagram.jpg"><br>个人理解：<br>RF信号给到Tuner，Tuner调谐成中频信号给到Demod，Demod解调成TS流给到Decoder，如果是隔行信号，还会经过De-Interlacer去交错，然后经过Scaler缩放，输出到Panel。  </p>
<hr>
<p>声音：<br>由前端输入模组，中间处理模组，后端输出模组构成：<br>前端输入一般叫做Audio_Rx模块，此模块与各通道HW连接，通过设定MUX，接收各个通道送过来的资料；<br>中间处理模组对收进来的资料处理、编解码动作及各种postprocess动作等等；<br>后端输出模组一般叫做Audio_Tx单元，会去执行Vol、PeakControl、输出通道选择等动作。<br><img src="https://i.loli.net/2020/09/09/7hkbSzi3nql5XRc.png" alt="Audio Processor Flow Chart.png"><br><img src="https://i.loli.net/2019/12/30/NxED3dr7sCqSRp1.jpg" alt="audio_block_diagram.jpg"><br>个人理解：<br>声音由通道输入，MUX后，经由PreScale处理声音额外的正Gain，然后经过AVL、EQ、Treble/Bass等处理后，输出到后端，执行Volume、Power Limiter、Mute等，最后经过功放放大，输出到喇叭。  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
      </tags>
  </entry>
  <entry>
    <title>Auto Color</title>
    <url>/2019/12/27/auto-color/</url>
    <content><![CDATA[<p>Auto Color，也有Auto ADC的叫法。分量和VGA属于高清模拟通道，在TV的流程里面会经过ADC处理。为了保证每台电视的一致性，在生产过程就会有一道ADC校正工序。但是目前的IC一般都会自动校正了。    </p>
<span id="more"></span>


<p>目的：  </p>
<ol>
<li>使信号的最低电平经ADC采集后输出的数位信号是0，信号的最高电平经ADC采集后输出的数位信号是255，这样可以得到最佳的对比度。  </li>
<li>硬件电路差异，进入ADC采集器的RGB信号可能偏离标准信号，且偏离量可能不一样，故必须对RGB通道分别做Auto Color。  </li>
</ol>
<p>原理：<br>通过调整ADC Offset设定值，使信号的最低电平经ADC采集后输出的数位信号为0，通过调整ADC Gain设定值使信号的最高电平经ADC采集后输出的数位信号为255。  </p>
<p><img src="https://i.loli.net/2019/12/27/83pyl1QRjkstuZJ.png" alt="auto_adc.png">  </p>
<p><img src="https://i.loli.net/2019/12/27/mJOnClSaRdHgzBG.jpg" alt="AutoColor.jpg">  </p>
<p>VGA ADC Adjust:<br><img src="https://i.loli.net/2019/12/27/pQ1Un9zBgfibN54.jpg" alt="VGA_ADC.jpg">  </p>
<p>YPbPr ADC Adjust:<br><img src="https://i.loli.net/2019/12/27/F5oqWwOavPR6YN2.jpg" alt="YPP_ADC_1.jpg">  </p>
<p><img src="https://i.loli.net/2019/12/27/oh5dTI2NwXJn4fa.jpg" alt="YPP_ADC_2.jpg">  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>adc</tag>
      </tags>
  </entry>
  <entry>
    <title>配屏不亮可能有哪些原因？</title>
    <url>/2019/12/26/panel-not-working/</url>
    <content><![CDATA[<p>配屏不亮可能有哪些原因？  </p>
<span id="more"></span>


<ol>
<li>排线松动  </li>
<li>板卡驱屏电压不对  </li>
<li>LVDS驱动电流不够  </li>
<li>分辨率不对  </li>
<li>屏参不对  </li>
</ol>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>panel</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓APP</title>
    <url>/2019/09/24/android/</url>
    <content><![CDATA[<p><span class="github-emoji"><span>💩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<span id="more"></span>



<h3 id="声明周期和启动模式"><a href="#声明周期和启动模式" class="headerlink" title="声明周期和启动模式"></a>声明周期和启动模式</h3><ul>
<li>典型情况下的声明周期  <ol>
<li>onCreate: 表示Activity正在被创建。  </li>
<li>onRestart: 表示Activity正在重新启动。  </li>
<li>onStart: 表示Activity正在被启动。这时Activity已经可见，但还是没有出现在前台。  </li>
<li>onResume: 表示Activity已经可见了，并且出现在前台并开始活动。  </li>
<li>onPause: 表示Activity正在停止。  </li>
<li>onStop: 表示Activity即将停止。  </li>
<li>onDestroy: 表示Activity即将被销毁。  </li>
</ol>
</li>
</ul>
<h3 id="IPC基础概念"><a href="#IPC基础概念" class="headerlink" title="IPC基础概念"></a>IPC基础概念</h3><ul>
<li><p>在Android中使用多线程只有一种方法，那就是给四大组件在AndroidMenifest中指定android:process属性，除此之外没有其他办法，也就是说我们无法给一个线程或者一个实体类指定其运行时所在的进程。其实还有一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程，但是这种方法属于特殊情况，也不是常用的创建多进程的方式。  </p>
</li>
<li><p>一般来说，使用多线程会造成如下几方面的问题：  </p>
<ol>
<li>静态成员和单例模式完全失效  </li>
<li>线程同步机制完全失效  </li>
<li>SharedPreferences的可靠性下降  </li>
<li>Application会多次创建  </li>
</ol>
</li>
<li><p>实现跨进程通信的方式很多，比如通过Intent来传递数据，共享文件和SharedPreferences，基于Binder的Messager和AIDL以及Socket等。  </p>
</li>
<li><p>IPC中的一些基础概念，主要包括三方面内容：Serializable接口、Parcelable接口以及Binder。  </p>
</li>
<li><p>什么是对象的序列化？<br>  对象序列化就是将对象的状态信息转化为可以存储或者传输的形式的过程，这些信息包括Class信息、继承关系信息、访问权限、变量类型以及数值信息等。<br>  将序列化对象写入文件后，也可以从文件中读取出来并对其进行反序列化操作。通过反序列化将对象的信息全部获取，然后可以在内存中根据这些信息新建对象。<br>  Java提供了Seriabizable接口来实现对象序列化。当对象在保存对象时，会把其状态保存为一组字节，反序列化时再将这些还原成对象再内存当中重新创建。需要注意的是类中的静态变量是不会被序列化的，因为它不属于对象而是属于类。  </p>
</li>
</ul>
<h4 id="Seriablizable"><a href="#Seriablizable" class="headerlink" title="Seriablizable"></a>Seriablizable</h4><ul>
<li><p>Serializable是Java锁提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。如下所示：<br>  User类是一个实现了Serializable接口的类，它是可以被序列化和反序列化的：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Seriablizable</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">519067123721295773L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">	<span class="keyword">public</span> String userName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  只需要采用ObjectOutputStream和ObjectInputStream即可轻松实现对象的序列化和反序列化：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">"Jake"</span>, <span class="keyword">true</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">User newUser = (User) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>上述代码演示了采用Serializable方式序列化对象的典型过程，很简单，只需要把实现了Serializable接口的User对象写到文件中就可以快速恢复了，恢复后的对象newUser和user的内容完全一样，但是两者并不是同一个对象。  </p>
</li>
</ul>
<h4 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h4><ul>
<li><p>Parcelable接口。只要实现了这个接口，一个类的对象就可以实现序列化并可以通过Intent和Binder传递。  </p>
</li>
<li><p>以下是一个典型用法：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">	<span class="keyword">public</span> String userName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Book book;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">boolean</span> isMale)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">		<span class="keyword">this</span>.userName = userName;</span><br><span class="line">		<span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内容描述</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//几乎在所有情况下这个方法都应该返回0，仅当当前对象中存在文件描述符时，此方法返回1。</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//序列化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>{</span><br><span class="line">		out.writeInt(userId);</span><br><span class="line">		out.writeString(userName);</span><br><span class="line">		out.writeInt(isMale?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">		out.writeParcelable(book, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反序列化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;User&gt;() {</span><br><span class="line">		<span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>{</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> User[] = newArray(<span class="keyword">int</span> size) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">		}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>{</span><br><span class="line">		userId = in.readInt();</span><br><span class="line">		userName = in.readString();</span><br><span class="line">		isMale = in.readInt() == <span class="number">1</span>;</span><br><span class="line">		book = in.readParcelable(Thread.currentThread().getContextClassLoader());</span><br><span class="line">		<span class="comment">//由于book是另一个可序列化对象，所以它的反序列化过程需要传递当前线程的上下文类加载器，否则会报找不到类的错误。</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>系统已经为我们提供了许多实现了Parcelable接口的类，它们都是可以直接序列化的，比如Intent、Bundle、Bitmap等，同时List和Map也可以序列化，前提是它们里面的每个元素都是可序列化的。  </p>
</li>
</ul>
<h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>直观来说，Binder是Android中的一个类，它实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，等等）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务器端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。  </p>
<p>Android开发中，BInder主要用在Service中，包括AIDL和Messager，其中普通Service中的Binder不涉及进程间通信，所以较为简单，无法触及Binder的核心，而Messager的底层其实是AIDL。  </p>
<p><img src="https://i.loli.net/2019/09/26/xHhaYTteLmy8r53.jpg" alt="Binder的工作机制.jpg">  </p>
<h3 id="Android中的IPC方式"><a href="#Android中的IPC方式" class="headerlink" title="Android中的IPC方式"></a>Android中的IPC方式</h3><h4 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h4><p>Activity、Service、Receiver都支持在Intent中传递Bundle数据  </p>
<h4 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h4><p>文件共享方式适合在对数据同步要求不高的进程之前进行通信，并且要妥善处理并发读/写的问题。<br>但是，SharedPreferences是个特例，不建议在进程间通信中使用SharedPreferences。  </p>
<h4 id="使用Messenger"><a href="#使用Messenger" class="headerlink" title="使用Messenger"></a>使用Messenger</h4><p><img src="https://i.loli.net/2019/09/26/LEwqeRUbx7AVHvQ.jpg" alt="Messenger工作原理.jpg">  </p>
<h4 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h4><p>Messenger是已串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理，如果有大量的并发请求，那么用Messenger就不太适合了。同时，Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。AIDL也是Messenger的底层实现，因此，Messenger本质上也是AIDL，只不过系统为我们做了封装从而方便上层的调用而已。  </p>
<p>在Binder的基础上我们可以更容易地理解AIDL。这里先介绍使用AIDL来进行进程间通信的流程，分为服务端和客户端两个方面。  </p>
<ol>
<li><p>服务端<br> 服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。  </p>
</li>
<li><p>客户端<br> 客户端所要做的事情就稍微简单一些，首先需要绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。  </p>
</li>
<li><p>AIDL接口的创建<br> 首先看AIDL接口的创建，如下所示，我们创建了一个后缀为AIDL的文件，在里面声明了一个接口和两个接口方法：  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ryg.chapter_2.aidl.Book;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>{</span><br><span class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> AIDL文件支持的数据类型：  </p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基本数据类型</td>
<td align="left">int、long、char、boolean、double等</td>
</tr>
<tr>
<td align="left">String 和 CharSequence</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">只支持ArrayList，里面每个元素都必须能够被AIDL支持</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value</td>
</tr>
<tr>
<td align="left">Parcelable</td>
<td align="left">所有实现了Parcelable接口的对象</td>
</tr>
<tr>
<td align="left">AIDL</td>
<td align="left">所有的AIDL接口本身也可以在AIDL文件中使用</td>
</tr>
</tbody></table>
<p> 以上6种数据类型就是AIDL所支持的所有数据类型，其中自定义的Parcelable对象和AIDL对象必须要显式import进来，不管它们是否和当前AIDL文件位于同一个包内。  </p>
<p> 另外一个需要注意的地方是，如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelable类型。  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></tbody></table></figure>

<p> AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入性参数，out表示输出型参数，inout表示输入输出型参数。  </p>
<p> AIDL接口中只支持方法，不支持声明静态常量，这一点区别于传统的接口。  </p>
</li>
<li><p>远程服务端Service的实现<br> 上面讲述了如何定义AIDL接口，接下来我们就需要实现这个接口了。我们先创建一个Service，称为BookManagerService，代码如下：  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BMS"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Book&gt;();</span><br><span class="line">	<span class="comment">//CopyOnWriteArrayList支持并发读/写。</span></span><br><span class="line">	<span class="comment">//前面我们提到，AIDL方法是在服务端的Binder线程池执行的，因此，当多个客户端同时连接的时候，</span></span><br><span class="line">	<span class="comment">//会存在多个线程同时访问的情形，所以我们要在AIDL方法中处理线程同步，</span></span><br><span class="line">	<span class="comment">//而我们这里直接使用CopyOnWriteArrayList来进行自动的线程同步。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() {</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>{</span><br><span class="line">        	        <span class="keyword">return</span> mBookList;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>{</span><br><span class="line">           			mBookList.add(book);</span><br><span class="line">       		}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{</span><br><span class="line">       		<span class="keyword">super</span>.onCreate();</span><br><span class="line">	        mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"Android"</span>));</span><br><span class="line">	        mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"Ios"</span>));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>{</span><br><span class="line">	        <span class="keyword">return</span> mBinder;</span><br><span class="line">   		}</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure>

<p> 然后我们需要在XML中注册这个Service，如下所示：  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">	android:name=<span class="string">".aidl.BookManagerService"</span></span><br><span class="line">	android:process=<span class="string">":remote"</span> &gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></tbody></table></figure>
<p> 注意BookManagerService是运行在独立的进程中的，它和客户端的Activity不在同一个进程中，这样就构成了进程间通信的场景。  </p>
</li>
<li><p>客户端的实现<br> 客户端的实现就比较简单了，首先要绑定远程服务，绑定成功后将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了，代码如下所示。  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BookManagerActivity"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() {</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>{</span><br><span class="line">			IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				List&lt;Book&gt; list = bookManager.getBookList();</span><br><span class="line">				Log.i(TAG, <span class="string">"query book list, list type:"</span> + list.getClass().getCanonicalName());</span><br><span class="line">				Log.i(TAG, <span class="string">"query book list:"</span> + list.toString());</span><br><span class="line">			} <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>{</span><br><span class="line">		}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_book_manager);</span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</span><br><span class="line">		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">		unbindService(mConnection);</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 绑定成功后，会通过bookManager去调用getBookList方法，然后打印出所获取的图书信息。需要注意的是，服务端的方法有可能需要很久才能执行完毕，这个时候下面的代码就会导致ANR，这一点是需要注意的，后面会再介绍这种情况，之所以先这么写是为了让读者更好地了解AIDL的实现步骤。  </p>
<p> 接着在XML中注册此Activity，运行程序。  </p>
<p> RemoteCallbackList是系统专门提供的用于删除跨进程listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口。  </p>
<pre><code> - 虽然说多次跨进程传输客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个共同点，那就是它们的底层的Binder对象是同一个。当客户端解注册的时候，我们只要遍历服务端所有的listener，找出那个和解注册listener具有相同Binder对象的服务端listener并把它删掉即可。  
 - RemoteCallbackList还有一个很有用的功能，那就是当客户端进程终止后，它能够自动移除客户端所注册的listener。  
 - RemoteCallbackList内部自动实现了线程同步功能，所以我们使用它来注册和解注册时，不需要做额外的线程同步工作。  
</code></pre>
</li>
</ol>
<p>到这里，AIDL的基本使用方法已经介绍完了，但是有几点还需要再次说明一下。我们知道，客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端线程会被挂起，这个时候如果服务端方法执行比较耗时，就会导致客户端线程长时间地阻塞在这里，而如果这个客户端线程是UI线程的话，就会导致客户端ANR，这当然不是我们想要看到的。因此，如果我们明确知道某个远程方法是耗时的，那么就要避免在客户端的UI线程中去访问远程方法。由于客户端的onServiceConnected和onSerivceDisconnected方法都运行在UI线程中，所以也不可以在它们里面直接调用服务端的耗时方法，这点要尤其注意。另外，由于服务端的方法本身就运行在服务端的Binder线程池中，所以服务端方法本身就可以执行大量耗时操作，这个时候切记不要在服务端方法中开线程去进行异步任务，除非你明确知道自己在干什么，否则不建议这么做。  </p>
<p>同理，当远程服务端需要调用客户端的listener中的方法时，被调用的方法也运行在Binder线程池中，只不过是客户端的线程池。所以我们同样不可以在服务端中调用客户端的耗时方法。  </p>
<p>最后一步：权限验证！   </p>
<p>总结一下大致流程：<br>首先创建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。  </p>
<h4 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h4><h4 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h4><h3 id="四大组件的工作过程"><a href="#四大组件的工作过程" class="headerlink" title="四大组件的工作过程"></a>四大组件的工作过程</h3><p>Android的四大组件中除了BroadcastReceiver以外,其他三种组件都必须在AndroidManifest中注册，对于BroadcastReceiver来说，它既可以在AndroidManifest中注册，也可以通过代码来注册。在调用方式上，Activity、Service和BroadcastReceiver需要借助Intent，而ContentProvider则无须借助Intent。  </p>
<p>广播（BroadcastReceiver）的注册有两种方式：静态注册和动态注册。静态注册是指在AndroidManifest中注册广播，这种广播在应用安装时会被系统解析，此种形式的广播不需要应用启动就可以收到相应的广播。动态注册广播需要通过Context.registerReceiver()来实现，并且在不需要的时候要通过Context.unRegisterReceiver()来解除广播，此种形式的广播必须要应用启动才能注册并接收广播,因为应用不启动就无法注册广播,无法注册广播就无法收到相应的广播。  </p>
<p><a href="https://youtu.be/8KunR2xqkMM">Android层次分析 –从顶层到底层</a>  </p>
<h3 id="Android的线程和线程池"><a href="#Android的线程和线程池" class="headerlink" title="Android的线程和线程池"></a>Android的线程和线程池</h3><p>主线程是指进程所拥有的线程,在Java中默认情况下一个进程只有一个线程,这个线程就是主线程.主线程主要处理界面交互相关的逻辑,因为用户随时会和界面发生交互,因此主线程在任何时候都必须有较高的响应速度,否则就会产生一种界面卡顿的感觉.为了保持较高的响应速度,这就要求主线程中不能执行耗时的任务,这个时候子线程就派上用场了.子线程也叫工作线程,除了主线程以外的线程都是子线程.  </p>
<p>Android沿用了Java的线程模型，其中的线程也分为主线程和子线程，其中主线程也叫UI线程。主线程的作用是运行四大组件以及处理它们和用户的交互，而子线程的作用则是执行耗时任务，比如网络请求、I/O操作等。  </p>
<p>Android的线程形态：传统的Thread、AsyncTask、HandlerThread、IntentService。  </p>
<p>Android线程的基本用法：  </p>
<ol>
<li><p>新建一个类继承自Thread，然后重写父类的run()方法，并在里面写耗时逻辑  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//处理具体的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如何启动？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyThread().start();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>实现Runnable接口的方式来定义一个线程  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//处理具体的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如何启动？  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Mythread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread).start();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>使用匿名类的方式，这种方法更为常见  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//处理具体的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}).start();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p><a href="https://houbb.github.io/2019/02/26/java-time-nanotime-02">Java 时间之 currentTimeMillis 与 nanoTime - 时间精确测量</a>  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2019/08/10/java/</url>
    <content><![CDATA[<p><span class="github-emoji"><span>💩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<span id="more"></span>


<h2 id="基本程序设计结构"><a href="#基本程序设计结构" class="headerlink" title="基本程序设计结构"></a>基本程序设计结构</h2><ul>
<li>变量：<br>  Java语言支持的变量类型有：  <pre><code>  1. 类变量：独立于方法之外的变量，用static修饰  
  2. 实例变量：独立于方法之外的变量，不过没有static修饰  
  3. 局部变量：类的方法中的变量  
</code></pre>
  实例：    <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> </span>{</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>; <span class="comment">//类变量</span></span><br><span class="line">	String str = <span class="string">"hello world"</span>; <span class="comment">//实例变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//局部变量</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ul>
<li><p>Java中的受保护部分对于所有子类及同一个包中的所有其他类都可见。  </p>
</li>
<li><p>protected需要从以下两个点来分析说明：</p>
<ol>
<li>子类与基类在同一个包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问；  </li>
<li>子类与基类不在同一个包中：那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。  </li>
</ol>
</li>
<li><p>final  </p>
<ul>
<li>在Java中，用关键字final指示常量。  </li>
<li>关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。  </li>
<li>在Java中，经常希望某个变量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。可以使用关键字static final设置一个类常量。  </li>
<li>final关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。（注：实例变量也可以被定义为final，被定义为final的变量不能被修改。被声明为final类的方法自动得声明为final，但是实例变量并不是final（如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域））</li>
</ul>
</li>
<li><p>构建字符串：StringBuilder  </p>
<ol>
<li>构建一个空的字符串构建器:   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></tbody></table></figure></li>
<li>当每次需要添加一部分内容时，就调用append()方法:   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">builder.append(ch); <span class="comment">//appends a single character</span></span><br><span class="line">builder.append(str); <span class="comment">//appends a string</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>在需要构建字符串时就调用toString()方法，将可以得到一个String对象，其中包括了构建器中的字符序列:   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String completedString = builder.toString();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><p>一旦创建了数组，就不能改变它的大小（尽管可以改变每一个数组元素）。如果经常需要在运行过程中扩展数组的大小，就应该使用另一种数据结构 -- 数组列表。  </p>
</li>
<li><p>初始化数据域的方法：  </p>
<ol>
<li>在构造器中设置值  </li>
<li>在声明中赋值  </li>
<li>初始化块（首先运行初始化块，然后才运行构造器的主体部分，这种机制不是必需的，也不常见，通常，直接将初始化代码放在构造器中）</li>
</ol>
</li>
<li><p>在对象与对象变量之间存在着一个重要的区别。例如，语句 Date deadline；<br>  定义了一个对象变量deadline，它可以引用Date类型的对象，但是，一定要认识到：变量deadline不是一个对象，实际上也没有引用对象。此时，不能将任何Date方法应用于这个变量上。语句 s = deadline.toString(); 将产生编译错误。必须首先初始化变量deadline，这里有两个选择，可以用新构造的对象初始化这个变量：deadline = new Date(); 也可以让这个变量引用一个已存在的对象：deadline = birthday；  </p>
</li>
<li><p>一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅是引用了一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。  </p>
</li>
<li><p>可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。deadline = null；  </p>
</li>
<li><p>局部变量不会自动地初始化为null，而必须通过调用new或将他们设置为null进行初始化。  </p>
</li>
<li><p>所有的Java对象都存储在堆中。  </p>
</li>
<li><p>在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。  </p>
</li>
<li><p>构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。  </p>
</li>
<li><p>注意不要编写返回引用可变对象的访问器方法。如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）。如果需要返回一个可变数据域的拷贝，就应该使用clone。对象的克隆是指存放在另一个位置上的对象副本。修改前的代码：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> Date hireDay;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> hireDay;</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  修改后的代码：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> hireDay.clone();</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>static游离块、一般游离块、子父类构造方法，执行顺序：父类静态游离块 &gt; 子类静态游离块 &gt; 父类游离块 &gt; 父类构造函数 &gt; 子类游离块 &gt; 子类构造函数  </p>
</li>
<li><p>块作用域：不能在嵌套的两个块中声明同名的变量。但是在C++中，可以在嵌套的块中重定义一个变量，在内层定义的变量会覆盖在外层定义的变量。  </p>
</li>
<li><p>一个方法可以访问所属类的所有对象的私有数据。  </p>
</li>
</ul>
<h3 id="静态域和静态方法"><a href="#静态域和静态方法" class="headerlink" title="静态域和静态方法"></a>静态域和静态方法</h3><ul>
<li><p>静态域：<br>  如果将域定义为static，每个类中只有一个这样的域，而每一个对象对于所有的实例域却都有自己的一份拷贝。例如，假定需要给每一个雇员赋予唯一的标识码。这里给Employee类添加一个实例域id和一个静态域nextId：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  现在，每一个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextId域。换句话说，如果有1000个Employee类的对象，则有1000个实例域id。但是，只有一个静态域nextId。即使没有一个雇员对象，静态域nextId也存在。它属于类，而不属于任何独立的对象。  </p>
</li>
<li><p>在下面两种情况下使用静态方法：  </p>
<ol>
<li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow）。  </li>
<li>一个方法只需要访问类的静态域（例如：Employee.getNextId）。  </li>
</ol>
</li>
<li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。  </p>
</li>
<li><p>静态方法只能访问静态成员，实例方法可以访问静态和实例成员。  </p>
</li>
<li><p>之所以不允许静态方法访问实例成员变量，是因为实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。  </p>
</li>
</ul>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><ul>
<li><p>方法参数共有两种类型：  </p>
<ol>
<li>基本数据类型（数字、布尔值）  </li>
<li>对象引用  </li>
</ol>
</li>
<li><p>方法参数的使用情况：  </p>
<ol>
<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。  </li>
<li>一个方法可以改变一个对象参数的状态。（实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。）  </li>
<li>一个方法不能让对象参数引用一个新的对象。 </li>
</ol>
</li>
<li><p>调用：<br>  按值调用：表示方法接收的是调用者提供的值。<br>  按引用调用：表示方法接收的是调用者提供的变量地址。<br>  一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。<br>  Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。<br>  Java程序设计语言对对象采用的不是引用调用，实际上，对象引用进行的是值传递。</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamTest</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* Test1: Methods can't modify numeric parameters*/</span></span><br><span class="line">		<span class="comment">//一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）</span></span><br><span class="line">		System.out.println(<span class="string">"Testing tripleValue:"</span>);</span><br><span class="line">		<span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">		System.out.println(<span class="string">"Before: percent = "</span> + percent);</span><br><span class="line">		tripleValue(percent);</span><br><span class="line">		System.out.println(<span class="string">"After: percent = "</span> + percent);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Test2: Methods can change the state of object parameters*/</span></span><br><span class="line">		<span class="comment">//一个方法可以改变一个对象参数的状态</span></span><br><span class="line">		System.out.println(<span class="string">"\nTesting tripleValue:"</span>);</span><br><span class="line">		Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry"</span>,<span class="number">500000</span>);</span><br><span class="line">		System.out.println(<span class="string">"Before: salary = "</span> + harry.getSalary());</span><br><span class="line">		tripleSalary(harry);</span><br><span class="line">		System.out.println(<span class="string">"After: salary = "</span> + harry.getSalary());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Test3: Methods can't attach new objects to object parameters*/</span></span><br><span class="line">		<span class="comment">//一个方法不能让对象参数引用一个新的对象</span></span><br><span class="line">		System.out.println(<span class="string">"\nTesting swap:"</span>);</span><br><span class="line">		Employee a = <span class="keyword">new</span> Employee(<span class="string">"Alice"</span>, <span class="number">70000</span>);</span><br><span class="line">		Employee b = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>, <span class="number">60000</span>);</span><br><span class="line">		System.out.println(<span class="string">"Before: a = "</span> + a.getName());</span><br><span class="line">		System.out.println(<span class="string">"Before: b = "</span> + b.getName());</span><br><span class="line">		swap(a,b);</span><br><span class="line">		System.out.println(<span class="string">"After: a = "</span> + a.getName());</span><br><span class="line">		System.out.println(<span class="string">"After: b = "</span> + b.getName());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(<span class="keyword">double</span> x)</span></span>{ <span class="comment">//doesn't work</span></span><br><span class="line">		x = <span class="number">3</span> * x;</span><br><span class="line">		System.out.println(<span class="string">"End of method: x = "</span> + x);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span><span class="params">(Employee x)</span></span>{ <span class="comment">//works</span></span><br><span class="line">		x.raiseSalary(<span class="number">200</span>);</span><br><span class="line">		System.out.println(<span class="string">"End of method: salary = "</span> + x.getSalary());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x, Employee y)</span></span>{</span><br><span class="line">		Employee temp = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = temp;</span><br><span class="line">		System.out.println(<span class="string">"End of method: x = "</span> + x.getName());</span><br><span class="line">		System.out.println(<span class="string">"End of method: y = "</span> + y.getName());</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>{ <span class="comment">//simplified Employee class</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s)</span></span>{</span><br><span class="line">		name = n;</span><br><span class="line">		salary = s;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> salary;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span>{</span><br><span class="line">		<span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">		salary += raise;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。然而，超类中的有些方法对子类Manager并不一定适用。具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来覆盖（override）超类中的这个方法。<br>  那么如何实现这个方法呢？乍看起来似乎很简单，只要返回salary和bonus域的总和就可以了：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> salary + bonus; <span class="comment">// won't work</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>然而，这个方法并不能运行。这是因为Manger类的getSalary方法不能地访问超类的私有域。也就是说，尽管每一个Manager对象都拥有一个名为salary的域，但在Manager类的getSalary方法中并不能直接地访问salary域。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，就必须借助于公有的接口，Employee类中的公有方法getSalary正是这样一个接口。  </p>
</li>
<li><p>现在，再试一下。将对salary域的访问替换成调用getSalary方法。  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">double</span> baseSalary = getSalary(); <span class="comment">// still won't work</span></span><br><span class="line">	<span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  上面这段代码仍然不能访问。问题出现在调用getSalary的语句上，这是因为Manager类也有一个getSalary方法（就是正在实现的这个方法），所以这条语句将会导致无限次地调用自己，直到整个程序崩溃为止。  </p>
</li>
<li><p>这里需要指出：我们希望调用超类Employee中的getSalary方法，而不是当前类的这个方法。为此，可以使用特定的关键字super解决这个问题：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">	<span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。  </p>
</li>
<li><p>super在构造器中的应用：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>{</span><br><span class="line">	<span class="keyword">super</span>(n,s,year,month,day);</span><br><span class="line">	bonus = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  这里的关键字super具有不同的含义。语句super(n,s,year,month,day);是“调用超类Employee中含有n、s、year、month和day参数的构造器”的简写形式。<br>  由于Manager类的构造器不能访问Employee类的私有域，所以必须利用Employee的构造器对这部分私有域进行初始化，我们可以通过super实现对超类构造器的调用。使用super调用构造器的语句必须是子类构造器的第一条语句。<br>  如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用其他构造器，则Java编译器将报告错误。（子类不能继承父类的构造器（构造方法或者构造函数），如果父类的构造器带有参数，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。如果父类构造器没有参数，则在子类的构造器中不需要使用super关键字调用父类构造器，系统会自动调用父类的无参构造器。）  </p>
</li>
<li><p>关键字this的两个用途：  </p>
<ol>
<li>引用隐式参数  </li>
<li>调用该类其他的构造器  </li>
</ol>
</li>
<li><p>关键字super的两个用途：  </p>
<ol>
<li>调用超类方法  </li>
<li>调用超类的构造器  </li>
</ol>
</li>
<li><p>重写(override)：  </p>
<ul>
<li>声明为final的方法不能被重写  </li>
<li>声明为static的方法不能被重写，但是能够被再次声明  </li>
<li>构造方法不能被重写  </li>
<li>如果不能继承一个方法，则不能重写这个方法  </li>
</ul>
</li>
<li><p>重载(overload)：  </p>
<ul>
<li>被重载的方法必须改变参数列表（参数个数或类型不一样）  </li>
<li>被重载的方法可以改变返回类型  </li>
<li>被重载的方法可以改变访问修饰符  </li>
<li>被重载的方法可以声明新的或更广的检查异常  </li>
<li>方法能够在同一个类中或者在一个子类中被重载  </li>
</ul>
</li>
</ul>
<ul>
<li><p>一个对象变量可以指示多种实际类型的现象被称为多态。在运行时能够自动地选择调用哪个方法的现象称为动态绑定。  </p>
</li>
<li><p>多态的实现方法：重写、接口、抽象类和抽象方法。  </p>
</li>
<li><p>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定。  </p>
</li>
<li><p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。  </p>
</li>
<li><p>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为内联。如果方法很简短、被频繁调用且没有真正地被覆盖，那么虚拟机中的即时编译器就会将这个方法进行内联处理。  </p>
</li>
<li><p>强制类型转换：在将超类转换成子类之前，应该使用instanceof进行检查。  </p>
</li>
<li><p>abstract关键字：  </p>
<ol>
<li>包含一个或多个抽象方法的类本身必须声明为抽象的。  </li>
<li>除抽象方法之外，抽象类还可以包含具体数据和具体方法。  </li>
<li>抽象方法充当着占位的角色，它们的具体实现在子类中。  </li>
<li>扩展抽象类可以有两种选择。一种是在子类中定义部分抽象方法或者抽象方法也不定义，这样就必须将子类也标记为抽象类；另一种是定义全部抽象方法，这样一来，子类就不是抽象的了。  </li>
<li>类即使不含抽象方法，也可以将类声明为抽象类。  </li>
<li>抽象类不能被实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。(抽象类不能直接通过new去实例化一个对象，那它就是不能实例化，要获取抽象类的对象，需要先用一个类继承抽象类，然后去实例化子类。也可以用匿名内部类，在抽象类中创建一个匿名的子类，继承抽象类，通过特殊的语法实例化子类的对象。)  </li>
<li>可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。  </li>
<li>构造方法、类方法（用static修饰的方法）不能声明为抽象方法。  </li>
</ol>
</li>
</ul>
<h2 id="接口和内部类"><a href="#接口和内部类" class="headerlink" title="接口和内部类"></a>接口和内部类</h2><ul>
<li><p>接口绝不能含有实例域，也不能在接口中实现方法。提供实例域和方法实现的任务应该由实现接口的那个类来完成。因此，可以将接口看成是没有实例域的抽象类。  </p>
</li>
<li><p>接口不是类，尤其不能使用new运算符实例化一个接口：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> Compare(...); <span class="comment">//ERROR</span></span><br></pre></td></tr></tbody></table></figure>
<p>  然而，尽管不能构造接口的对象，却能声明接口的变量：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Compare x; <span class="comment">//OK</span></span><br></pre></td></tr></tbody></table></figure>
<p>  接口变量必须引用实现了接口的类对象：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> Employee(...); <span class="comment">//OK provided Employee implements Comparable</span></span><br></pre></td></tr></tbody></table></figure>
<p>  接下来，如同使用instanceof检查一个对象是否属于某个特定类一样，也可以使用instanceof检查一个对象是否实现了某个特定的接口：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable) {...}</span><br></pre></td></tr></tbody></table></figure>
<p>  与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个称为Moveable的接口：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">move</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  然后，可以以它为基础扩展一个叫做Powered的接口：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Powered</span> <span class="keyword">extends</span> <span class="title">Moveable</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">milePerGallon</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  虽然在接口中不能包含实例域或静态方法，但却可以包含常量。<br>  与接口中的方法都自动地被设置为public一样，接口中的域将被自动设为public static final。  </p>
</li>
<li><p>为什么要使用内部类？  </p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据。  </li>
<li>内部类可以对同一个包中的其他类隐藏起来。  </li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。  </li>
</ol>
</li>
<li><p>Java内部类还有另外一个功能，这使得它比C++的嵌套类更加丰富，用途更加广泛。内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。  </p>
</li>
<li><p>局部内部类：<br>  局部内部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。  </p>
</li>
<li><p>由外部方法访问final变量：<br>  局部类不仅能够访问包含它们的外部类，还可以访问局部变量，不过，这些局部变量必须被声明为final。  </p>
</li>
<li><p>final关键字可以应用于局部变量、实例变量和静态变量。在所有这些情况下，它们的含义都是：在创建这个变量之后，只能够为之赋值一次。此后，再也不能修改它的值了，这就是final。不过，在定义final变量的时候，不必进行初始化。  </p>
</li>
<li><p>匿名内部类：  </p>
<ol>
<li>如果构造器参数的闭圆括号跟一个开花括号，正在定义的就是匿名内部类。  </li>
<li>由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给超类的构造器。尤其是在内部类实现接口的时候，不能有任何构造参数。  </li>
</ol>
</li>
<li><p>静态内部类：<br>  有时候，使用内部类只是为了把一个类隐藏在另一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static，以便取消产生的引用。    </p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p>Throwable  </p>
<ul>
<li>Error(未检查异常)  </li>
<li>Exception  <ul>
<li>IOException(已检查异常)  </li>
<li>RuntimeException(未检查异常)  </li>
</ul>
</li>
</ul>
</li>
<li><p>声明：方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类已检查异常。但是，不需要声明Java的内部错误，即从Error继承的错误。同样，也不应该声明从RuntimeException继承的那些未检查异常。总之，一个方法必须声明所有可能抛出的已检查异常，而未检查异常要么不可控制（Error），要么就应该避免发生（RuntimeException）。  </p>
</li>
<li><p>由于程序错误导致的异常属于RuntimeException，而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。<br>  派生于RuntimeException的异常包含下面几种情况：  </p>
<ol>
<li>错误的类型转换  </li>
<li>数组访问越界  </li>
<li>访问空指针  </li>
</ol>
<p>  不是派生于RuntimeException的异常包括：  </p>
<ol>
<li>试图在文件尾部后面读取数据  </li>
<li>试图打开一个不存在的文件  </li>
<li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在  </li>
</ol>
<p>  “如果出现RuntimeException异常，那么就一定是你的问题”是一条相当有道理的规格。  </p>
</li>
<li><p>如果在子类中覆盖了超类的一个方法，子类方法中声明的已检查异常不能比超类方法中声明的异常更通用（也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常）。特别需要说明的是，如果超类方法没有抛出任何已检查异常，子类也不能抛出任何已检查异常。  </p>
</li>
<li><p>如果想传递一个异常，就必须在方法的首部添加一个throws说明符，以便告知调用者这个方法可能会抛出异常。  </p>
</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li><p>对于一个static方法而言，无法访问泛型类型的参数。如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法。  </p>
</li>
<li><p>泛型类：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>{first = <span class="keyword">null</span>; second = <span class="keyword">null</span>;}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>{<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second;}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>{<span class="keyword">return</span> first;}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>{<span class="keyword">return</span> second;}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>{first = newValue;}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>{second = newValue;}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>泛型方法：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  类型变量放在修饰符（这里是public static）的后面，返回类型的前面。<br>  泛型方法可以定义在普通类中，也可以定义在泛型类中。<br>  当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q"</span>,<span class="string">"Public"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>  大多数情况下，方法调用中可以省略<string>类型参数。编译器有足够信息能够推断出所调用的方法。也就是说，可以调用：  </string></p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String middle = ArrayAlg.getMiddle(<span class="string">"John"</span>,<span class="string">"Q"</span>,<span class="string">"Public"</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>线程可以有如下6种状态：New(新创建)、Runnable(可运行)、Blocked(被阻塞)、Waiting(等待)、Timed waiting(计时等待)、Terminated(被终止)。  </p>
<ul>
<li>在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。  </li>
<li>当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。  </li>
<li>当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。  </li>
<li>有几个方法有一个超时参数，调用它们导致线程进入计时等待状态。  </li>
<li>线程因如下两个原因之一而被终止：因为run方法正常退出而自然死亡；因为一个没有捕获的异常终止了run方法而意外死亡。  </li>
</ul>
</li>
<li><p>同步：  </p>
<ol>
<li>锁和条件的关键之处：  <ul>
<li>锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。  </li>
<li>锁可以管理试图进入被保护代码段的线程。  </li>
<li>锁可以拥有一个或多个相关的条件对象。  </li>
<li>每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。  </li>
</ul>
</li>
<li>synchronize、wait()、notifyAll()  </li>
<li>除了调用同步方法获得锁，线程还可以通过进入一个同步阻塞获得锁：   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">synchronize(obj) {</span><br><span class="line">	critical section</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。（volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。）  </li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>CRC查表</title>
    <url>/2019/08/09/crc/</url>
    <content><![CDATA[<p>复制下来。</p>
<span id="more"></span>


<p>代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> crcTable[<span class="number">256</span>] = {</span><br><span class="line"><span class="number">0x00000000</span>, <span class="number">0x77073096</span>, <span class="number">0xEE0E612C</span>, <span class="number">0x990951BA</span>, <span class="number">0x076DC419</span>, <span class="number">0x706AF48F</span>,</span><br><span class="line"><span class="number">0xE963A535</span>, <span class="number">0x9E6495A3</span>, <span class="number">0x0EDB8832</span>, <span class="number">0x79DCB8A4</span>, <span class="number">0xE0D5E91E</span>, <span class="number">0x97D2D988</span>,</span><br><span class="line"><span class="number">0x09B64C2B</span>, <span class="number">0x7EB17CBD</span>, <span class="number">0xE7B82D07</span>, <span class="number">0x90BF1D91</span>, <span class="number">0x1DB71064</span>, <span class="number">0x6AB020F2</span>,</span><br><span class="line"><span class="number">0xF3B97148</span>, <span class="number">0x84BE41DE</span>, <span class="number">0x1ADAD47D</span>, <span class="number">0x6DDDE4EB</span>, <span class="number">0xF4D4B551</span>, <span class="number">0x83D385C7</span>,</span><br><span class="line"><span class="number">0x136C9856</span>, <span class="number">0x646BA8C0</span>, <span class="number">0xFD62F97A</span>, <span class="number">0x8A65C9EC</span>, <span class="number">0x14015C4F</span>, <span class="number">0x63066CD9</span>,</span><br><span class="line"><span class="number">0xFA0F3D63</span>, <span class="number">0x8D080DF5</span>, <span class="number">0x3B6E20C8</span>, <span class="number">0x4C69105E</span>, <span class="number">0xD56041E4</span>, <span class="number">0xA2677172</span>,</span><br><span class="line"><span class="number">0x3C03E4D1</span>, <span class="number">0x4B04D447</span>, <span class="number">0xD20D85FD</span>, <span class="number">0xA50AB56B</span>, <span class="number">0x35B5A8FA</span>, <span class="number">0x42B2986C</span>,</span><br><span class="line"><span class="number">0xDBBBC9D6</span>, <span class="number">0xACBCF940</span>, <span class="number">0x32D86CE3</span>, <span class="number">0x45DF5C75</span>, <span class="number">0xDCD60DCF</span>, <span class="number">0xABD13D59</span>,</span><br><span class="line"><span class="number">0x26D930AC</span>, <span class="number">0x51DE003A</span>, <span class="number">0xC8D75180</span>, <span class="number">0xBFD06116</span>, <span class="number">0x21B4F4B5</span>, <span class="number">0x56B3C423</span>,</span><br><span class="line"><span class="number">0xCFBA9599</span>, <span class="number">0xB8BDA50F</span>, <span class="number">0x2802B89E</span>, <span class="number">0x5F058808</span>, <span class="number">0xC60CD9B2</span>, <span class="number">0xB10BE924</span>,</span><br><span class="line"><span class="number">0x2F6F7C87</span>, <span class="number">0x58684C11</span>, <span class="number">0xC1611DAB</span>, <span class="number">0xB6662D3D</span>, <span class="number">0x76DC4190</span>, <span class="number">0x01DB7106</span>,</span><br><span class="line"><span class="number">0x98D220BC</span>, <span class="number">0xEFD5102A</span>, <span class="number">0x71B18589</span>, <span class="number">0x06B6B51F</span>, <span class="number">0x9FBFE4A5</span>, <span class="number">0xE8B8D433</span>,</span><br><span class="line"><span class="number">0x7807C9A2</span>, <span class="number">0x0F00F934</span>, <span class="number">0x9609A88E</span>, <span class="number">0xE10E9818</span>, <span class="number">0x7F6A0DBB</span>, <span class="number">0x086D3D2D</span>,</span><br><span class="line"><span class="number">0x91646C97</span>, <span class="number">0xE6635C01</span>, <span class="number">0x6B6B51F4</span>, <span class="number">0x1C6C6162</span>, <span class="number">0x856530D8</span>, <span class="number">0xF262004E</span>,</span><br><span class="line"><span class="number">0x6C0695ED</span>, <span class="number">0x1B01A57B</span>, <span class="number">0x8208F4C1</span>, <span class="number">0xF50FC457</span>, <span class="number">0x65B0D9C6</span>, <span class="number">0x12B7E950</span>,</span><br><span class="line"><span class="number">0x8BBEB8EA</span>, <span class="number">0xFCB9887C</span>, <span class="number">0x62DD1DDF</span>, <span class="number">0x15DA2D49</span>, <span class="number">0x8CD37CF3</span>, <span class="number">0xFBD44C65</span>,</span><br><span class="line"><span class="number">0x4DB26158</span>, <span class="number">0x3AB551CE</span>, <span class="number">0xA3BC0074</span>, <span class="number">0xD4BB30E2</span>, <span class="number">0x4ADFA541</span>, <span class="number">0x3DD895D7</span>,</span><br><span class="line"><span class="number">0xA4D1C46D</span>, <span class="number">0xD3D6F4FB</span>, <span class="number">0x4369E96A</span>, <span class="number">0x346ED9FC</span>, <span class="number">0xAD678846</span>, <span class="number">0xDA60B8D0</span>,</span><br><span class="line"><span class="number">0x44042D73</span>, <span class="number">0x33031DE5</span>, <span class="number">0xAA0A4C5F</span>, <span class="number">0xDD0D7CC9</span>, <span class="number">0x5005713C</span>, <span class="number">0x270241AA</span>,</span><br><span class="line"><span class="number">0xBE0B1010</span>, <span class="number">0xC90C2086</span>, <span class="number">0x5768B525</span>, <span class="number">0x206F85B3</span>, <span class="number">0xB966D409</span>, <span class="number">0xCE61E49F</span>,</span><br><span class="line"><span class="number">0x5EDEF90E</span>, <span class="number">0x29D9C998</span>, <span class="number">0xB0D09822</span>, <span class="number">0xC7D7A8B4</span>, <span class="number">0x59B33D17</span>, <span class="number">0x2EB40D81</span>,</span><br><span class="line"><span class="number">0xB7BD5C3B</span>, <span class="number">0xC0BA6CAD</span>, <span class="number">0xEDB88320</span>, <span class="number">0x9ABFB3B6</span>, <span class="number">0x03B6E20C</span>, <span class="number">0x74B1D29A</span>,</span><br><span class="line"><span class="number">0xEAD54739</span>, <span class="number">0x9DD277AF</span>, <span class="number">0x04DB2615</span>, <span class="number">0x73DC1683</span>, <span class="number">0xE3630B12</span>, <span class="number">0x94643B84</span>,</span><br><span class="line"><span class="number">0x0D6D6A3E</span>, <span class="number">0x7A6A5AA8</span>, <span class="number">0xE40ECF0B</span>, <span class="number">0x9309FF9D</span>, <span class="number">0x0A00AE27</span>, <span class="number">0x7D079EB1</span>,</span><br><span class="line"><span class="number">0xF00F9344</span>, <span class="number">0x8708A3D2</span>, <span class="number">0x1E01F268</span>, <span class="number">0x6906C2FE</span>, <span class="number">0xF762575D</span>, <span class="number">0x806567CB</span>,</span><br><span class="line"><span class="number">0x196C3671</span>, <span class="number">0x6E6B06E7</span>, <span class="number">0xFED41B76</span>, <span class="number">0x89D32BE0</span>, <span class="number">0x10DA7A5A</span>, <span class="number">0x67DD4ACC</span>,</span><br><span class="line"><span class="number">0xF9B9DF6F</span>, <span class="number">0x8EBEEFF9</span>, <span class="number">0x17B7BE43</span>, <span class="number">0x60B08ED5</span>, <span class="number">0xD6D6A3E8</span>, <span class="number">0xA1D1937E</span>,</span><br><span class="line"><span class="number">0x38D8C2C4</span>, <span class="number">0x4FDFF252</span>, <span class="number">0xD1BB67F1</span>, <span class="number">0xA6BC5767</span>, <span class="number">0x3FB506DD</span>, <span class="number">0x48B2364B</span>,</span><br><span class="line"><span class="number">0xD80D2BDA</span>, <span class="number">0xAF0A1B4C</span>, <span class="number">0x36034AF6</span>, <span class="number">0x41047A60</span>, <span class="number">0xDF60EFC3</span>, <span class="number">0xA867DF55</span>,</span><br><span class="line"><span class="number">0x316E8EEF</span>, <span class="number">0x4669BE79</span>, <span class="number">0xCB61B38C</span>, <span class="number">0xBC66831A</span>, <span class="number">0x256FD2A0</span>, <span class="number">0x5268E236</span>,</span><br><span class="line"><span class="number">0xCC0C7795</span>, <span class="number">0xBB0B4703</span>, <span class="number">0x220216B9</span>, <span class="number">0x5505262F</span>, <span class="number">0xC5BA3BBE</span>, <span class="number">0xB2BD0B28</span>,</span><br><span class="line"><span class="number">0x2BB45A92</span>, <span class="number">0x5CB36A04</span>, <span class="number">0xC2D7FFA7</span>, <span class="number">0xB5D0CF31</span>, <span class="number">0x2CD99E8B</span>, <span class="number">0x5BDEAE1D</span>,</span><br><span class="line"><span class="number">0x9B64C2B0</span>, <span class="number">0xEC63F226</span>, <span class="number">0x756AA39C</span>, <span class="number">0x026D930A</span>, <span class="number">0x9C0906A9</span>, <span class="number">0xEB0E363F</span>,</span><br><span class="line"><span class="number">0x72076785</span>, <span class="number">0x05005713</span>, <span class="number">0x95BF4A82</span>, <span class="number">0xE2B87A14</span>, <span class="number">0x7BB12BAE</span>, <span class="number">0x0CB61B38</span>,</span><br><span class="line"><span class="number">0x92D28E9B</span>, <span class="number">0xE5D5BE0D</span>, <span class="number">0x7CDCEFB7</span>, <span class="number">0x0BDBDF21</span>, <span class="number">0x86D3D2D4</span>, <span class="number">0xF1D4E242</span>,</span><br><span class="line"><span class="number">0x68DDB3F8</span>, <span class="number">0x1FDA836E</span>, <span class="number">0x81BE16CD</span>, <span class="number">0xF6B9265B</span>, <span class="number">0x6FB077E1</span>, <span class="number">0x18B74777</span>,</span><br><span class="line"><span class="number">0x88085AE6</span>, <span class="number">0xFF0F6A70</span>, <span class="number">0x66063BCA</span>, <span class="number">0x11010B5C</span>, <span class="number">0x8F659EFF</span>, <span class="number">0xF862AE69</span>,</span><br><span class="line"><span class="number">0x616BFFD3</span>, <span class="number">0x166CCF45</span>, <span class="number">0xA00AE278</span>, <span class="number">0xD70DD2EE</span>, <span class="number">0x4E048354</span>, <span class="number">0x3903B3C2</span>,</span><br><span class="line"><span class="number">0xA7672661</span>, <span class="number">0xD06016F7</span>, <span class="number">0x4969474D</span>, <span class="number">0x3E6E77DB</span>, <span class="number">0xAED16A4A</span>, <span class="number">0xD9D65ADC</span>,</span><br><span class="line"><span class="number">0x40DF0B66</span>, <span class="number">0x37D83BF0</span>, <span class="number">0xA9BCAE53</span>, <span class="number">0xDEBB9EC5</span>, <span class="number">0x47B2CF7F</span>, <span class="number">0x30B5FFE9</span>,</span><br><span class="line"><span class="number">0xBDBDF21C</span>, <span class="number">0xCABAC28A</span>, <span class="number">0x53B39330</span>, <span class="number">0x24B4A3A6</span>, <span class="number">0xBAD03605</span>, <span class="number">0xCDD70693</span>,</span><br><span class="line"><span class="number">0x54DE5729</span>, <span class="number">0x23D967BF</span>, <span class="number">0xB3667A2E</span>, <span class="number">0xC4614AB8</span>, <span class="number">0x5D681B02</span>, <span class="number">0x2A6F2B94</span>,</span><br><span class="line"><span class="number">0xB40BBE37</span>, <span class="number">0xC30C8EA1</span>, <span class="number">0x5A05DF1B</span>, <span class="number">0x2D02EF8D</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">CountCRC32</span><span class="params">(<span class="keyword">char</span> *pData, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> crc;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> c;</span><br><span class="line"></span><br><span class="line">    crc = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    {</span><br><span class="line">        c = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pData[i];</span><br><span class="line">        crc = ((crc&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x00FFFFFF</span>) ^ crcTable[ (crc^c) &amp; <span class="number">0xFF</span> ];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>( crc^<span class="number">0xFFFFFFFF</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://blog.csdn.net/liyuanbhu/article/details/7882789">循环冗余校验（CRC）算法入门引导</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>crc</tag>
        <tag>checksum</tag>
      </tags>
  </entry>
  <entry>
    <title>iHerb礼券码</title>
    <url>/2019/08/08/iherb/</url>
    <content><![CDATA[<p>分享我的iHerb礼券码</p>
<span id="more"></span>


<p><a href="https://cn.iherb.com/?rcode=BKZ9932">BKZ9932</a></p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>nutrition</tag>
        <tag>protein</tag>
        <tag>bulking</tag>
      </tags>
  </entry>
  <entry>
    <title>开始健身</title>
    <url>/2019/08/08/kaike/</url>
    <content><![CDATA[<p>BE BETTER TOMORROW THAN YOU ARE TODAY!  </p>
<span id="more"></span>


<p>身高170cm左右，大学期间体重在102斤到104斤之间浮动，身材很瘦。2016年年中开始工作之后，没多久就有了健身的想法，当时还不想去健身房，想从寝室健身开始，于是在公司宿舍住了大概半年后，搬出去开始自己租房子，大概2017年年中，终于买了一个哑铃凳和一对哑铃放在小出租屋里，果然，闲置了一年半，最后二手出了。健身失败。  </p>
<p>时间来到了2019年4月。半途而废的挫败感让我难堪，适逢<a href="https://zhuanlan.zhihu.com/Uncle-Zhuo">卓叔</a>新馆开张，我终于下定决心健身了，花了接近5000块钱买了20节课，这是我花钱最多的一次单次消费！卧槽，终于要开始了。前期一周两节课，分化开始后一周三节课，按照这个频率，课很快就学完了，觉得收获很大。公司现在搞了个小型健身房，我现在开始在公司练啦，对我有用的只有个史密斯机、一个哑铃凳和一架子哑铃，总比没有好吧！史密斯机练三大项很难受！没办法正常做硬拉和杠铃卧推，槽糕！  </p>
<p>5月1号和8月7号的自拍，有点小进步，嘻嘻。  </p>
<p>期待明年今日。  </p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>bulking</tag>
        <tag>fitness</tag>
        <tag>workout</tag>
        <tag>muscle</tag>
        <tag>training</tag>
        <tag>health</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB使用</title>
    <url>/2019/05/23/gdb/</url>
    <content><![CDATA[<p>GDB速查。  </p>
<span id="more"></span>


<p>常见调试命令  </p>
<table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">命令缩写</th>
<th align="left">命令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">backtrace</td>
<td align="left">bt</td>
<td align="left">查看函数调用堆栈</td>
</tr>
<tr>
<td align="left">frame</td>
<td align="left">f</td>
<td align="left">查看栈帧</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">l</td>
<td align="left">查看源码</td>
</tr>
<tr>
<td align="left">print</td>
<td align="left">p</td>
<td align="left">打印内部变量值</td>
</tr>
<tr>
<td align="left">info</td>
<td align="left">i</td>
<td align="left">查看程序状态</td>
</tr>
<tr>
<td align="left">display</td>
<td align="left">disp</td>
<td align="left">跟踪某变量，每次停下来则显示值</td>
</tr>
<tr>
<td align="left">run</td>
<td align="left">r</td>
<td align="left">开始运行程序</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">c</td>
<td align="left">继续程序运行，直到下一个断点</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">b</td>
<td align="left">设置断点</td>
</tr>
<tr>
<td align="left">start</td>
<td align="left">s</td>
<td align="left">开始执行程序</td>
</tr>
<tr>
<td align="left">step</td>
<td align="left">s</td>
<td align="left">执行下一条语句，若该语句为函数调用，则进入函数内的第一条语句</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">n</td>
<td align="left">执行下一条语句，不会进入函数内部执行</td>
</tr>
<tr>
<td align="left">watch</td>
<td align="left"></td>
<td align="left">监视变量值的变化</td>
</tr>
<tr>
<td align="left">file</td>
<td align="left"></td>
<td align="left">装入需要调试的程序</td>
</tr>
<tr>
<td align="left">set var name=v</td>
<td align="left"></td>
<td align="left">设置变量的值</td>
</tr>
<tr>
<td align="left">kill</td>
<td align="left">k</td>
<td align="left">杀掉正在调试的程序</td>
</tr>
<tr>
<td align="left">quit</td>
<td align="left">q</td>
<td align="left">退出GDB环境</td>
</tr>
</tbody></table>
<p>举例  </p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">info threads</td>
<td align="left">显示当前可调试的所有线程</td>
</tr>
<tr>
<td align="left">t 23</td>
<td align="left">跳到Thread ID 23</td>
</tr>
<tr>
<td align="left">f 1</td>
<td align="left">跳到第一帧</td>
</tr>
<tr>
<td align="left">thread apply all bt</td>
<td align="left">查看所有线程堆栈信息</td>
</tr>
<tr>
<td align="left">break 16</td>
<td align="left">设置断点，在源程序第16行处</td>
</tr>
<tr>
<td align="left">break func</td>
<td align="left">设置断点，在函数func( )入口处</td>
</tr>
<tr>
<td align="left">info break</td>
<td align="left">查看断点信息</td>
</tr>
<tr>
<td align="left">p i</td>
<td align="left">打印变量i的值</td>
</tr>
<tr>
<td align="left">finish</td>
<td align="left">退出函数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>2851</title>
    <url>/2019/05/11/2851/</url>
    <content><![CDATA[<p>速查。  </p>
<span id="more"></span>


<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>进入到code的Android版本目录，“pie”是Android 9  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kernel/android/pie  </span><br></pre></td></tr></tbody></table></figure>
<p>初始化编译环境  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> build/envsetup.sh  </span><br></pre></td></tr></tbody></table></figure>
<p>选择板型  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ lunch  </span><br></pre></td></tr></tbody></table></figure>
<p>进入到APK目录  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vendor/realtek/app/HKMediaBrowser  </span><br></pre></td></tr></tbody></table></figure>
<p>编译  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mm  </span><br></pre></td></tr></tbody></table></figure>
<p>在<code>kernel/android/pie/frameworks/base/services</code>目录下的东西，需要到这个目录下执行<code>mm</code>，<code>eng</code>版本会生成<code>services.jar</code>,<code>user-debug</code>会生成<code>services.jar``services.jar.prof``oat/arm/services.art``oat/arm/services.odex``oat/arm/services.vdex</code>  </p>
<p>编译kernel模块  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ make -C kernel/linux/linux-4.14/ CROSS_COMPILE=../../../kernel/system/tmp/toolchain/asdk-6.4.1-a55-EL-4.4-g2.26-a32nut-170810/bin/asdk-linux- modules  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mount -o rw,remount /  </span><br><span class="line">$ mount -o rw,remount /vendor  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="更新API"><a href="#更新API" class="headerlink" title="更新API"></a>更新API</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kernel/android/pie  </span><br><span class="line">$ <span class="built_in">source</span> build/envsetup.sh  </span><br><span class="line">$ lunch  </span><br><span class="line">$ make update-api  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="Android分区查看"><a href="#Android分区查看" class="headerlink" title="Android分区查看"></a>Android分区查看</h3><ul>
<li>查看分区数  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat /proc/partitions  </span><br></pre></td></tr></tbody></table></figure></li>
<li>查看分区名字  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls -l /dev/block/by-name/  </span><br></pre></td></tr></tbody></table></figure></li>
<li>查看分区挂载点  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat /proc/mounts  </span><br></pre></td></tr></tbody></table></figure></li>
<li>查看磁盘使用情况  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ df -h  </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ dumpsys -l <span class="comment">#查看当前所有的系统服务名称，接着就可以通过dumpsys + name查看某个服务的具体信息  </span></span><br><span class="line">$ dumpsys activity <span class="comment">#查询AMS服务相关信息  </span></span><br><span class="line">$ dumpsys window <span class="comment">#查询WMS服务相关信息  </span></span><br><span class="line">$ dumpsys cpuinfo <span class="comment">#查询CPU情况  </span></span><br><span class="line">$ dumpsys meminfo <span class="comment">#查询内存情况  </span></span><br><span class="line">$ dumpsys input <span class="comment">#查询linux event与android keyevent的映射  </span></span><br><span class="line"></span><br><span class="line">$ dumpsys activity a packagename <span class="comment">#获取某个应用的Activity信息  </span></span><br><span class="line">$ dumpsys activity s packagename <span class="comment">#获取某个应用的Service信息  </span></span><br><span class="line">$ dumpsys activity b packagename <span class="comment">#获取某个应用的Broadcast信息  </span></span><br><span class="line">$ dumpsys activity prov packagename <span class="comment">#获取某个应用的Provider信息  </span></span><br><span class="line">$ dumpsys activity p packagename <span class="comment">#查询某个应用的进程状态  </span></span><br><span class="line"></span><br><span class="line">$ dumpsys activity top <span class="comment">#当前界面app状态  </span></span><br><span class="line">$ dumpsys activity oom <span class="comment">#查看进程状态  </span></span><br><span class="line"></span><br><span class="line">$ dumpsys usb dump-descriptors -dump-list <span class="comment">#查看USB描述符状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ dumpsys activity | grep Focuse  </span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kernel/android/nougat/packages/apps/  </span><br><span class="line">$ find -name <span class="string">"AndroidManifest.xml"</span>  | xargs grep -wnr <span class="string">"com.android.tv.settings"</span>  </span><br><span class="line">$ ls kernel/android/nougat/packages/apps/TvSettings/Settings  </span><br></pre></td></tr></tbody></table></figure>

<h3 id="ADB使用"><a href="#ADB使用" class="headerlink" title="ADB使用"></a>ADB使用</h3><p>单板设置：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">setprop service.adb.tcp.port 5555  </span><br><span class="line">start adbd  </span><br><span class="line">ifconfig  </span><br></pre></td></tr></tbody></table></figure>

<p>PC机设置：<br>ipconfig确认IP是否跟单板在同一个网段上<br>Ping单板的IP<br>连接：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ adb connect 192.168.1.105:5555  </span><br><span class="line">$ adb shell  </span><br><span class="line">$ adb kill-server <span class="comment">#终止adb服务进程  </span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="logcat"><a href="#logcat" class="headerlink" title="logcat"></a>logcat</h3><p>常用功能：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ logcat -c <span class="comment">#清空所有的日志缓存信息  </span></span><br><span class="line">$ logcat -G 10M <span class="comment">#设置缓存区大小为10M  </span></span><br><span class="line">$ logcat -s MainActivity <span class="comment">#设置输出日志的标签，只显示MainActivity标签的日志  </span></span><br><span class="line">$ logcat -v time <span class="comment">#设置日志的输出格式，log带有日期  </span></span><br><span class="line">$ logcat | grep &lt;过滤内容&gt; <span class="comment">#根据内容过滤log  </span></span><br><span class="line">$ logcat CRYPTO:S <span class="comment">#S表示为不输出该标签的日志  </span></span><br><span class="line">$ logcat | grep -vE <span class="string">"CRYPTO"</span> <span class="comment">#滤掉CRYPTO  </span></span><br></pre></td></tr></tbody></table></figure>

<p>应用：<br>如何查看指定应用的日志？以包名为com.realtek.dtv的应用为例：  </p>
<ol>
<li>查看应用进程号  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ps | grep com.realtek.dtv  </span><br></pre></td></tr></tbody></table></figure>
获得信息，可知该应用的PID为1069：  <blockquote>
<p> 1069 1000       0:05 com.realtek.dtv<br> 2909 2000       0:00 grep com.realtek.dtv  </p>
</blockquote>
</li>
<li>过滤该应用的日志  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ logcat -c;logcat | grep 1069  </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>应用安装：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ pm install /storage/udisk/sda1/.apk  </span><br><span class="line">$ pm uninstall com.test.selftest  （包名） </span><br></pre></td></tr></tbody></table></figure>
<p>编辑框也可以直接输入信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ input text 12345678  </span><br></pre></td></tr></tbody></table></figure>
<p>bootcode指令烧录:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ usb start;  </span><br><span class="line">$ fatload usb 0:1 0x1500000 dvrboot.rescue.exe.bin;  </span><br><span class="line">$ go 0x1500000  </span><br></pre></td></tr></tbody></table></figure>
<p>升级内核：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ swuu vmlinux.pkg  </span><br></pre></td></tr></tbody></table></figure>
<p>打开KERNEL打印信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 7 4 1 7 &gt; /proc/sys/kernel/printk  </span><br></pre></td></tr></tbody></table></figure>
<p>关闭KERNEL打印信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 0 4 1 7 &gt; /proc/sys/kernel/printk  </span><br></pre></td></tr></tbody></table></figure>
<p>打开demod打印信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"log_onoff=1"</span> &gt; /proc/rtkdemod/dbg  </span><br></pre></td></tr></tbody></table></figure>
<p>开bootcode打印：<br>编辑bootcode/uboot/include/configs/rtd285o_common.h  </p>
<p>快速打开一个应用：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ am start com.android.tv.settings/com.android.tv.settings.MainSettings  </span><br></pre></td></tr></tbody></table></figure>

<p>调试IR信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ rtd irda set_decode_dbg_en 1  </span><br></pre></td></tr></tbody></table></figure>
<p>选择IR协议：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ rtd irda set_protocol 1  </span><br></pre></td></tr></tbody></table></figure>
<p>快速复位：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ am broadcast -a android.intent.action.MASTER_CLEAR  </span><br></pre></td></tr></tbody></table></figure>
<p>输入虚拟键：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ input keyevent 26 //keycode_power  </span><br></pre></td></tr></tbody></table></figure>
<p>查看input设备的属性：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat /proc/bus/input/devices  </span><br></pre></td></tr></tbody></table></figure>
<p>编译差分包：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ./build/tools/releasetools/ota_from_target_files -i ota_target_files_old.zip ota_target_files.zip update.zip  </span><br></pre></td></tr></tbody></table></figure>
<p>升级OTA：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ touch /cache/recovery/<span class="built_in">command</span>;  </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"--update_package=/data/update.zip"</span> &gt; /cache/recovery/<span class="built_in">command</span>;  </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"--wipe_data"</span> &gt;&gt; /cache/recovery/<span class="built_in">command</span>;  </span><br><span class="line">$ sync;  </span><br><span class="line">$ reboot  </span><br></pre></td></tr></tbody></table></figure>
<p>按住TAB  </p>
<p>打包系统log信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tar cvf /mnt/media_rw/sda1/log.tar /tmp/var/<span class="built_in">log</span>/ /data/anr/ /data/tombstones/;sync;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>mm编译出来的软件无法安装：<br>不生成<code>odex</code>，只生成<code>apk</code>，就可以安装了。<br>把<code>Android.mk</code>的<code>LOCAL_DEX_PREOPT </code>设定为<code>false</code>。  </p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>挂在so的问题，一般可以看<code>tombstones</code>文件，或者用<code>addr2line</code>工具定位：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ addr2line -f -C -e libhbbtv_jni.so 0000381b</span><br></pre></td></tr></tbody></table></figure>
<p><code>-f</code>显示函数名称<br><code>-C</code>显示函数参数  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>realtek</tag>
        <tag>android</tag>
        <tag>2851</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用</title>
    <url>/2019/05/10/git/</url>
    <content><![CDATA[<p>速查。  </p>
<span id="more"></span>


<h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><ul>
<li><p>把文件修改添加到暂存区：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git add</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>提交修改，把暂存区的内容提交到当前分支：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>下载远程分支<code>rtk_base</code>的代码，并把根文件夹命名为<code>rtk_code_base</code>：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b rtk_base http://123.45.6.78:9999/Hlkffm_Bndroid/2951_hlkffm_0402.git rtk_code_base </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>单行显示git记录，包括版本号和commit log：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>显示1个commit：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1</span><br></pre></td></tr></tbody></table></figure>
<p>  如果想显示5个，就-5，不指定的话，会从该commit一直往后显示</p>
</li>
<li><p>查看一段时间区间的提交信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --since=<span class="string">"2019-11-18 00:00:00"</span> --until=<span class="string">"2019-12-01 00:00:00"</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看具体某一个版本，包括修改的作者、时间、文件等，以及“shows number of added and deleted lines”：    </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git show 7f7c809c1f537a3ffff57667d41424e1cff8cad1 --numstat</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看某行代码提交记录：  </p>
<p>  查看index.js文件中第38行的提交修改记录：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git blame -L 38,38 src/component/BarCode/index.js</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看某个文件中某个函数的提交记录：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -L :FunctionName:FilePath</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看单个文件的历史修改记录：  </p>
<p>  首先切换到要查看的文件所在的目录  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kernel/android/pie/vendor/realtek/app/HKMediaBrowser/app/src/main/java/com/hk/mediabrowser/activity/</span><br></pre></td></tr></tbody></table></figure>

<p>  列出文件的所有改动历史  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline PhotoPlayerActivity.java</span><br></pre></td></tr></tbody></table></figure>

<p>  显示该文件每次提交的diff  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p PhotoPlayerActivity.java</span><br></pre></td></tr></tbody></table></figure>

<p>  查看某个提交中的某个文件的变化  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git show 4a771319a90dad7d654dbd7ece50cd9add0fef30 PhotoPlayerActivity.java</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>HEAD指向的版本就是当前版本，在版本的历史之间切换：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git reset --hard commit_id</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在两个版本之间创建Diff：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git diff [旧版本 Commit ID] [新版本 Commit ID] &gt; [Diff文件名]</span><br></pre></td></tr></tbody></table></figure>
<p>  eg:  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git diff 5af260f2e3974e0d043a42f397b2d9165e6b4d3f e4c3cbd7700e5230e6b053cf3e231bced23f4edc &gt; patch.diff</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>应用Diff：  </p>
<p>  检查Diff文件  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git apply --<span class="built_in">stat</span> patch.diff</span><br></pre></td></tr></tbody></table></figure>

<p>  检查Diff文件是否能正常打入  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git apply --check patch.diff</span><br></pre></td></tr></tbody></table></figure>

<p>  打入Diff  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git apply patch.diff</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看命令历史：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看工作区和版本库里面最新版本的区别：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>丢弃工作区的修改：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p>  把readme.txt文件在工作区的修改全部撤销，这里有两种情况：  </p>
<ol>
<li>readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；  </li>
<li>readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。  </li>
</ol>
</li>
<li><p>把暂存区的修改撤销掉(unstage)：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>合并某分支到当前分支:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git merge &lt;name&gt;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>清理掉本地不受版本库控制的文件:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git clean -f</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136">stash应用场景 - 处理临时任务前需要保存工作现场</a>  </p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320">多人协作</a>  </p>
</li>
<li><p>rebase  </p>
</li>
<li><p>标签    </p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424">配置别名</a>  </p>
</li>
<li><p>开发步骤  </p>
<ol>
<li>切换到最新的develop分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git fetch origin;git checkout origin/develop;git branch -D develop;git checkout -b develop</span><br></pre></td></tr></tbody></table></figure></li>
<li>新建一个自己的临时开发分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -b user_01</span><br></pre></td></tr></tbody></table></figure></li>
<li>添加修改  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git add path/file</span><br></pre></td></tr></tbody></table></figure></li>
<li>提交修改，并产生一个git_ID:0deaddead  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">""</span><span class="string">""</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>切换到最新的develop分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git fetch origin;git checkout origin/develop;git branch -D develop;git checkout -b develop</span><br></pre></td></tr></tbody></table></figure></li>
<li>拉取刚才的提交，到最新的develop分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git cherry-pick 0deaddead</span><br></pre></td></tr></tbody></table></figure></li>
<li>推送到服务器  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin develop:develop</span><br></pre></td></tr></tbody></table></figure></li>
<li>删除自己临时的开发分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch -D user_01</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><p>git不同code，修改相同路径相同的文件，直接抓取的修改文件的方法：  </p>
<p>  例如，谷歌TV抓取歌谷TV上的文件，在谷歌TV code执行：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote add gegu git@123.45.6.78:Android_RD/gegu_tv.git  </span><br><span class="line">$ git remount -v  </span><br><span class="line">$ git fetch gegu  </span><br><span class="line">$ git pull  </span><br><span class="line">$ git cherry-pick xxxxxxx(gegu上的gitid)  </span><br><span class="line">$ git push origin develop  </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://git-scm.com/docs/git-show">git show</a>  </li>
<li><a href="https://www.git-scm.com/docs/git-log#Documentation/git-log.txt--Lltstartgtltendgtltfilegt">git log</a>  </li>
<li><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README.md">git-flight-rules</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>[转载]Android System Server大纲之LightsService</title>
    <url>/2019/03/19/lights-service/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从功能机以来，手机等设备就配备了Led闪光灯，当有未接电话、未读短信和通知等等，Led就会闪烁。和振动器类似，都是给用户一种人机交互的反馈，哪怕这种人机交互是那么的简单。既然它是一个Led，也就是一个硬件，Android系统上层驱动这个硬件的服务就是LightsService，所以，这个文章也是描述一个软硬件结合的功能。但是上层APP不能直接驱动Led硬件，LightsService是系统所使用。    </p>
<span id="more"></span>


<p>既然是软硬结合的一个功能，那么在Android系统里，从上到下实现这个功能的架构如下：<br><img src="https://i.loli.net/2019/03/19/5c90af777f197.png" alt="FamilyYuan.png">  </p>
<h2 id="LightsService初始化"><a href="#LightsService初始化" class="headerlink" title="LightsService初始化"></a>LightsService初始化</h2><p>回顾《<a href="https://blog.csdn.net/myfriend0/article/details/55098173">Android系统之System Server大纲</a>》一文，LightsService在frameworks/base/services/java/com/android/server/SystemServer.java中的启动过程是：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>{</span><br><span class="line">        <span class="comment">// Manages LEDs and display backlight so we need it to bring up the display.</span></span><br><span class="line">        mSystemServiceManager.startService(LightsService.class);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的代码中，LightsService是通过SystemServiceManager.startService()的方式启动，在《<a href="https://blog.csdn.net/myfriend0/article/details/55098173">Android系统之System Server大纲</a>》一文中提到的Android系统的各种服务的启动方式可知，LightsService是继承了SystemService，LightsService启动后会回调onStart()方法。代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{</span><br><span class="line">        publishLocalService(LightsManager.class, mService);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码在frameworks/base/services/core/java/com/android/server/lights/LightsService.java中。<br>在《<a href="https://blog.csdn.net/myfriend0/article/details/55098173">Android系统之System Server大纲</a>》一文中提到，publishLocalService()的作用，这里是把mService推进LocalServices中，所以外部引用LightsService时，实际是拿到mService这个对象。mService的代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LightsManager mService = <span class="keyword">new</span> LightsManager() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Light <span class="title">getLight</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (id &lt; LIGHT_ID_COUNT) {</span><br><span class="line">                <span class="keyword">return</span> mLights[id];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>mService的实质是一个LightsManager，LightsManager只提供一个方法getLight(int id)，从数组mLights中匹配一个返回值，返回值是什么类型呢？看mLights[]的本质，如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> LightImpl mLights[] = <span class="keyword">new</span> LightImpl[LightsManager.LIGHT_ID_COUNT];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>mLights[]的实质一个LightImpl的数组，所以LightsManager的getLight(int id)返回的是一个LightImpl的实例，LightImpl的代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LightImpl</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>{</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlashing</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> mode, <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS)</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                setLightLocked(color, mode, onMS, offMS, BRIGHTNESS_MODE_USER);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>LightImpl实际是Light的子类，而Light实质是一个led硬件的抽象，那么一个led就被抽象成一个Light对象。因此，要控制led，只要拿到led的抽象对象Light即可实现驱动led。  </p>
<p>回头再看看LightsService的初始化，LightsService的构造方法如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightsService</span><span class="params">(Context context)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line"></span><br><span class="line">        mNativePointer = init_native();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LightsManager.LIGHT_ID_COUNT; i++) {</span><br><span class="line">            mLights[i] = <span class="keyword">new</span> LightImpl(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上文提到的LightImpl数组mLights就是在LightsService中被初始化了，这里会根据LightsManager.LIGHT_ID_COUNT的总数循环生成LightImpl的实例保存在mLights数组中。这里的LightsManager.LIGHT_ID_COUNT的值是8，代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsManager</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_BACKLIGHT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_KEYBOARD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_BUTTONS = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_BATTERY = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_NOTIFICATIONS = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_ATTENTION = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_BLUETOOTH = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_WIFI = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_COUNT = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Light <span class="title">getLight</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从LIGHT_ID_BACKLIGHT到LIGHT_ID_WIFI共8个，这里是否表示8个led呢，后文在论述清楚。回到LightsService的构造方法，调用了init_native()方法，当然，熟悉Android架构的都清楚，其它硬件的服务和LightsService一样，都有这么一个过程。目的就是LightsService启动时，调用init_native()初始化硬件，也就是软硬件的通道在init_native()这个方法中打通。init_native()是一个native方法，对应的JNI接口是：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">init_native</span><span class="params">(JNIEnv* <span class="comment">/* env */</span>, jobject <span class="comment">/* clazz */</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    hw_module_t* <span class="keyword">module</span>;</span><br><span class="line">    Devices* devices;</span><br><span class="line"></span><br><span class="line">    devices = (Devices*)malloc(sizeof(Devices));</span><br><span class="line"></span><br><span class="line">    err = hw_get_module(LIGHTS_HARDWARE_MODULE_ID, (hw_module_t <span class="keyword">const</span>**)&amp;<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">        ......</span><br><span class="line">        devices-&gt;lights[LIGHT_INDEX_NOTIFICATIONS]</span><br><span class="line">                = get_device(<span class="keyword">module</span>, LIGHT_ID_NOTIFICATIONS);</span><br><span class="line">        ......</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        memset(devices, <span class="number">0</span>, sizeof(Devices));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (jlong)devices;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个函数定义在文件frameworks/base/services/core/jni/com_android_server_lights_LightsService.cpp中。  </p>
<p>init_native()中首先调用了hw_get_module()函数，这个函数就是打开硬件设备，这个是函数的实现过程在hardware/libhardware/hardware.c中，对Android HAL熟悉的读者，应该很熟悉这个过程，本文也不往下赘述这个过程了。然后通过调用get_device()函数取得返回值赋值Devices的变量lights，get_device()的一个参数是LIGHT_ID_NOTIFICATIONS，这和上文中LightsManager的8个led id是对应的。Devices的变量lights的实质是：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">struct Devices {</span><br><span class="line">    light_device_t* lights[LIGHT_COUNT];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>light_device_t定义在hardware/libhardware/include/hardware/lights.h文件中。回到init_native()函数，接着看get_device()这个函数：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> light_device_t* get_device(hw_module_t* <span class="keyword">module</span>, <span class="keyword">char</span> <span class="keyword">const</span>* name)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    hw_device_t* device;</span><br><span class="line">    err = <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>, name, &amp;device);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> (light_device_t*)device;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过module-&gt;methods-&gt;open()打开硬件设备，这个过程本文就不再赘述了。打开设备通道后，取得light_device_t，保存在Devices的数组lights中，这和LightsService上文中的LightImpl的数组mLights也是对应的关系。  </p>
<h2 id="通过LightsService启动Led"><a href="#通过LightsService启动Led" class="headerlink" title="通过LightsService启动Led"></a>通过LightsService启动Led</h2><p>APP虽然不能直接驱动led，但是led一般也是为Android的Notification所使用，所以APP发起一个通知，led也会闪烁。本文就从Android的notification入手，分析驱动led的过程。  </p>
<p>APP创建Notification时，可以通过如下方法指定这个notification需要led：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setLights</span><span class="params">(<span class="meta">@ColorInt</span> <span class="keyword">int</span> argb, <span class="keyword">int</span> onMs, <span class="keyword">int</span> offMs)</span> </span>{</span><br><span class="line">    mN.ledARGB = argb;</span><br><span class="line">    mN.ledOnMS = onMs;</span><br><span class="line">    mN.ledOffMS = offMs;</span><br><span class="line">    <span class="keyword">if</span> (onMs != <span class="number">0</span> || offMs != <span class="number">0</span>) {</span><br><span class="line">        mN.flags |= FLAG_SHOW_LIGHTS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>本文暂时不对这个方法进行过多的阐述，会在以后的文章中再详细介绍Android的notification机制。当然APP如果不调用这个方法，那么Android系统会自动为APP的notification选取默认值。  </p>
<p>APP的notification通知到Android系统以后，就会驱动led闪烁起来。在上文LightsService的初始化中提到，led硬件已经抽象成一个Light对象，这个对象便是LightImpl，获取到LightImpl的实例，便可驱动led。Android的notification获取LightImpl的代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> LightsManager lights = getLocalService(LightsManager.class);</span><br><span class="line">    mNotificationLight = lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个类定义在文件frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java中。  </p>
<p>在上文LightsService的初始化中可知，LightsService被推进到LocalService中，所以是通过getLocalService()获取到LightsManager，然后再通过getLight()方法，获取到LightImpl的实例，这个过程在上文LightsService的初始化中已经阐述的很明白。获取到了LightImpl，通过什么接口驱动led呢？先看看LightImpl的结构：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setBrightness</span><span class="params">(<span class="keyword">int</span> brightness)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setBrightness</span><span class="params">(<span class="keyword">int</span> brightness, <span class="keyword">int</span> brightnessMode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setFlashing</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> mode, <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pulse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pulse</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> onMS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个类定义在文件frameworks/base/services/core/java/com/android/server/lights/Light.java中。  </p>
<p>如上面的代码，LightImpl提供setBrightness()设置亮度、setColor设置颜色、setFlashing启动led等7个方法。因此，Anroid notification驱动led的代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">mNotificationLight.setFlashing(ledARGB, Light.LIGHT_FLASH_TIMED,ledOnMS, ledOffMS);</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法定义在文件frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java中。<br>setFlashing()接收四个参数，第一个当然是颜色，类型是rgb；第二参数是mode，数值分别是可以是：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_FLASH_NONE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_FLASH_TIMED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_FLASH_HARDWARE = <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这些变量定义在文件frameworks/base/services/core/java/com/android/server/lights/Light.java中。<br>第三个和第四个是一对相反的参数，分别表示led闪烁时亮的时间，led闪烁时灭的时间。接着看setFlashing()的实现：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LightImpl</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlashing</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> mode, <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            setLightLocked(color, mode, onMS, offMS, BRIGHTNESS_MODE_USER);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法定义在文件frameworks/base/services/core/java/com/android/server/lights/LightsService.java中。<br>直接调用了setLightLocked()，代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LightImpl</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLightLocked</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> mode, <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS, <span class="keyword">int</span> brightnessMode)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!mLocked &amp;&amp; (color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS ||</span><br><span class="line">            mBrightnessMode != brightnessMode)) {</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">"setLight #"</span> + mId + <span class="string">": color=#"</span></span><br><span class="line">                + Integer.toHexString(color) + <span class="string">": brightnessMode="</span> + brightnessMode);</span><br><span class="line">        mLastColor = mColor;</span><br><span class="line">        mColor = color;</span><br><span class="line">        mMode = mode;</span><br><span class="line">        mOnMS = onMS;</span><br><span class="line">        mOffMS = offMS;</span><br><span class="line">        mLastBrightnessMode = mBrightnessMode;</span><br><span class="line">        mBrightnessMode = brightnessMode;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_POWER, <span class="string">"setLight("</span> + mId + <span class="string">", 0x"</span></span><br><span class="line">                + Integer.toHexString(color) + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            setLight_native(mNativePointer, mId, color, mode, onMS, offMS, brightnessMode);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_POWER);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法定义在文件frameworks/base/services/core/java/com/android/server/lights/LightsService.java中。  </p>
<p>对参数整理一遍后，调用了JNI方法setLight_native()，这里的第二个参数便是LightsManager.LIGHT_ID_NOTIFICATIONS = 4；继续往下看setLight_native()：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLight_native</span><span class="params">(JNIEnv* <span class="comment">/* env */</span>, jobject <span class="comment">/* clazz */</span>, jlong ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint light, jint colorARGB, jint flashMode, jint onMS, jint offMS, jint brightnessMode)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Devices* devices = (Devices*)ptr;</span><br><span class="line">    <span class="keyword">light_state_t</span> state;</span><br><span class="line">    ......</span><br><span class="line">    state.brightnessMode = brightnessMode;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">ALOGD_IF_SLOW</span>(<span class="number">50</span>, <span class="string">"Excessive delay setting light"</span>);</span><br><span class="line">        devices-&gt;lights[light]-&gt;<span class="built_in">set_light</span>(devices-&gt;lights[light], &amp;state);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个函数定义在文件frameworks/base/services/core/jni/com_android_server_lights_LightsService.cpp中。  </p>
<p>set_light()的定义是在文件hardware/libhardware/include/hardware/lights.h中，具体实现，就因led的硬件厂商不同而不同了，这里以某个led的厂商为例：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_lights</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">char</span> <span class="keyword">const</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">               struct <span class="keyword">hw_device_t</span> **device)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dragon_lights</span> *<span class="title">lights</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    lights-&gt;base.set_light = set_light_backlight;</span><br><span class="line"></span><br><span class="line">    *device = (struct <span class="keyword">hw_device_t</span> *)lights;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在led通道初始化过程中，set_light()函数实际调用的是set_light_backlight函数，set_light_backlight函数如下：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_light_backlight</span><span class="params">(struct <span class="keyword">light_device_t</span> *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                   struct <span class="keyword">light_state_t</span> <span class="keyword">const</span> *state)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dragon_lights</span> *<span class="title">lights</span> =</span> <span class="built_in">to_dragon_lights</span>(dev);</span><br><span class="line">    <span class="keyword">int</span> err, brightness_idx;</span><br><span class="line">    <span class="keyword">int</span> brightness = <span class="built_in">rgb_to_brightness</span>(state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (brightness &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// Get the bin number for brightness (0 to kNumBrightnessLevels - 1)</span></span><br><span class="line">        brightness_idx = (brightness - <span class="number">1</span>) * kNumBrightnessLevels / <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get brightness level</span></span><br><span class="line">        brightness = kBrightnessLevels[brightness_idx];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lights-&gt;lock);</span><br><span class="line">    err = <span class="built_in">write_brightness</span>(lights, brightness);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;lights-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>跟踪到这里，本文也就不往下跟踪了，这些代码都会因led厂商不同而不同。驱动led的过程就到此结束。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文阐述了LightsService的作用，从打开硬件通道和驱动硬件led闪烁起来的过程，虽然APP是不可以直接驱动led，但是led几乎都是为android notification所用，所以，APP发布的notification也可以使用led，通知用户有新的状态。对于上文提到的led颜色，对于很多设备，是不支持设置颜色了的，设置了也只能是一种颜色，所以在这些设备上，可以说是大多数设备，这个功能基本就没有任何用处。另外，因led硬件的不同，文章中提到的8个led id，可能有，可能没有。  </p>
<hr>
<ol>
<li><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://blog.csdn.net/myfriend0/article/details/56482594">原文链接</a>  </li>
<li>网上另外一篇不错的文章：<a href="https://blog.csdn.net/zhangchiytu/article/details/7958513">lights从上到下的流程</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title>Java接口回调</title>
    <url>/2019/03/18/callback-2/</url>
    <content><![CDATA[<blockquote>
<p>Android中的回调，遵循的基本思想是Java中的回调函数。<br>回调函数就是一个通过函数指针调用的函数。如果你的函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的时间或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。<br>Java中没有指针的概念，通过接口和内部类的方式实现回调的功能。  </p>
</blockquote>
<span id="more"></span>


<p>举个栗子，有以下几个文件：  </p>
<p>文件Interface.java，接口定义类：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iPrintf</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件App.java，接口的实现类1：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iPrintf</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"impl: printf"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件App2.java，接口的实现类2：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App2</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iPrintf</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"impl: printf 2"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件Sys.java，调用回调函数的类：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sys</span> </span>{</span><br><span class="line">	<span class="comment">//定义回调接口的成员变量</span></span><br><span class="line">	<span class="keyword">private</span> Interface mInterface;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置回调接口对象成员变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Interface mInterface)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.mInterface = mInterface;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用回调接口对象中的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCallback</span><span class="params">()</span> </span>{</span><br><span class="line">		mInterface.iPrintf();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件Test.java，测试类：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>{</span><br><span class="line">		Sys mSys = <span class="keyword">new</span> Sys();</span><br><span class="line">		App mApp = <span class="keyword">new</span> App();</span><br><span class="line">		App2 mApp2 = <span class="keyword">new</span> App2();</span><br><span class="line">		mSys.setCallback(mApp); <span class="comment">//通过形参传递接口的实现类的对象的引用</span></span><br><span class="line">		mSys.doCallback();</span><br><span class="line">		mSys.setCallback(mApp2); <span class="comment">//通过形参传递接口的实现类的对象的引用</span></span><br><span class="line">		mSys.doCallback();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://blog.csdn.net/linshijun33/article/details/48183925">Android接口回调，最简单的理解方式</a>  </li>
<li><a href="https://www.imooc.com/article/20224">Android 回调方法的实现</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>callback</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>callback function in c example</title>
    <url>/2019/03/16/callback/</url>
    <content><![CDATA[<p>网上查到的很好的解释：    </p>
<blockquote>
<p>回调函数是指使用者自己定义一个函数，实现这个函数的程序内容，然后把这个函数（入口地址）作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。  </p>
</blockquote>
<span id="more"></span>


<p>至少在应用之间异步消息传递、驱动层与应用层之间的通信上有奇效。代码中很多模块的实现都使用回调做法（代码写得还真绕，看了好一会<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），后来在添加Uart/IR工厂自动化测试，单键通过按键面板实现7键功能上也参考了。<br>思路是先实现回调函数功能，然后把回调函数赋给一个函数指针（注册回调函数），最后使用这个函数指针即可。例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*callbackFunc)</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">callbackFunc pCallbackFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerCallbackFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pCallbackFunc = &amp;add;</span><br><span class="line">	<span class="comment">//pCallbackFunc = add; //ok</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	registerCallbackFunc();</span><br><span class="line">	c = (*pCallbackFunc)(a,b);</span><br><span class="line">	<span class="comment">//c = pCallbackFunc(a,b); //ok</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c = %d\n"</span>,c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://www.geeksforgeeks.org/callbacks-in-c/">Callbacks in C</a>  </li>
<li><a href="https://stackoverflow.com/questions/142789/what-is-a-callback-in-c-and-how-are-they-implemented">What is a “callback” in C and how are they implemented?</a>  </li>
<li><a href="https://segmentfault.com/a/1190000008293902">一文搞懂C语言回调函数</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>callback</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔</title>
    <url>/2019/02/16/hanoi-tower/</url>
    <content><![CDATA[<p>递归实现汉诺塔问题。  </p>
<span id="more"></span>


<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveOne</span><span class="params">(<span class="keyword">int</span> diskNum, <span class="keyword">char</span> init, <span class="keyword">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"move disk %d from %c to %c\n"</span>,diskNum,init,dest);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> diskNum, <span class="keyword">char</span> init, <span class="keyword">char</span> temp, <span class="keyword">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(diskNum == <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		moveOne(diskNum, init, dest);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		move(diskNum<span class="number">-1</span>, init, dest, temp);</span><br><span class="line">		moveOne(diskNum, init, dest);</span><br><span class="line">		move(diskNum<span class="number">-1</span>, temp, init, dest);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	move(<span class="number">3</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：  </p>
<blockquote>
<p>move disk 1 from A to C<br>move disk 2 from A to B<br>move disk 1 from C to B<br>move disk 3 from A to C<br>move disk 1 from B to A<br>move disk 2 from B to C<br>move disk 1 from A to C  </p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>algorithm</tag>
        <tag>hanoi</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2019/02/15/search/</url>
    <content><![CDATA[<p>查找算法。<br><img src="https://i.loli.net/2019/02/15/5c663799023fb.png">  </p>
<span id="more"></span>


<p>例程如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinearSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> keyValue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 线性查找，一般当序列无序时使用</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(a[i] == keyValue)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> keyValue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 折半查找，适用于有序序列</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> R = length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> M = (L+R)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[M] &gt; keyValue)</span><br><span class="line">			R = M - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[M] &lt; keyValue)</span><br><span class="line">			L = M + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> M;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OMGSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> keyValue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 插值查找，适用于元素分布均匀的有序序列，因其按照线性比例来确定M值</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> R = length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// M值根据如下数学方程获得：</span></span><br><span class="line">		<span class="comment">// (keyValue - a[L]) : (M - L) = (a[R] - a[L]) : (R - L)</span></span><br><span class="line">		<span class="keyword">int</span> M = (keyValue - a[L]) * (R - L) / (a[R] - a[L]) + L;</span><br><span class="line">		<span class="keyword">if</span>(a[M] &gt; keyValue)</span><br><span class="line">			R = M - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[M] &lt; keyValue)</span><br><span class="line">			L = M + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> M;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size = <span class="number">20</span>; <span class="comment">// 斐波那契数组的长度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> F[])</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">	<span class="comment">// 构造一个斐波那契数组</span></span><br><span class="line">	F[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">	F[<span class="number">1</span>] = <span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; max_size; i++)  </span><br><span class="line">		F[i] = F[i<span class="number">-1</span>] + F[i<span class="number">-2</span>];  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> keyValue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 斐波那契查找</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">int</span> R = length - <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> F[max_size];  </span><br><span class="line">	Fibonacci(F); <span class="comment">// 构造一个斐波那契数组F   </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">while</span>(length &gt; F[k]) <span class="comment">// 计算length位于斐波那契数列的位置  </span></span><br><span class="line">		k++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp[F[k]<span class="number">-1</span>]; <span class="comment">// 将数组a扩展到F[k]-1的长度  </span></span><br><span class="line">	<span class="built_in">memcpy</span>(temp,a,length*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &lt; F[k]<span class="number">-1</span>; i++)  </span><br><span class="line">		temp[i] = a[length<span class="number">-1</span>];  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R)  </span><br><span class="line">	{  </span><br><span class="line">		<span class="keyword">int</span> M = L + F[k<span class="number">-1</span>] - <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span>(keyValue &lt; temp[M])  </span><br><span class="line">		{  </span><br><span class="line">			R = M - <span class="number">1</span>;  </span><br><span class="line">			k -= <span class="number">1</span>;  </span><br><span class="line">		}  </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(keyValue &gt; temp[M])  </span><br><span class="line">		{  </span><br><span class="line">			L = M + <span class="number">1</span>;  </span><br><span class="line">			k -= <span class="number">2</span>;  </span><br><span class="line">		}  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">		{  </span><br><span class="line">			<span class="keyword">if</span>(M &lt; length)  </span><br><span class="line">				<span class="keyword">return</span> M; <span class="comment">// 若相等则说明M即为查找到的位置  </span></span><br><span class="line">			<span class="keyword">else</span>  </span><br><span class="line">				<span class="keyword">return</span> length<span class="number">-1</span>; <span class="comment">// 若M&gt;=length则说明是扩展的数值,返回length-1  </span></span><br><span class="line">		}  </span><br><span class="line">	}    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">100</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> keyValue = <span class="number">25</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"LinearSearch Result: %d at %d\n"</span>,keyValue,LinearSearch(a,length,keyValue));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"BinarySearch Result: %d at %d\n"</span>,keyValue,BinarySearch(a,length,keyValue));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"OMGSearch Result: %d at %d\n"</span>,keyValue,OMGSearch(a,length,keyValue));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FibonacciSearch Result: %d at %d\n"</span>,keyValue,FibonacciSearch(a,length,keyValue));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>algorithm</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2019/02/14/merge-sort/</url>
    <content><![CDATA[<p>归并排序，是指将两个有序序列合并成一个有序序列的操作。两个有序序列如何获得？通过从上到下递归分解序列，当元素为1时就是有序序列。接着从下到上合并序列，最后得到一个有序序列。  </p>
<span id="more"></span>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arrays</span></span><br><span class="line"><span class="comment"> * @param L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * @param M      指向数组分隔的元素</span></span><br><span class="line"><span class="comment"> * @param R      指向数组最后的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arrays[], <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lengthLeft = M - L;</span><br><span class="line">	<span class="keyword">int</span> lengthRight = R - M + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左边的数组的大小</span></span><br><span class="line">	<span class="keyword">int</span> leftArray[lengthLeft];</span><br><span class="line">	<span class="built_in">memset</span>(leftArray,<span class="number">0</span>,lengthLeft*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//右边的数组大小</span></span><br><span class="line">	<span class="keyword">int</span> rightArray[lengthRight];</span><br><span class="line">	<span class="built_in">memset</span>(rightArray,<span class="number">0</span>,lengthRight*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//往这两个数组填充数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) {</span><br><span class="line">		leftArray[i - L] = arrays[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) {</span><br><span class="line">		rightArray[i - M] = arrays[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//arrays数组的第一个元素</span></span><br><span class="line">	<span class="keyword">int</span> k = L;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//比较这两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; lengthLeft &amp;&amp; j &lt; lengthRight) {</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//谁比较小，谁将元素放入大数组中,移动指针，继续比较下一个</span></span><br><span class="line">		<span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) {</span><br><span class="line">			arrays[k++] = leftArray[i++];</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			arrays[k++] = rightArray[j++];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; lengthLeft) {</span><br><span class="line">		arrays[k++] = leftArray[i++];</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt; lengthRight) {</span><br><span class="line">		arrays[k++] = rightArray[j++];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arrays</span></span><br><span class="line"><span class="comment"> * @param L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * @param R      指向数组最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arrays[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果只有一个元素，那就不用排序了</span></span><br><span class="line">	<span class="keyword">if</span> (L == R) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取中间的数，进行拆分</span></span><br><span class="line">		<span class="keyword">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">		mergeSort(arrays, L, M);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">		mergeSort(arrays, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//合并</span></span><br><span class="line">		merge(arrays, L, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">	mergeSort(a,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">	{   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">	}   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://juejin.im/post/5ab4c7566fb9a028cb2d9126">归并排序就这么简单</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2019/02/13/shell-sort/</url>
    <content><![CDATA[<p>希尔排序，实质是分组插入排序。  </p>
<span id="more"></span>


<p>代码有点难懂，需要手动演算才更好理解。  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; a[j + gap]; j -= gap)</span><br><span class="line">                        {</span><br><span class="line">                                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                                a[j] = a[j+gap];</span><br><span class="line">                                a[j+gap] = temp;</span><br><span class="line">                        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">        sort(a,length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://www.itcodemonkey.com/article/3286.html">图解希尔排序</a>  </li>
<li><a href="https://blog.csdn.net/MoreWindows/article/details/6668714">白话经典算法系列之三 希尔排序的实现</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Panel的几个概念</title>
    <url>/2019/02/12/panel/</url>
    <content><![CDATA[<p>Panel的几个概念。  </p>
<span id="more"></span>


<h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><ul>
<li><p>FRC(free run)  </p>
<ul>
<li>特性：Display输出frame rate不需跟input video frame rate同步。  </li>
<li>应用：Input video frame rate太低或太高，panel无法支援frame rate，panel在某些应用下需强制输出固定frame rate给TCON。  </li>
</ul>
</li>
<li><p>Frame Sync<br>什么是Frame Sync？<br>狭义的说：让Output V sync freq与Input V sync freq相同。<br>例如：Input V Freq 60Hz，Output V Freq也等于60Hz。<br>广义的说：让Output V sync freq与Input V sync freq保持一定比例关系。<br>例如：Input V Freq 60Hz，Output V Freq等于120Hz。  </p>
</li>
</ul>
<p>为保证输入和输出的场频相同就要满足DCLK/(Htotal×Vtotal) = 采样时钟频率/(输入Htotal×输入Vtotal)，为满足这一公式，DCLK、Htotal、Vtotal会在屏可接收的范围内进行调整。不同的芯片会采用不同的LOCK方法，因此计算方法会不同，只有去看程序才能明白是怎么计算的。</p>
<pre><code>- 特性：output frame rate刚好是input frame rate的1倍或2倍。例如：Input V Freq 60Hz,Output V Freq也等于60Hz；Input V Freq 60Hz，Output V Freq等于120Hz。  
- 应用：确保输出画面跟输入信号一样流畅。  
- 控制：确保display不会有掉frame或是出现不规律的frame repeat现象。  
</code></pre>
<ul>
<li><p>Frame PLL Mode  </p>
<ul>
<li>运作方式：固定住Output H total and V total, 然后IC会自动调整(微调)Output clock來使得Output V Freq接近Input V Freq。  </li>
<li>优点：固定Vtt、Htt，不会有short frame/line的问题；可以做FRC。  </li>
<li>缺点：需要较长的时间来完成frame sync；会受到clock范围的限制。  </li>
</ul>
</li>
<li><p>Frame Lock  </p>
<ul>
<li>frame lock是固定Dclk，当input reference信号来时，将Output 的timing generator reset掉，借由这个动作到达input和output一张frame的时间一样长。  </li>
<li>优点：frame sync速度快，一张frame就sync住。  </li>
<li>缺点：因为是用input的reference信号（可预期不可control）来clear timing generator，在reset时有可能不是一张完整的frame或者line，会有short frame和short line的情况，因此：<br>  1，有些panel没办法接收这种timing，画面会闪；<br>  2，当reset点不是在Blanking区间，换timing， OSD会破掉；<br>  3，因为是每一张frame都reset，所以没办法做FRC。  </li>
</ul>
</li>
</ul>
<p><a href="https://www.doc88.com/p-6911746171453.html">FrameLock(FrameSync)</a>  </p>
<h2 id="Frame-Sync"><a href="#Frame-Sync" class="headerlink" title="Frame Sync"></a>Frame Sync</h2><p>目前常用的Frame Sync有以下两种方式：Frame PLL Mode、Frame Lock。  </p>
<h2 id="RDA-Frame-Sync-方法"><a href="#RDA-Frame-Sync-方法" class="headerlink" title="RDA Frame Sync 方法"></a>RDA Frame Sync 方法</h2><p><img src="https://i.loli.net/2019/02/12/5c6293a433a9d.jpg" alt="rda calc frame sync.jpg">  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>同一版软件在V320BJ6_Q01这款屏上测试正常，在V320BJ8_Q01这款屏上测试任意信号都有随机抖动的问题。两款屏的Timing Spec一样。调试思路是调整输出Clock值。尝试微调Vtotal无法改善，放弃，然后尝试关展频，测试5台机器2小时再也没有抖动的问题，但是另外一个抖动频率较高的机器仍发现有抖动情况，读寄存器发现在60Hz信号下吃的却是50Hz的Vtotal，于是修改屏参强制60Hz输出，测试未见异常。由于客户不做EMI，所以此题改法是关闭展频，至于60Hz信号为什么会吃50Hz值，暂时没有结论。  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://wenku.baidu.com/view/61565e78e009581b6bd9eba1.html">FPLL实际应用介绍</a>  </li>
<li><a href="https://blog.csdn.net/jxgz_leo/article/details/52225462">用于降低EMI的时钟展频技术</a>  </li>
<li><a href="https://www.onsemi.cn/pub/Collateral/AND9015-D.PDF">ON Semiconductor</a>  </li>
<li><a href="https://www.cypress.com/file/106246/download">Cypress Semiconductor</a>  </li>
<li><a href="https://blog.csdn.net/cswuhsdaz/article/details/91471437">分辨率的Clock和屏的Clock</a></li>
</ol>
<hr>
<h2 id="色彩分辨率"><a href="#色彩分辨率" class="headerlink" title="色彩分辨率"></a>色彩分辨率</h2><p>色彩分辨装是指显示屏能显示的颜色深度，一般以位数来描述，如：10Bit、8Bit、6Bit。而规格书有时也会以可显示的颜色数量来描述，如16.7M。颜色数量和位数的关系是：颜色数量=2<sup>bits</sup>*2<sup>bits</sup>*2<sup>bits</sup>。以8Bit的显示屏为例，可显示的颜色数量为Display Colors=2<sup>8</sup>*2<sup>8</sup>*2<sup>8</sup>=16777216(16.7M)。颜色位数的设定会影响显示屏对画面细节部分的显示.设定不当时会出现画面细节模糊或屏幕亮度变低。  </p>
<h2 id="LVDS数据格式"><a href="#LVDS数据格式" class="headerlink" title="LVDS数据格式"></a>LVDS数据格式</h2><p>两种LVDS数据格式：JEIDA和VESA。具体使用哪种格式是由屏的SELLVDS这个脚决定的。<br><img src="https://i.loli.net/2019/12/26/PI2hvFEfDxVOC6k.jpg" alt="SELLVDS.jpg">  </p>
<h2 id="Timing参数"><a href="#Timing参数" class="headerlink" title="Timing参数"></a>Timing参数</h2><p>需要关注的参数：DCLK、行场Total、行场Blank，电视机工作时，DCLK是根据信号的频率而变化的，DCLK = HTotal x VTotal x 信号频率。<br>有的Panel会详细细分60Hz和50Hz，一般Dclk = HTotal*VTotal*60，所以当只给出了60Hz的VTotal时，可以算出50Hz的VTotal=1.2*60Hz的VTotal。<br><img src="https://i.loli.net/2019/12/26/9QufyMh3Xltq1p4.jpg" alt="Timing.jpg"><br><img src="https://i.loli.net/2019/12/26/O8qiB9NjzYokQXA.jpg" alt="Timing组成.jpg"><br>Total = Display + Blank;<br>Blank = Sync + 后肩 + 前肩;<br><img src="https://i.loli.net/2019/12/27/gi5IajhkrPCyZfV.jpg" alt="aframe.jpg"><br><a href="https://www.cnblogs.com/sky-heaven/p/9040817.html">LCD时序中设计到的VSPW/VBPD/VFPD/HSPW/HBPD/HFPD总结【转】</a>  </p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><p>时序需要参考屏规格书具体调整。一般来说：<br>开机顺序：先开Panel，再开LVDS，最后开Backlight；<br>关机顺序：先关Backlight，再关LVDS，最后关Panel。  </p>
<h2 id="LVDS驱动电流"><a href="#LVDS驱动电流" class="headerlink" title="LVDS驱动电流"></a>LVDS驱动电流</h2><p>因LVDS接口实际是差分信号接口,调整差分信号的电流会影响LVDS信号输出的幅度。不同的屏因为匹配阻抗略有差异，同样的驱动电流，LVDS输出的幅度也不一样。当LVDS的输出幅度过大或过小时，画面会出现黑屏等现象。<br><img src="https://i.loli.net/2019/12/26/Et3ucUeBDQ8sPyW.jpg" alt="LVDS Interface.jpg"><br><img src="https://i.loli.net/2019/12/26/8SeMj2lmYTq4sax.jpg" alt="LVDS Input Characteristics.jpg"><br><a href="https://blog.csdn.net/github_33678609/article/details/53435286">LVDS协议及原理分析</a>  </p>
<h2 id="眼图"><a href="#眼图" class="headerlink" title="眼图"></a>眼图</h2><p>眼图：一系列数字信号叠加在一起而形成的，因为数字信号有高低电平的变化。  </p>
<p><code>眼高</code>越高，这个信号越好，两条红色横线是VIH与VIL。左边、右边箭头是信号01转换的时刻，这两个箭头越宽，说明越接近原信号的建立时间，保持时间。这两个箭头越小，说明信号不完整，产生反射、干扰等。<br>数字信号在采样前后，需要一定的建立时间和保持时间，数字信号在这一段时间内应保持稳定，才能保证正确采样。而对于电平的判决，需要高电平的电压值高于输入高电平VIH，低电平的电压值低于输入低电平VIL。  </p>
<p><code>眼宽</code>：当信号很多叠加在一起时，这个眼宽就很好地反映了这个信号的稳定时间。  </p>
<h2 id="常见问题及解法思路"><a href="#常见问题及解法思路" class="headerlink" title="常见问题及解法思路"></a>常见问题及解法思路</h2><h4 id="画面闪线或抖动"><a href="#画面闪线或抖动" class="headerlink" title="画面闪线或抖动"></a>画面闪线或抖动</h4><p>屏画面闪亮线一般会出现在电视开机过程中或TV 转台瞬间，原因有多种，最常见的是DCLK设定超出屏可支持的范围。另外一个原因是DCLK 锁定的速度太快，以致屏接受不了这种改变而出现亮线。  </p>
<h4 id="画面水印严重"><a href="#画面水印严重" class="headerlink" title="画面水印严重"></a>画面水印严重</h4><p>画面水印多数是因为屏对图像数据颜色深度处理不足，以致非常相近颜色都被认是同一种颜色，在画面上出现色块，在过渡色画面较容易出现。对于水印的处理，除了屏供应商修改T-con软件外，机芯软件一般可通过调整Gamma曲线的顶端来降低水印。具体的做法是把Gamma的最大值减少。除了屏本身的原因外，软件PQ的设定有时也会产生水印，例如调整画质时把个别颜色的增益设定过大，再经过白平衡调整，处理后的颜色已提前进入饱和，从而出现水印。  </p>
<h4 id="移动画面及水平移动字幕出现停顿"><a href="#移动画面及水平移动字幕出现停顿" class="headerlink" title="移动画面及水平移动字幕出现停顿"></a>移动画面及水平移动字幕出现停顿</h4><p>移动画面不流畅在排除了画面本身的问题外，DCLK与信号未实现同步是主要原因。如V-Total、H-Total参数设定不正确，使得DCLK超出了同步范围。  </p>
<h4 id="屏工作一段时间后出现黑屏"><a href="#屏工作一段时间后出现黑屏" class="headerlink" title="屏工作一段时间后出现黑屏"></a>屏工作一段时间后出现黑屏</h4><p>一种情况表现为电视有声音无图像，背光也不亮。问题的原因之一是背光PWM占空比最小值设定过小，从而使背光模块进入保护状态。还有一个原因就是前面提到个别屏的Dimming信号在屏背光启动时需要保持100%占空比一段时间来激发背光灯管，如果背光启动时，Dimming信号的占空比是用户设定值，而且占空比较小，背光灯管就有可能不能正常启动。另一种情况是有声音无图像但背光是亮的。这种情况的原因之一是展频设置不当，个别屏的展频幅度超过2%时就会出现黑屏现象，所以软件设置的展频幅度一般在1.4%~2%之间。  </p>
<h4 id="背光不受控"><a href="#背光不受控" class="headerlink" title="背光不受控"></a>背光不受控</h4><p>该问题的表现为调整背光时屏幕亮度变化很少或不变化，排除硬件原因，最可能的原因是PWM频率设置不正确。如，屏的PWM频率范围是140~160Hz，如果设定的PWM频率在这个范围外，那就有可能出现这样的问题。  </p>
<h4 id="屏幕有滚动细横纹"><a href="#屏幕有滚动细横纹" class="headerlink" title="屏幕有滚动细横纹"></a>屏幕有滚动细横纹</h4><p>这种现象在纯颜色的画面下较容易观察到。而引起该问题的原因多数是展频的频率设置不正确，可以调整展频的频率看现象是否有改善。如果调整展频的频率没有改善，可以关掉展频功能来进一步确认。  </p>
<h4 id="画面闪彩点"><a href="#画面闪彩点" class="headerlink" title="画面闪彩点"></a>画面闪彩点</h4><p>该问题表现为图像及UI都会闪点，引起该问题的原因多数是LVDS信号的眼图不良。  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>panel</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/02/08/insertion-sort/</url>
    <content><![CDATA[<p>如何去理解插入排序？我的方法是：已知选择排序的思路是选出特定元素去组成新的序列，对于插入排序而言，是要把元素插入到有序序列。  </p>
<span id="more"></span>


<p>代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="comment">//直接插入排序，产生从小到大的序列</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">        {   </span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>]) <span class="comment">//这个条件是要判断当前元素是否要插入到有序序列</span></span><br><span class="line">                {   </span><br><span class="line">                        t = a[i]; <span class="comment">//把要插入的值先保存出来</span></span><br><span class="line">                        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;t;j--)</span><br><span class="line">                        {   </span><br><span class="line">                                a[j+<span class="number">1</span>] = a[j]; <span class="comment">//把元素往后挪，直到找到要插入的位置</span></span><br><span class="line">                        }   </span><br><span class="line">                        a[j+<span class="number">1</span>] = t; <span class="comment">//终于找到要插入的位置了，赋值</span></span><br><span class="line">                }   </span><br><span class="line">        }   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">        sort(a,length);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {   </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">        }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以上为直接插入排序，如果数据量比较大，尝试用二分插入排序，可以减小比较次数。因为相对于直接插入排序，一边比较一边找插入位置而言，二分插入排序的做法是先通过比较找到要插入的位置，然后挪元素，这里二分法找位置会较快。<br>二分插入排序，代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">        <span class="comment">//二分插入排序                    </span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">                {</span><br><span class="line">                        t = a[i];</span><br><span class="line">                        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> right = i<span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">                        {</span><br><span class="line">                                <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                                <span class="keyword">if</span>(t&lt;a[mid])</span><br><span class="line">                                {</span><br><span class="line">                                        right = mid<span class="number">-1</span>;</span><br><span class="line">                                }</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                {</span><br><span class="line">                                        left = mid+<span class="number">1</span>;</span><br><span class="line">                                }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=left;j--)</span><br><span class="line">                        {</span><br><span class="line">                                a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">                        }</span><br><span class="line">                        a[left] = t;</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">}   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">        <span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">        sort(a,length);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>如何克服自我怀疑？</title>
    <url>/2019/01/31/null/</url>
    <content><![CDATA[<p>容易自我怀疑，如何克服？网友的回答。  </p>
<span id="more"></span>

<h4 id="来自bgwzh的回答"><a href="#来自bgwzh的回答" class="headerlink" title="来自bgwzh的回答"></a>来自bgwzh的回答</h4><p>克服是不可能克服的，这辈子都不行。虽然克服不了，但你可以选择修正。  </p>
<p>修正的话你就要搞清楚为什么你会自我怀疑。其实说白了很简单，就是你心智参数配置问题。  </p>
<p>因为你过去的经验，所以你给自己设定了一个“无能者”或“失败者”的称号。所以每次做事，你看看自己的这个称号，你就会开始自我怀疑。因此，解决办法就是移除这个称号，让你对自己有一个正确的认识。  </p>
<p>具体方法是，回忆过去所有失败的经验，然后去思考自己为什么失败。那是你能力欠缺还是外界因素。有些领导喜欢说不要找借口。虽然有些确实是借口，但有些确是理由。比如让你一天之内开发出一个完善的系统。你能做到吗？做不到，你的理由就不是借口。你需要衡量自己的能力，只有你自己知道你到底是不是在找借口。因此对自己诚实很重要。如果你总是自欺，你就会慢慢变得越难觉察自己真实的情况。  </p>
<p>当你得出结论之后，不要去强化并再度认可自己的称号。不要用几个事件就决定拥有无限可能的自己。你是什么样的不能从你做过的事上得出结论，那只能得出，你选择成为了那个样，这个结论。你可以选择失败，同样可以选择成功。只要吸取并利用好过去的经验。  </p>
<p>我不清楚你的具体情况，你也可能没有失败的经验，且几乎每一次都会成功，但你每次还是会自我怀疑。如果你是这种情况，那就是你童年时给自己设定了错误的认知所致。认知的设定可能源于你家人对你的评判，你接受了，并把这评价设置为自己的标签，于是你就会在每次做事时都会感受到自我怀疑。  </p>
<p>如果你是这种情况，那你就需要把注意力放在你成功的案例上。同样的，去思考你成功的原因，只要你能得出这个成功你能力大于巧合这个结论，那你就完成了。你不是一个“不行”的男人，你很可以，只是你觉得自己不行罢了。你现在已不同往日，你已经长大了，没必要再用童年时的自我标签了。你可以抛开过去，为自己重新做诠释。  </p>
<p>@gabon 这位兄弟说他会有焦虑。其实焦虑的本质是恐惧，你恐惧自己不行，也恐惧失败。如何修正对自己的认识上面说了，现在说下如何修正对失败的恐惧。  </p>
<p>恐惧失败只有两个原因，一是恐惧失败后自己的形象受损，一是恐惧失败后自己的身体受损。因此，你只需要理解人都会犯错，并支持这个认知，你就可以免于害怕自己形象的受损。你无需做一个完美无缺之人。你也做不到。  </p>
<p>至于身体受损的担心就更好说了，你只要反问自己，失败了，你会死吗？你不会死，也没那么容易死。你喜欢考虑很多，给自己未来以保障。然而生命无常，计划永远赶不上变化。你给自己设想的保障，说不定明天就会被公司裁员所打破。要适当的享受冒险，你才能活的安心。  </p>
<p><strong>一定要把车到山前必有路与天无绝人之路奉为你的座右铭，你才能安住于当下，不念过去，不惧未来。只有现在是真实的，未来的情况你无法预测，也无需预测。只要在当下把事情做好就行了，未来自会以它该是的样子而来。你只需要接受即可。人不是来这无常的世界体验永恒与安定的，而是来这体验变化与精彩的。按这个思想来对待生活吧，你必会体验到生命的美好。</strong>  </p>
<p>以上。  </p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>ego</tag>
        <tag>life</tag>
        <tag>live</tag>
      </tags>
  </entry>
  <entry>
    <title>Android延迟执行的三种方式</title>
    <url>/2019/01/18/android-delay/</url>
    <content><![CDATA[<p>Android延迟执行的三种方式</p>
<span id="more"></span>

<ul>
<li><p>线程  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>); <span class="comment">// 休眠1秒</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 延时执行的代码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	}</span><br><span class="line">}).start();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>延时器</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">timer.schedule(<span class="keyword">new</span> TimerTask() {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 延时执行的代码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	}</span><br><span class="line">},<span class="number">1000</span>); <span class="comment">// 延时1秒</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Android消息处理</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 延时执行的代码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	}</span><br><span class="line">},<span class="number">1000</span>); <span class="comment">// 延时1秒</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2019/01/16/selection-sort/</url>
    <content><![CDATA[<p>选择排序，字面意思就是依次选出最大/小值、次最大/小值、次次最大/小值、次次次最大/小值……  </p>
<span id="more"></span>

<p>直接贴代码：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> * a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    {</span><br><span class="line">	min = i;</span><br><span class="line">	<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;length;j++)</span><br><span class="line">	{</span><br><span class="line">	    <span class="keyword">if</span>(a[j]&lt;a[min])</span><br><span class="line">	    {</span><br><span class="line">		min = j;</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(min!=i)</span><br><span class="line">	{</span><br><span class="line">	    temp = a[i];</span><br><span class="line">	    a[i] = a[min];</span><br><span class="line">	    a[min] = temp;</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">    selection_sort(a,length);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>优化思路是可以在一个循环里面不仅仅是选取最大/小值，而是同时把最大值和最小值取出来。优化代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(left=<span class="number">0</span>,right=length<span class="number">-1</span>;left&lt;right;left++,right--)</span><br><span class="line">    {</span><br><span class="line">	min = left;</span><br><span class="line">	max = right;</span><br><span class="line">	<span class="keyword">for</span>(i=left;i&lt;=right;i++)</span><br><span class="line">	{</span><br><span class="line">	    <span class="keyword">if</span>(a[min]&gt;a[i])</span><br><span class="line">		min = i;</span><br><span class="line">	    <span class="keyword">if</span>(a[max]&lt;a[i])</span><br><span class="line">		max = i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(min!=left)</span><br><span class="line">	{</span><br><span class="line">	    temp = a[left];</span><br><span class="line">	    a[left] = a[min];</span><br><span class="line">	    a[min] = temp;</span><br><span class="line">	    <span class="keyword">if</span>(max==left)  <span class="comment">//why</span></span><br><span class="line">		max = min; <span class="comment">//why</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(max!=right)</span><br><span class="line">	{</span><br><span class="line">	    temp = a[right];</span><br><span class="line">	    a[right] = a[max];</span><br><span class="line">	    a[max] = temp;</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">    selection_sort(a,length);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一开始想不通交换min值的时候为什么要重新获取max值，画个图就一目了然了。 </p>
<blockquote>
<p>if(max==left)<br>  max = min;  </p>
</blockquote>
<p><img src="https://i.loli.net/2019/01/17/5c3fe03bb93a5.jpg" alt="selectionSort"><br>因为i是由left坐标遍历到right坐标，所以最大值有可能落在left的坐标上，当最大值落在left坐标时，交换最小值的时候， a[left]与a[min]交换了，原本最大值是a[left]在left位置，交换最小值后转移到min位置，即此刻最大值的坐标落在min的位置，而不是原来left的位置。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>PAL M 识别成 NTSC M</title>
    <url>/2019/01/14/PALM/</url>
    <content><![CDATA[<p>搜台后 PAL/M 为什么会识别成 NTSC/M ？  </p>
<span id="more"></span>

<p>客户提出一个疑问：自动搜台 PAL/M 为什么会识别成 NTSC/M ？<br>事实上，跟搜台方式无关，无论自动还是手动搜台，结果都一样，在AV通道同样。<br>做如下实验：<br>54200设定 PAL M chroma = off，ATV图像无颜色，屏显是 NTSC M<br>54200设定 PAL M chroma != off，ATV图像有颜色，屏显是 PAL M<br>54200设定 NTSC M chroma = off，ATV图像无颜色，屏显是 NTSC M<br>54200设定 NTSC M chroma != off，ATV图像有颜色，屏显是 NTSC M  </p>
<p>判断制式的做法是先判断扫描线数，PAL/M和NTSC/M都是525行，如果没有色副载波，就默认是NTSC/M了，关闭chroma，就没有了色副载波信号，所以PAL/M会被识别成NTSC/M。</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>palm</tag>
        <tag>ntscm</tag>
        <tag>atv</tag>
      </tags>
  </entry>
  <entry>
    <title>步履不停</title>
    <url>/2019/01/06/tokugawa-ieyasu/</url>
    <content><![CDATA[<p>读完了《德川家康》，摘抄几个句子，状态差的时候看一看。</p>
<span id="more"></span>

<ul>
<li><p>“阿久，你一定要忍耐，这个时代需要的就是忍耐。人们必须克制心中的欲望，懂得忍让。人生在世无不如此，这是命中注定的。”  </p>
</li>
<li><p>“只要你剃了头发，那些以前闭门不见客的人也会以礼佛的名义见你……哈哈，这也是随风的策谋。”  </p>
</li>
<li><p>信长意味深长地微笑了，神态根本不像只有十四岁的少年，“人生之事无不是雅兴，今日也不例外。你这次给我带来了什么？”  </p>
</li>
<li><p>常思此世间，飘零无定处。直叹水中月，浮生若朝露。人生五十年，如梦亦如幻。有生斯有死，壮士何所憾？  </p>
</li>
<li><p>如果只有某一个人能够做到高瞻远瞩，那么政治和战斗将无法展开…..  </p>
</li>
<li><p>“真好，能够活到今天。”  </p>
</li>
<li><p>“掉以轻心了吧！”浪人哈哈大笑，“绝不可轻言主动进攻。但对方发起攻击，就必须漂亮地予以反击。但又需在击退敌人的同时，保证自己的安全。不攻击对方，也不要被对方击中。这才是大将之剑。”  </p>
</li>
<li><p>人要能够打造自己的身体。猥琐的身体只能附着猥琐的灵魂。  </p>
</li>
<li><p>“作为大将，要吃朝霞和彩云，强筋健体；要内心哭泣，脸上微笑”  </p>
</li>
<li><p>“是我违背了忍耐的誓言，我太心急了。”  </p>
</li>
<li><p>“凡事不可慌张。慌张使人目盲。”  </p>
</li>
<li><p>已经来临的人生之冬是人力无法阻止的。  </p>
</li>
<li><p>“不能发怒！”  </p>
</li>
<li><p>再也没有比将人生作为赌注更让人爽快之事了。信长果然如藤吉郎所料地行动。如此一来，藤吉郎就可以发挥自己的智慧，去赢得这场人生的豪赌。他将赌注下在信长这匹烈马身上，而这匹烈马，大概会一直驰骋纵横，直到人生最后一刻。  </p>
</li>
<li><p>此事并非完全出乎意料。只要义元不死，就无法打破当前势力的均衡，那他松平元康就只能继续做骏府的人质。甚至可以说，元康一直在等待义元之死。<br>  元康不经意抬头望着天空，乌云散尽，繁星闪烁，一颗流星忽然坠向南方的海面。如此辽阔的天地，居然没有冈崎人立锥之地–他真切地感受到了命运的残酷，但并未绝望。处境如此险恶，他反而想笑。<br>  望着天空中闪烁的星星，元康不断反省当前他应该抛弃的东西。首先应该抛弃的，是这座孤城。至于妻子和孩子，他已经抛弃了。日夜思念的母亲，他已经见过了，那见面也就可以当做别离。对冈崎城的执著应该抛弃，还有，冥冥中支撑着他奋斗的“运气”–那模糊的幻影，现在也应完全抛开。不，仅仅扔掉这些东西，还无法行动自如。还要抛弃什么呢？元康眼前突然浮现出雪斋禅师的脸。他笑了。最后应该抛弃的，是我自己，唯有完全没有了自己，无限静寂的“无”才能显露出来–雪斋长老留给元康的那个“无”，多年后，终于又回到元康心中。  </p>
</li>
<li><p>但是於大不想诅咒人生的悲惨，她甚至还希望宽恕那一切，希望一切走向光明，并一直为此默默祈祷。她认为，宽恕一切，能够让人逐渐变得坚强和伟大。  </p>
</li>
<li><p>“我从今以后不会性急，却也要一刻不停。”  </p>
</li>
<li><p>永禄十年腊月，家康得到敕许，改姓德川。  </p>
</li>
<li><p>后天的努力能改变人的命运吗？非要改变那些无法改变的东西，到头来只是徒劳；本可以改变的却不努力，就是懈怠。也就是说，既存在因人的后天努力而改变的命运，也确实存在着由命运主宰的人生。令人迷惑的是，人不可逆天而动，但人的所动，都是因为希望逃脱宿命。  </p>
</li>
<li><p>三左卫门出去后，家康长叹一声，禁不住哈哈大笑，但马上自责：尔岂可幸灾乐祸！  </p>
</li>
<li><p>“女人难道就这么害怕独守空房吗，阿浓？”浓夫人没有回答。    </p>
</li>
<li><p>浓姬很清楚，大概是年龄逐长的缘故，从十七八岁就开始咏叹“人生五十年”的丈夫，即使牺牲生命，也要在这个世界建立新秩序，这是他的大悲愿。当她不明白丈夫的心志时，心情是舒畅的；明白以后，她变得痛苦。  </p>
</li>
<li><p>生难死亦难，眼际乌云漫，蓦然回首间，山端明月现。  </p>
</li>
<li><p>对秀吉来说，没有哪一次战役不是他命运的转折点。这只猴子总是拼尽全力做每一件事。  </p>
</li>
<li><p>“太夫，如果说人生只有五十载，我早已足够了。“久政脸上浮现出笑容，”我的一生无怨无悔，始终按照自己的意志行事，不曾失节。“  </p>
</li>
<li><p>“不……柔弱正是你的力量。柔弱而又坚强的人，最易惹人发火。”  </p>
</li>
<li><p>如果只讲策略，不论感情，所为就不合天意，如此一来，随时可能会被自己的策略颠覆。  </p>
</li>
<li><p>自助者，天助之。命运之事，怎能随便试探？命运便是时刻准备着，不断前进，不断忍耐，除此之外，别无他途。  </p>
</li>
<li><p>“面临战斗时，一定要牢牢控制住自己，不要贸然进击，而是要忍耐、等待，等待战机。在这方面，甲州信玄公最有心得。”  </p>
</li>
<li><p>“从今往后，无论什么人，都得学会隐忍，世上再也没有比隐忍更好的盾牌了。你明白吗？并不是什么人都能忍的。能忍人之不能忍者，将来方能成大器。”  </p>
</li>
<li><p>信长势如破竹，扩展着自己的势力。信长越扩张，家康就越内敛，两人之间的差距越来越大，就像走向了阴阳两极。  </p>
</li>
<li><p>人生，生是那么漫长，死却是如此迅速而脆弱。  </p>
</li>
<li><p>秀吉超常的精力，源自他从不把辛劳作为辛劳来看待，在他的胸中，从来就无“辛劳”之辞。他夜以继日，每进一步，都会感到无比的快乐，也感到莫大的欣慰。这种“辛劳之乐”非但不会令人疲劳，只会磨炼人的意志，鼓舞人的精神。从这个意义上来说，秀吉仿佛一名无我之人，而他的喜悦便如登高回望之情。在四十七载沉浮中，他深深地体味到了这种“辛劳之乐”的功效，一直将其奉为座右铭。  </p>
</li>
<li><p>可能每个人的一生都是无家可归的，只不过是进行着一次遥远的旅程罢了。  </p>
</li>
<li><p>“随风无敌人，因为他总是以心换心。”  </p>
</li>
<li><p>“我曾受雪斋禅师严训。禅师说，碰到困难时，要心中无物，这样，道理便会显现，便能心领神会了。‘无’便可通神明之心。”  </p>
</li>
<li><p>战事中，遇到阻碍，比战败更能体现大将性情。进退有方，才是大将之材，一般人却难以做到。  </p>
</li>
<li><p>木食上人默默待在一旁。从聚乐第到伏见，再从伏见到高野山，对于关白秀次，这短短的旅程，竟是他的省悟之旅，甚至远胜他二十八年的苦恼人生。律己恕人，多么重大的发现，对人宽容，便畅通无阻；反之，人生就会陷入无尽的黑暗。“我佛宗旨便是如此。对自己严格要求，对他人宽宏大量……只有这样，人生才会丰富多彩；不懂得这些，生活便贫乏寡淡。如今，大人的人生即将变得丰富。”“上人，我想在这里向大政所谢罪。”“贫僧以为，此乃善事。”  </p>
</li>
<li><p>世上并非事事都能如人所愿，这并非人的过错。  </p>
</li>
<li><p>难道家康历尽千辛万苦，隐忍了五十余年，也会像松永久秀和明智光秀那样徒劳一生？  </p>
</li>
<li><p>人无论心胸有多宽广，却还有解不开的结。  </p>
</li>
<li><p>这果真是一场欣求净土的战事吗？每当出战，家康总是扪心自问，这已成了他勇气的源泉。  </p>
</li>
<li><p>十九岁时就已立起的旗帜，他花甲之年依然不倒。不同的是，当初立下这面旗帜时，身边只有十几个人，而今他拥有万千威武之师。  </p>
</li>
<li><p>家康终生隐忍，绝不冒进，始终稳坐钓鱼台，静观天下势。但不动则已，动必中的。  </p>
</li>
<li><p>“大将悲哀时不能哭，在苦累时要忍耐，有好吃的东西时要分给家臣。怎样，五郎太丸，你能成为大将吗？”  </p>
</li>
<li><p>命数不会眷顾一个无所事事之人，特意为他开辟一条出人头地的道路。  </p>
</li>
<li><p>去岁新年，胜重曾问家康，身为所司代，为政应注意什么。家康道：“人一生如负重致远，不可急躁。以不自在为寻常事，则不觉不足。心生欲望时，当思先前困窘之日。”言毕，家康又微笑道：”忍耐乃长久根本，愤怒是人生大敌。只知胜而不知败，自害其身。常思己过，勿怪人非。凡事过犹不及。“  </p>
</li>
<li><p>如今，家康终于等到了嫡孙出生。这个孩儿的祖父是征夷大将军，拥有着无上的权力。然而家康再怎么得意，也不至于忘形，因今日一切都是他艰苦奋斗所得。  </p>
</li>
<li><p>用人时，不能让人心慰，人定不会尽全力。  </p>
</li>
<li><p>家康看到事情于天下不利时，自会放弃无谓的忍耐，但表面上却会不动声色。正因如此，不管高台院在道歉时，家康装得多么若无其事，他也不会因此而改变主意。  </p>
</li>
<li><p>”意外之风带来的凉意，很容易让人昏昏欲睡。”  </p>
</li>
<li><p>“真正的大将既能坐于漏船，亦能够卧于火屋。”  </p>
</li>
<li><p>事不宜迟，正月里可借“拜年”之名，做许多大事。  </p>
</li>
<li><p>秀忠果然严格按照义理约束自己。  </p>
</li>
<li><p>满座人鸦雀无声。众人都感到，许久不见的、只有作战议事时才有的杀气，又从家康身上散发出来。  </p>
</li>
<li><p>“人有病，天知否？”  </p>
</li>
<li><p>“万物皆有源，如花果皆有种子。”  </p>
</li>
<li><p>许久，宗矩才明白，家康公的眼睛清澈如水，许可看到冥界。  </p>
</li>
<li><p>“兵法与为人之道本是一途。”  </p>
</li>
<li><p>盛世大和花竞放，千秋万代颂春风。  </p>
</li>
<li><p>“憎人之心不可有，律己之心不可无。”  </p>
</li>
<li><p>家康其颜如佛，祥和安宁。他被病痛折磨了这么久，鼻梁却似比平日更是挺拔。所谓往生，当是这般模样。  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2019/01/04/bubble-sort/</url>
    <content><![CDATA[<p>冒泡排序，思路是相邻两个的两两比较。  </p>
<span id="more"></span>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>C  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">               <span class="keyword">int</span> temp = a[j];</span><br><span class="line">               a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">               a[j<span class="number">-1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    sort(a,length);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>{</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = length -<span class="number">1</span>; j &gt; i; j--) {</span><br><span class="line">				<span class="keyword">if</span>(a[j] &lt; a[j-<span class="number">1</span>]) {</span><br><span class="line">					<span class="keyword">int</span> temp = a[j];</span><br><span class="line">					a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">					a[j-<span class="number">1</span>] = temp;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">		BubbleSort bs = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">		bs.sort(a,a.length);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i:a) {</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>添加打印信息，修改代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">               <span class="keyword">int</span> temp = a[j];</span><br><span class="line">               a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">               a[j<span class="number">-1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">		<span class="keyword">for</span>(s = <span class="number">0</span>; s &lt; length; s++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[s]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    sort(a,length);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译运行，得到有如下打印信息：  </p>
<blockquote>
<p>1 4 5 2 7 3 6<br>1 2 4 5 3 7 6<br>1 2 3 4 5 6 7<br>1 2 3 4 5 6 7<br>1 2 3 4 5 6 7<br>1 2 3 4 5 6 7<br>1 2 3 4 5 6 7  </p>
</blockquote>
<p>发现从第3行开始便是多余的动作，如何优化呢？当再没有两两交换发生时，退出便是，这里优化的外层的循环。修改代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		flag = <span class="number">0</span>; <span class="comment">//优化</span></span><br><span class="line">		<span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">				a[j<span class="number">-1</span>] = temp;</span><br><span class="line">				flag = <span class="number">1</span>; <span class="comment">//优化</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="comment">//优化</span></span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">//优化</span></span><br><span class="line">		<span class="keyword">for</span>(s = <span class="number">0</span>; s &lt; length; s++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[s]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	sort(a,length);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>是否有机会优化内层循环？对于一组数据，可能有一部分数据是有序的，此时记录最后一次发生交换的位置，下次比较就从开始比较到刚才记录的位置，可减少多余的比较，因为此位置后面的数据是有序的，后面就不需要比较这些内容。<br>修改代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; k; j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">				a[j<span class="number">-1</span>] = temp;</span><br><span class="line">				pos = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		k = pos;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	sort(a,length);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>完整c代码：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; k; j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">				a[j<span class="number">-1</span>] = temp;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				pos = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		k = pos;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	sort(a,length);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/hansionz/article/details/80822494">【排序】：冒泡排序以及三种优化</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>几个C语言知识点</title>
    <url>/2018/12/27/c/</url>
    <content><![CDATA[<p>重新整理以前的笔记，基本来自《C语言深度解剖》。  </p>
<span id="more"></span>

<h1 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码/反码/补码"></a>原码/反码/补码</h1><p>原码：原码就是这个数本身的二进制形式，其中最高位为符号位。<br>补码：在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。<br>反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。  </p>
<p>求补码的方法：整数或零，则补码等于原码，负数则补码等于除符号位外，各位取反加一<br>求反码的方法：正数，反码与原码相同，负数，对其原码逐位取反，但符号位除外，符号位还是一  </p>
<p>在计算机系统中，数值一律用补码来表示。 </p>
<p>问题1：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">{</span><br><span class="line">	a[i] = <span class="number">-1</span>-i;</span><br><span class="line">}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">strlen</span>(a)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><span style="color:red"> 以上代码输出为255 </span>  </p>
<p>问题2：<br>char a = -300，求 int a<br>300的原码：1 0010 1100<br>取反：1101 0011<br>加一：1101 0100<br>300的补码：1101 0100<br>符号位：1<br>求原码：101 0100<br>取反：010 1011<br>加一：010 1100<br>求得：-44  </p>
<p>问题3：<br>int i = -20;<br>unsigned j = 10;<br>i+j的值为多少？为什么？  </p>
<p>问题4：<br>下面的代码有什么问题？  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%u\n"</span>,i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>基本类型 - 数值类型、字符类型</li>
<li>构造类型 - 数组、结构体、共用体、枚举类型</li>
<li>指针类型</li>
<li>空类型</li>
</ul>
<p>常用数据类型在32位和64位CPU上的字节数比较：<br>测试程序：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"char[%d], char*[%d], short int[%d], int[%d], unsigned int[%d], float[%d], double[%d], long[%d], long long[%d], unsigned long[%d]\n"</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="keyword">sizeof</span>(<span class="keyword">char</span> *),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>),<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">float</span>),<span class="keyword">sizeof</span>(<span class="keyword">double</span>),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">long</span>),<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>),<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>不同CPU类型的输出结果：<br>x86_64:  </p>
<blockquote>
<p>char[1], char*[8], short int[2], int[4], unsigned int[4], float[4], double[8], long[8], long long[8], unsigned long[8]  </p>
</blockquote>
<p>i686:  </p>
<blockquote>
<p>char[1], char*[4], short int[2], int[4], unsigned int[4], float[4], double[8], long[4], long long[8], unsigned long[4]  </p>
</blockquote>
<p>总结：很明显的比较结果，指针和长整形由4个字节升为8个字节  </p>
<h1 id="32个关键字"><a href="#32个关键字" class="headerlink" title="32个关键字"></a>32个关键字</h1><p>举例：<br>register - 声明寄存器变量<br>const - 声明只读变量<br>volatile - 说明变量在程序执行中可被隐含地改变。这个关键字声明的变量，编译器对访问该变&gt;量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。  </p>
<p>分析：<br>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。(对Java来说：Java内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。)</p>
<p>下面是volatile变量的几个例子：  </p>
<ol>
<li>并行设备的硬件寄存器（如：状态寄存器）  </li>
<li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)  </li>
<li>多线程应用中被几个任务共享的变量  </li>
</ol>
<p>  回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。 假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。  </p>
<p>有如下3个问题：  </p>
<ol>
<li>一个参数既可以是const还可以是volatile吗？解释为什么。  </li>
<li>一个指针可以是volatile 吗？解释为什么。  </li>
<li>下面的函数有什么错误：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>下面是答案： </p>
<ol>
<li>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。  </li>
<li>是的。尽管这并不很常见。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。  </li>
<li>这段代码的有个恶作剧。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">int</span> a,b; a = *ptr; </span><br><span class="line">    b = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * b; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">int</span> a; a = *ptr; </span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>extern: 说明变量是在其他文件中声明（也可以看作是引用变量）<br>sizeof: 计算对象所占内存空间大小  </p>
<p>函数参数的声明举例：void func(int i,char c)<br>定义声明最重要的区别：定义创建了对象，并为这个对象分配了内存，声明没有分配内存  </p>
<p>编译器在默认的缺省情况下，所有变量都是auto的。  </p>
<p>register变量必须是能被CPU寄存器所接受的类型。意味着register变量必须是一个单个的值，并且其长度应小于或等于整形的长度。而且register变量可能不存在内存中，所以不能用取址运算符“&amp;”来获取register变量的地址。比如说，32位的CPU，最多是4个字节，整形和长整形都是占4个字节的数据类型。<br>注意：register变量只是对编译器的建议，编译器并不一定会将该变量作为register变量。  </p>
<h1 id="static关键字作用"><a href="#static关键字作用" class="headerlink" title="static关键字作用"></a>static关键字作用</h1><ol>
<li><p><strong>修饰变量</strong><br> 静态区是分配静态变量、全局变量空间的；初始化的全局变量放在数据段；局部变量放在栈；未初始化的全局变量放在bss段。<br> 从C程序运行的角度看，内存几大部分：静态存储区、堆区和栈区。<br> 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存在静态数据、全局数据和常量。<br> 全局区（静态区）（static） —- 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。  </p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;			<span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;			<span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> b;			<span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"abc"</span>;		<span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2;			<span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;	<span class="comment">//123456\0在常量区，p3在栈上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;		<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);	<span class="comment">//堆</span></span><br><span class="line">    p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);	<span class="comment">//堆</span></span><br><span class="line">    p1 = <span class="string">"123456"</span>;		<span class="comment">//123456\0在常量区，编译器将p1与p3所指向的“123456\0”优化成同一个地方</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 全局变量、局部变量、静态全局变量、静态局部变量的区别，如下：  </p>
<ul>
<li>从作用域看  </li>
</ul>
<ol>
<li>全局变量具有全局域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。  </li>
<li>静态局部变量具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在。它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。  </li>
<li>局部变量也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。  </li>
<li>静态全局变量（其他文件即使使用extern声明也没法使用它）也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同的静态全局变量，它们也是不同的变量。  </li>
</ol>
<ul>
<li>从分配内存空间看<br>全局变量、静态全局变量、静态局部变量都在静态存储区分配空间，而局部变量在栈分配空间。  </li>
</ul>
<p> 把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生命周期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围，因此static这个说明符在不同的地方起的作用是不同的。  </p>
<p> 注意：<br> 对于静态局部变量的理解：  </p>
<ol>
<li>若全局变量仅在单个函数中使用，则可以将这个变量修改为改函数的静态局部变量  </li>
<li>由于被static修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值<br>直观的例子：<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k,ii = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    ii++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ii = %d\n"</span>,ii);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    j++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"j = %d\n"</span>,j);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">    {</span><br><span class="line">	func1();</span><br><span class="line">	func2();</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
<ol start="2">
<li><strong>修饰函数</strong><br>函数前加static使得函数成为静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件（所以又称为内部函数）。</li>
</ol>
<ol start="3">
<li><p><strong>C++里对static赋予了第三个作用（如果成员声明为static，可以在外部直接访问）</strong>  </p>
<ol>
<li>静态数据成员  </li>
</ol>
</li>
</ol>
<ul>
<li>静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一个内存，供所有对象共用  </li>
<li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义  <ol start="2">
<li>静态成员函数  </li>
</ol>
</li>
<li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数  </li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员  </li>
<li>静态成员函数不能访问非静态成员函数（不包括构造函数）和非静态数据成员  </li>
</ul>
<h1 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h1><p>int i = 0;<br>A). sizeof(int);<br>B). sizeof(i);<br>C). sizeof int;<br>D). sizeof i;<br>A、B和D都正确，C错误。  </p>
<blockquote>
<p>sizeof(int) *p表示什么意思？<br>32位系统下：<br>int *p = NULL;<br>sizeof(p)的值是多少？ 4<br>sizeof(*p)呢？ 4<br>char *q = NULL;<br>sizeof(q)的值是多少？ 4<br>sizeof(*q)呢？ 1<br>int a[100];<br>sizeof (a) 的值是多少？ 400<br>sizeof(a[100])呢？ 4<br>sizeof(&amp;a)呢？ 4<br>sizeof(&amp;a[0])呢？ 4<br>int b[100];<br>void fun(int b[100])<br>{<br>    sizeof(b);// sizeof (b) 的值是多少？是个指针类型，把 int b[100] 改为 char b[100] 也是输出 4<br>}  </p>
</blockquote>
<h1 id="与零值比较"><a href="#与零值比较" class="headerlink" title="与零值比较"></a>与零值比较</h1><ol>
<li><p>bool变量<br> bool bTestFlag = FALSE;//为什么一般初始化为FALSE比较好？<br> FALSE在编译器里被定义为0，而TRUE则不一定是1，不同的编译器有不同的定义。  </p>
</li>
<li><p>float变量<br> float fTestVal = 0.0;<br> const float EPSINON = 0.00001;<br> if((fTestVal &gt;= -EPSIONON) &amp;&amp; (fTestVal &lt;= EPSINON))  </p>
</li>
</ol>
<h1 id="return关键字"><a href="#return关键字" class="headerlink" title="return关键字"></a>return关键字</h1><p>return可以返回些什么东西？如：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>str属于局部变量，位于栈内存中，在Func结束的时候被释放，所以返回str会导致错误。<br>规则：return语句不可返回指向“栈内存”的“指针”，因为该内存在函数体结束时被自动销毁。  </p>
<h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><ol>
<li><p>const修饰的是只读变量，而不是常量  </p>
</li>
<li><p>节省空间，避免不必要的内存分配，同时提高效率<br> 例如：  </p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3 <span class="comment">//宏常量</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>; <span class="comment">//此时并未将 N 放入内存中</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> i = N; <span class="comment">//此时为 N 分配内存，以后不再分配</span></span><br><span class="line"><span class="keyword">int</span> I = M; <span class="comment">//预编译期间进行宏替换，分配内存</span></span><br><span class="line"><span class="keyword">int</span> j = N; <span class="comment">//没有内存分配</span></span><br><span class="line"><span class="keyword">int</span> J = M; <span class="comment">//再进行宏替换，又一次分配内存</span></span><br></pre></td></tr></tbody></table></figure>

<p> const定义的只读变量从汇编的角度看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的只读变量在程序运行过程中只有一份拷贝（因为它是全局的只读变量，存放在静态区），而#define定义的宏常量在内存中有若干个拷贝。#define宏是在预编译阶段进行替换，而const修饰的只读变量是在编译的时候确定其值。#define宏没有类型，而const修饰的只读变量具有特定的类型。  </p>
</li>
</ol>
<p>注意：  </p>
<ul>
<li>当const修饰指针时  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p; <span class="comment">// p 可变，p 指向的对象不可变</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p; <span class="comment">// p 可变，p 指向的对象不可变</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p; <span class="comment">// p 不可变，p 指向的对象可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p; <span class="comment">// 指针 p 和 p 指向的对象都不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">//前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>const修饰函数返回值（返回指针）<br>如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。<br>例如函数：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">GetString</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
如下语句将出现编译错误：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = GetString();</span><br></pre></td></tr></tbody></table></figure>
正确的用法是：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = GetString();</span><br></pre></td></tr></tbody></table></figure></li>
<li>const修饰的只读变量不能用来作为定义数组的维数，也不能放在case关键字后面。  </li>
<li>常量指针与指针常量的区别<br>*（指针）和const（常量）谁在前先读谁；* 象征着地址，const 象征着内容；谁在前面谁就不允许改变。  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;b; <span class="comment">// const 在前，定义为常量指针</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p2 = &amp;c; <span class="comment">// * 在前，定义为指针常量</span></span><br><span class="line"><span class="comment">//常量指针p1: 指向的地址可以变，但内容不可以重新赋值，内容的改变只能通过修改地址指向后变换。</span></span><br><span class="line"><span class="comment">//指针常量p2: 指向的地址不可以重新赋值，但内容可以改变，必须初始化，地址跟随一生。</span></span><br></pre></td></tr></tbody></table></figure>
问：C语言函数返回值为 const 型 有什么意义？<br>答：当为指针时，有意义，一般数值没有意义 当返回为const指针时，表示对返回指针所指向的数据内容不要进行修改。有修改则程序会报错。  </li>
<li>C语言可以通过指针修改const修饰的只读变量  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, *p, a);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ol>
<li><p>空结构体占一个字节</p>
</li>
<li><p>柔性数组</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 柔性数组允许在定义结构体的时候创建一个空数组，而这个数组的大小可以在程序运行的过程中根据你的需求进行更改<br> 这个空数组必须声明为结构体的最后一个成员，并且还要求这样的结构体至少包含一个其他类型的成员<br> 柔性数组不占用内存<br> 给结构体分配内存：  </p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">test *stpTest = (test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test)+<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">//分配100</span></span><br><span class="line">test *stpTest = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*test) + <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">strlen</span>(paddress) + <span class="number">1</span>); <span class="comment">//动态分配</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在 C++里 struct 关键字与 class 关键字一般可以通用，只有一个很小的区别。struct 的成员默认情况下属性是 public 的，而 class 成员却是 private 的。  </p>
</li>
<li><p>union维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置空间，在union中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。  </p>
</li>
<li><p>大端模式（ Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放 在高地址中。 小端模式（ Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放 在低地址中。<br> 判断系统大小端的方法 – 可以利用union类型数据的特点：所有成员的起始地址一致  </p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">check</span></span></span><br><span class="line"><span class="class">	{</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">char</span> ch;</span><br><span class="line">	}c;</span><br><span class="line">	c.i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> (c.ch == <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	checkSystem() == <span class="number">1</span> ? <span class="built_in">printf</span>(<span class="string">"Little-endian/n"</span>) : <span class="built_in">printf</span>(<span class="string">"Big-endian/n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 在 x86 系统下，输出的值为多少？ // x86 - 小端</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">	<span class="keyword">int</span> *prt1 = (<span class="keyword">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> *ptr2 = (<span class="keyword">int</span> *)((<span class="keyword">int</span>)a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %x\n"</span>, ptr1[<span class="number">-1</span>], *ptr2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 答案： 5，2000000</span></span><br><span class="line"><span class="comment">// 解释：</span></span><br><span class="line"><span class="comment">// a 是数组首元素的首地址，而 &amp;a 是整个数组的首地址，a+1 是偏移 int 个字节， 而 &amp;a+1 是偏移整个数组的大小</span></span><br><span class="line"><span class="comment">// 所以，此题 &amp;a+1 偏移 20 个字节，ptr1[-1] = 5</span></span><br><span class="line"><span class="comment">// 数组 a 的分布是：{01 00 00 00， 02 00 00 00， 03 00 00 00， 04 00 00 00， 05 00 00 00}，地址从左到右递增</span></span><br><span class="line"><span class="comment">// (int)a + 1 是向后移动了 1 个字节，即 00 00 00 02，由于是小端，所以 02 00 00 00</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="define用法"><a href="#define用法" class="headerlink" title="#define用法"></a>#define用法</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCHAR char*</span></span><br><span class="line">PCHAR p3,p4; <span class="comment">// 等效于 char * p3,p4;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCHAR (char*)</span></span><br><span class="line">PCHAR p3,p4; <span class="comment">// 等效于 (char *) p3,p4;</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y X*2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X 2</span></span><br><span class="line"><span class="keyword">int</span> z = Y;</span><br><span class="line"><span class="comment">// z 的值是多少？ 4</span></span><br></pre></td></tr></tbody></table></figure>


<h1 id="除法与取余运算"><a href="#除法与取余运算" class="headerlink" title="除法与取余运算"></a>除法与取余运算</h1><p>参与运算的量均为整形时，结果为整形，舍去小数。如果运算量中有一个为实型，结果为双精度实型。<br>例如：5/2=2, 1/2=0, 5/2.0=2.5<br>参与运算的量均为整形，求余运算的结果等于两个数相除后的余数。<br>例如：5%2=1, 1%2=1</p>
<p>5%2.0和5.0%2的结果是语法错误  </p>
<p>除号的正负取舍和一般的算数一样，符号相同为正，相异为负,求余符号的正负取舍和被除数符号相同。<br>-3/16=0, 16/-3=-5, -3%16=-3, 16%-3=1  </p>
<p>printf(“%d\n”,10/2.5);<br>整形数据默认为int，实型数据默认为double。<br>整形只能使用整形说明符 %d 等。<br>实型只能使用实型说明符。  </p>
<h1 id="pragma预处理"><a href="#pragma预处理" class="headerlink" title="#pragma预处理"></a>#pragma预处理</h1><ul>
<li>#pragma message(“消息文本”)<br>  当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。<br>  假设我们希望判断自己有没有在源代码的什么地方定义了_X86 这个宏可以用下面的方法    <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _X86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> message(“_X86 macro activated!”)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。<br><img src="https://i.loli.net/2020/01/07/zawc7EXiB19HSU4.png" alt="32位CPU与内存模型.png">  </p>
<p>举例：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> x1;</span><br><span class="line">    <span class="keyword">short</span> x2;</span><br><span class="line">    <span class="keyword">float</span> x3;</span><br><span class="line">    <span class="keyword">char</span> x4;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于编译器默认情况下会对这个struct作自然边界对齐，结构的第一个成员x1，其偏移地址为0，占据了第1个字节。第二个成员x2为short类型，其起始地址必须2字节对界，因此，编译器在x2和x1之间填充了一个空字节。结构的第三个成员x3和第四个成员x4恰好落在其自然边界地址上，在它们前面不需要额外的填充字节。在test结构中，成员x3要求4字节对界，是该结构所有成员中要求的最大边界单元，因而test结构的自然对界条件为4字节，编译器在成员x4后面填充了3个空字节。整个结构所占据空间为12字节。  </p>
<p>使用指令#pragma pack (n)，编译器将按照 n 个字节对齐。<br>使用指令#pragma pack ()，编译器将取消自定义字节对齐方式。<br>在#pragma pack (n)和#pragma pack ()之间的代码按 n 个字节对齐。  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestStruct4</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestStruct5</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    TestStruct4 d;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> e;</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack ()</span></span><br></pre></td></tr></tbody></table></figure>
<p>问题：</p>
<ol>
<li>sizeof(TestStruct5)等于多少？  </li>
<li>TestStruct5 的 c 后面空了几个字节接着是 d？  </li>
</ol>
<p>TestStruct5 中,c 和 TestStruct4 中的 a 一样,按 1 字节对齐,而 d 是个结构,它是 8 个字节,它按什么对齐呢？<br>对于结构来说，它的默认对齐方式就是它的所有成员使用的对齐参数中最大的一个, TestStruct4 的就是 4 。<br>(复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式,这样在成员是复杂类型时,可以最小化长度)  </p>
<p>TestStruct4的内存布局：  </p>
<table>
<thead>
<tr>
<th align="left">a</th>
<th align="left">b</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1***</td>
<td align="left">1111</td>
</tr>
</tbody></table>
<p>TestStruct5的内存布局：  </p>
<table>
<thead>
<tr>
<th align="left">c</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">e</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1***</td>
<td align="left">1***</td>
<td align="left">1111****</td>
<td align="left">11111111</td>
</tr>
</tbody></table>
<p>答案：</p>
<ol>
<li>24  </li>
<li>3  </li>
</ol>
<p>注意：<br>对于数组,比如:char a[3];它的对齐方式和分别写 3 个 char 是一样的.也就是说，它还是按 1 个字节对齐.如果写: typedef char Array3[3];Array3 这种类型的对齐方式还是按 1 个字节对齐,而不是按它的长度。  </p>
<p>补充：联合体内存对齐的问题  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//例1：</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">}u;</span><br><span class="line"><span class="comment">//sizeof(u) = 16</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//例2：</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">double</span> a1;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> height;</span><br><span class="line">}stu;</span><br><span class="line"><span class="comment">//sizeof(stu) = 24</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//例3：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        <span class="keyword">long</span> a;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        {</span></span><br><span class="line">            <span class="keyword">char</span> a1;</span><br><span class="line">            <span class="keyword">short</span> a2;</span><br><span class="line">            <span class="keyword">char</span> a3;</span><br><span class="line">        }st_a;</span><br><span class="line">    }un_a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(un_a.st_a)), (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(un_a)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//sizeof(un_a.st_a) = 6</span></span><br><span class="line"><span class="comment">//sizeof(un_a) = 8</span></span><br></pre></td></tr></tbody></table></figure>
<p>从这里可以看出联合体所占的空间不仅取决于最宽成员，还跟所有成员有关系，即其大小必须满足两个条件：  </p>
<ol>
<li>大小足够容纳最宽的成员  </li>
<li>大小能被其包含的所有基本数据类型的大小所整除</li>
</ol>
<h1 id="a-i"><a href="#a-i" class="headerlink" title="a[i]"></a>a[i]</h1><p>对于数组a[i]<br>数组首元素的地址：a、&amp;a[0]<br>数组的地址：&amp;a  </p>
<h1 id="指针和数组的定义与声明"><a href="#指针和数组的定义与声明" class="headerlink" title="指针和数组的定义与声明"></a>指针和数组的定义与声明</h1><ol>
<li><p>编译器会把存在指针变量中的任何数据当做地址来处理  </p>
</li>
<li><p>定义为数组，声明为指针<br> 文件1：char a[100]; //定义了数组a<br> 文件2：extern char *a; //声明它为指针 //这样做是错的  </p>
<p> 解析：extern char a[] 与 extern char a[100] 等价的原因，因为这是声明，不分配空间，所以编译器无需知道这个数组有多少个元素。这两个声明都告诉编译器 a 是在别的文件中被定义的一个数组， a 同时代表数组 a 的首元素的首地址，也就是这块内存的起始地址。数组内任何元素的地址都只需要知道这个地址就可以计算出来。但是，当你声明为 extern char *a 时，编译器理所当然的认为 a 是一个指针变量，在 32 位系统下，占 4 个 byte。这 4 个 byte 里保存了一个地址，这个地址上存的是字符类型数据。虽然在文件 1 中，编译器知道 a 是一个数组，但是在文件 2 中，编译器并不知道这点。大多数编译器是按文件分别编译的，编译器只按照本文件中声明的类型来处理。所以，虽然 a 实际大小为 100 个 byte，但是在文件 2 中，编译器认为 a 只占 4 个 byte。  </p>
</li>
<li><p>定义为指针，声明为数组<br> 文件1：char *p = “abcdefg”;<br> 文件2：extern char p[]; //这样的做法也是错误的</p>
<p> 解析：在文件 1 中， 编译器分配 4 个 byte 空间， 并命名为 p。 同时 p 里保存了字符串常量 “ abcdefg” 的首字符的首地址。这个字符串常量本身保存在内存的静态区，其内容不可更改。在文件 2 中，编译器认为 p 是一个数组，其大小为 4 个 byte，数组内保存的是 char 类型的数据。  </p>
</li>
</ol>
<h1 id="地址的强制转换"><a href="#地址的强制转换" class="headerlink" title="地址的强制转换"></a>地址的强制转换</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    <span class="keyword">char</span> *pcName;</span><br><span class="line">    <span class="keyword">short</span> sDate;</span><br><span class="line">    <span class="keyword">char</span> cha[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">}*p;</span><br></pre></td></tr></tbody></table></figure>
<p>假设 p 的值为 0x100000，如下表达式的值分别为多少？  </p>
<ol>
<li>p + 0x1 = 0x____ ?  </li>
<li>(unsigned long) p + 0x1 = 0x____ ?  </li>
<li>(unsigned int *) p + 0x1 = 0x____ ?  </li>
</ol>
<p>指针变量与一个整数相加减并不是用指针变量里的地址直接加减这个整数。  </p>
<ol>
<li>p + 0x1 的值为 0x100000 + sizof（ Test） * 0x1 ，此结构体的大小为 20byte，所以 p + 0x1 的值为： 0x100014  </li>
<li>将指针变量 p 保存的值强制转换成无符号的长整型数。任何数值一旦被强制转换，其类型就改变了。所以这个表达式其实就是一个无符号的长整型数加上另一个整数。所以其值为： 0x100001  </li>
<li>p 被强制转换成一个指向无符号整型的指针。所以其值为： 0x100000 + sizeof（ unsigned int） * 0x1，等于 0x100004  </li>
</ol>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>];</span><br><span class="line">p = a;</span><br><span class="line"><span class="comment">//问&amp;p[4][2] - &amp;a[4][2]的值为多少？</span></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>前面我们讲过，当数组名 a 作为右值时，代表的是数组首元素的首地址。这里的 a 为二维数组，我们把数组 a 看作是包含 5 个 int 类型元素的一维数组,里面再存储了一个一维数组。如此，则 a 在这里代表的是 a[0]的首地址。 a+1 表示的是一维数组 a 的第二个元素。 a[4]表示的是一维数组 a 的第 5 个元素，而这个元素里又存了一个一维数组。所以&amp;a[4][2]表示的是&amp;a[0][0]+4*5*sizeof(int) + 2*sizeof(int)。  </li>
<li>根据定义， p 是指向一个包含 4 个元素的数组的指针。也就是说 p+1 表示的是指针 p 向后移动了一个“包含 4 个 int 类型元素的数组”。这里 1 的单位是 p 所指向的空间，即4*sizeof(int)。所以， p[4]相对于 p[0]来说是向后移动了 4 个“包含 4 个 int 类型元素的数组”，即&amp;p[4]表示的是&amp;p[0]+4*4*sizeof(int)。由于 p 被初始化为&amp;a[0]，那么&amp;p[4][2]表示的是&amp;a[0][0]+4*4*sizeof(int)+2* sizeof(int)。  </li>
<li>其实我们最简单的办法就是画内存布局图  </li>
</ol>
<h1 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h1><h1 id="一维数组参数"><a href="#一维数组参数" class="headerlink" title="一维数组参数"></a>一维数组参数</h1><p>C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针。<br>同样的，函数的返回值也不能是一个数组，而只能是指针。  </p>
<h1 id="一级指针参数"><a href="#一级指针参数" class="headerlink" title="一级指针参数"></a>一级指针参数</h1><p>问： 能否把指针变量本身传递给一个函数？<br>例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> c = p[<span class="number">3</span>]; <span class="comment">//或者是 char c = *(p+3)</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *p2 = <span class="string">"abcdefg"</span>;</span><br><span class="line">    fun(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>答： 无法把指针变量本身传递给一个函数。<br>func函数实际运行时，对 p2 做一份拷贝，假设其拷贝名为_p2。那传递到func函数内部的就是_p2 而并非 p2 本身。  </p>
<p>再看如下例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span> <span class="params">(<span class="keyword">char</span> * p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">free</span>(str); <span class="comment">//free 并没有起作用，内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在运行 strcpy(str,”hello”)语句的时候发生错误。这时候观察 str 的值， 发现仍然为 NULL。也就是说 str 本身并没有改变，我们 malloc 的内存的地址并没有赋给str，而是赋给了_str。而这个_str 是编译器自动分配和回收的，我们根本就无法使用。  </p>
<p>解决方法：  </p>
<ol>
<li>用return  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">GetMemory</span> <span class="params">(<span class="keyword">char</span> * p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetMemory(str,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>用二级指针  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span> <span class="params">(<span class="keyword">char</span> ** p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(&amp;str,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//注意，这里的参数是&amp;str 而非 str。这样的话传递过去的是 str 的地址，是一个值。在函数内部，用钥匙("*")来开锁： *(&amp;str)，其值就是 str。所以 malloc 分配的内存地址是真正赋值给了 str 本身。</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="二维数组参数与二维指针参数"><a href="#二维数组参数与二维指针参数" class="headerlink" title="二维数组参数与二维指针参数"></a>二维数组参数与二维指针参数</h1><p>Page 100</p>
<h1 id="函数指针使用"><a href="#函数指针使用" class="headerlink" title="函数指针使用"></a>函数指针使用</h1><h1 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h1><h1 id="函数指针数组的指针"><a href="#函数指针数组的指针" class="headerlink" title="函数指针数组的指针"></a>函数指针数组的指针</h1><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>如果参数是指针，且仅作为输入参数用，则应在类型前加const，以防止该指针在函数体内被意外修改。例如：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_copy</span> <span class="params">(<span class="keyword">char</span> *strDestination， <span class="keyword">const</span> <span class="keyword">char</span> *strSource)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li>return语句不可返回指向“栈内存”的“指针”，因为该内存在函数体结束时被自动销毁。例如：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>在函数体的“入口处”，对参数的有效性进行检查。尤其是指针参数，尽量使用assert宏做入口校验，而不使用if语句校验。  </li>
</ol>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>防止头文件被重复包含  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __FN_FILENAME_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FN_FILENAME_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>其中“FN_FILENAME”一般为本头文件名大写，这样可以有效避免重复，因为同一个工程中不可能存在两个同名的头文件。  </p>
<h1 id="常见的内存错误及对策"><a href="#常见的内存错误及对策" class="headerlink" title="常见的内存错误及对策"></a>常见的内存错误及对策</h1><ol>
<li><p>指针没有指向一块合法的内存  </p>
<ol>
<li>结构体成员指针未初始化（解决方法是malloc一块空间）  </li>
<li>没有为结构体指针分配足够的内存  </li>
<li>函数的入口校验  <ul>
<li>不管什么时候，我们使用指针之前一定要确保指针是有效的  </li>
<li>一般在函数入口处使用 assert(NULL != p)对参数进行校验。在非参数的地方使用 if(NULL != p)来校验。但这都有一个要求，即 p 在定义的同时被初始化为 NULL 了  </li>
<li>assert 是一个宏，而不是函数，包含在 assert.h 头文件中。如果其后面括号里的值为假，则程序终止运行，并提示出错；如果后面括号里的值为真，则继续运行后面的代码  </li>
</ul>
</li>
</ol>
</li>
<li><p>为指针分配的内存太小  </p>
</li>
<li><p>内存分配成功，但并未初始化  </p>
</li>
<li><p>内存越界  </p>
</li>
<li><p>内存泄漏<br> 会产生泄漏的内存就是堆上的内存（这里不讨论资源或句柄等泄漏情况），也就是说由 malloc 系列函数或 new 操作符分配的内存。如果用完之后没有及时 free 或 delete，这块内存就无法释放，直到整个程序终止  </p>
<ul>
<li><p>malloc 函数的原型：(void *)malloc(int size)<br>  使用 malloc 函数同样要注意这点：如果所申请的内存块大于目前堆上剩余内存块（整块），则内存分配会失败，函数返回 NULL<br>  既然 malloc 函数申请内存有不成功的可能，那我们在使用指向这块内存的指针时，必须用 if(NULL != p)语句来验证内存确实分配成功了  </p>
</li>
<li><p>内存释放 free函数：free(p)<br>  指针变量 p 本身保存的地址并没有改变，但是它对这个地址处的那块内存却已经没有所有权了。那块被释放的内存里面保存的值也没有改变，只是再也没有办法使用了<br>  如果对 p 连续两次以上使用 free 函数，肯定会发生错误。因为第一使用 free 函数时， p 所属的内存已经被释放，第二次使用时已经无内存可释放了<br>  既然使用 free 函数之后指针变量 p 本身保存的地址并没有改变， 那我们就需要重新把 p的值变为 NULL：p = NULL<br>  释放完块内存之后，没有把指针置 NULL，这个指针就成为了“野指针”，这是很危险的，而且也是经常出错的地方。所以一定要记住一条：free 完之后，一定要给指针置 NULL  </p>
</li>
</ul>
</li>
</ol>
<h1 id="其他典型题目"><a href="#其他典型题目" class="headerlink" title="其他典型题目"></a>其他典型题目</h1><ul>
<li><p>当unsigned类型与signed类型运算时，默认转换成unsigned类型  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-6</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a+b&gt;0\n"</span>);<span class="comment">//这句话被打印</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a+b&lt;0\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> z = a+b;</span><br><span class="line">    <span class="keyword">if</span>(z &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"z&gt;0"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"z&lt;0"</span>);<span class="comment">//这句话被打印</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当int和unsigned int相加时，要将int转化为unsigned int，而int小于0，所以它的最高位是符号位，为1，所以转化的结果是一个很大的正数，在第一个if语句中，是两个“正数”相加，结果自然就大于0了。而在z = a+b这一句时，它把a+b的结果看做一个int类型，而a+b最高位为1，所以z是一个负数，所以打印的是第二个语句。  </p>
</li>
<li><p>在以下数组定义中，正确的有（AD）<br>A) int a[‘a’];<br>B) int a[3.4];<br>C) int a[][4];<br>D) int *a[10];<br>int a[][4]; 不明确的话，就不知道分配多少内存。  </p>
<p>  在定义二维数组的时候对其进行初始化，也可以省略第一维，编译器会根据你的初始化语句自动决定第一维度。（有初始化的时候，第二维的数字代表分配内存的长度，第一维的数字代表分配内存倍数，倍数可以让机器去数，但长度没有的话就不好开辟空间了）  </p>
<p>  多维数组声明时，可以省略第一维，但是不能省略第二维或者更高维的大小。这是由编译器原理限制的。<br>  设有数组int a[m][n]，如果要访问a[i][j]的值，编译器的寻址方式为：  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">&amp;a[i][j]=&amp;a[<span class="number">0</span>][<span class="number">0</span>]+i*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n+j*<span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">//注意n为第二维的维数</span></span><br></pre></td></tr></tbody></table></figure>
<p>  因此，可以省略第一维的维数，不能省略其他维的维数。  </p>
</li>
<li><p>printf压栈<br>  例1：  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>,++n,++n,n++,++n); <span class="comment">// 9 9 6 9</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>,n); <span class="comment">// 9</span></span><br></pre></td></tr></tbody></table></figure>

<p>  例2：  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, i, --i, i, i--);</span><br></pre></td></tr></tbody></table></figure>

<p>  “对于a++的结果，是有ebp寻址函数栈空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；而对于++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。”  </p>
</li>
<li><p>数组和指针  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str7 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *str8 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str1 == str2 ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str3 == str4 ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str5 == str6 ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str7 == str8 ) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>  结果是：0 0 1 1<br>  解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间。而str5,str6,str7,str8是指针，它们指向相同的常量区域。  </p>
</li>
<li><p>字符串常量</p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* s=<span class="string">"AAA"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">'B'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br></pre></td></tr></tbody></table></figure>
<p>  有什么错？<br>  “AAA”是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。<br>  cosnt char* s=”AAA”;<br>  然后又因为是常量，所以对是s[0]的赋值操作是不合法的。  </p>
</li>
<li><p>优先级<br>  () &gt; [] &gt; *  </p>
<p>  指针数组：int *(ap[])<br>  数组指针：int (*ap) []<br>  所以 int * ap[]是指针数组，因为 [] 的优先级高于 *  </p>
<p>  指针函数：int * ( fp() )  // () 优先级高，先与 fp 结合成一个函数，再由 int * 说明这是一个整形的指针函数<br>  函数指针：int (*fp) ()  // () 运算符，自左至右，首先说明 fp 是一个指针，指向一个返回值是整形的函数<br>  所以 int *fp() 是指针函数，因为 () 的优先级高于 *  </p>
</li>
<li><p>定义  </p>
</li>
</ul>
<ol>
<li>变量的定义中，除了 变量名 以外的内容就是该变量的类型<br> int a; a 变量名, int 类型<br> int b[10];   b 变量名  ，int [10] 数组的类型<br> int * p   p  变量名   int * 指针的类型  </li>
<li>数组的定义中，除了 数组名[元素数目] 以外的内容就是该数组的元素类型<br> int a[10]  int 元素类型   整形数组<br> int a [3][5] int[5] 数组类型   二维数组<br> int * p[5]   int *  指针类型  指针数组  </li>
<li>指针的定义中，除了 * 指针变量名，以外的内容就是该指针指向对象的类型<br> int *p;   int 整形    整形指针<br> int (*p)[5];  int[5]  数组    数组指针<br> int (*p) ();      int () 返回值为int类型的函数    函数指针   </li>
</ol>
<ul>
<li><p>函数指针和指针函数<br>函数指针的本质是一个变量，该变量的内容指向一个函数。<br>指针函数的本质是一个函数，只不过其返回值是一个指针类型的变量。  </p>
</li>
<li><p>地址<br>  要对绝对地址0x100000赋值，我们可以用  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="number">0x100000</span> = <span class="number">1234</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>  那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)( ))<span class="number">0x100000</span> ) ( );</span><br></pre></td></tr></tbody></table></figure>

<p>  首先要将0x100000强制转换成函数指针,即:  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span> (*)())<span class="number">0x100000</span></span><br></pre></td></tr></tbody></table></figure>
<p>  然后再调用它:  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)())<span class="number">0x100000</span>)();</span><br></pre></td></tr></tbody></table></figure>
<p>  用typedef可以看得更直观些:  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*)</span><span class="params">()</span> voidFuncPtr</span>;</span><br><span class="line">*((voidFuncPtr)<span class="number">0x100000</span>)();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>为什么有垃圾值？<br>  因为操作系统释放内存只是释放对这个内存地址的使用权限（回收内存空间），下一个变量使用这个内存地址的时候，内存地址上保存的值还是上一次遗留下来的值，这就是垃圾值，因此变量需要初始化。  </p>
</li>
<li><p>如果两指针属于同一数组，则可以相减  </p>
</li>
<li><p>一个字节一个地址。所有的指针变量只占4个字节，用第一个字节的地址表示整个变量的地址。  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>一个DVB-C自动搜台的疑问</title>
    <url>/2018/12/18/dvbc-auto-tuning/</url>
    <content><![CDATA[<p>DVBC搜台过程中，频点乱序。</p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Mantis提交了一条问题：DVBC搜台过程中，进度条在前进，频点也在跳动，但是乱序，并非从低到高。<br>实际情况是：码流机播放《610.750 Network ID 1536.ts》码流，频点设定到482MHz，DVBC搜台过程中，频率从低到高搜，但是搜到482MHz的时候，频率就乱了。  </p>
<h3 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h3><p>截取部分log信息：  </p>
<blockquote>
<p>[virtual void CTableScanner::xWorkerThread() 139] CH_SCAN_STATE_BEGIN_FREQ start<br>[virtual void CTableScanner::xWorkerThread() 145] CH_SCAN_STATE_SCANNING start<br>xStageBeginFreq:161:: m_isDeleteAll = 1, m_curFreq = 474000000<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 296] isScanMode = 1, m_curFreq = 474000000, m_curBandwidth = 8000000, tunerId = 0, m_feType = 2, m_modulation = 11,  m_symbolrate = 6900000<br>[bool FrontendLib_SetTuner(UINT32, UINT32, UINT8, RT_FRONTEND_TYPE, RT_MODULATION, RT_SPECTRAL_INVERSION, bool, UINT32, SatelliteInfo *) 156] isScanMode = 1, frequency = 474000000, bandwidth = 8000000, tunerId = 0, feType = 2, modulation = 11,  symbolRate = 6900000<br>[FrontendLib_SetTuner 174] frequency=474000000 bandwidth=8000000 tvSystem=19<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 298] ret = 0<br>[virtual void CTableScanner::xWorkerThread() 166] CH_SCAN_STATE_SCANNING end<br>[virtual void CTableScanner::xWorkerThread() 171] CH_SCAN_STATE_END_FREQ begin<br>[xUpdateChannelMgr:197] freq=474000000, bSave=1, bUpdateCurChIndex=0, bKeepChannel=0, curFrequency=0, modulation=11<br>xUpdateChannelMgr 211 RemoveChannel 474000000<br>[xRemoveChannel:2220]<br>[bool CDvbTableScanner::xGetNitFreqList(bool) 139] errCode = 1900551, freqCount = 0<br>[virtual void CTableScanner::xWorkerThread() 139] CH_SCAN_STATE_BEGIN_FREQ start<br>[virtual void CTableScanner::xWorkerThread() 145] CH_SCAN_STATE_SCANNING start<br>xStageBeginFreq:161:: m_isDeleteAll = 1, m_curFreq = 482000000<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 296] isScanMode = 1, m_curFreq = 482000000, m_curBandwidth = 8000000, tunerId = 0, m_feType = 2, m_modulation = 11,  m_symbolrate = 6900000<br>[bool FrontendLib_SetTuner(UINT32, UINT32, UINT8, RT_FRONTEND_TYPE, RT_MODULATION, RT_SPECTRAL_INVERSION, bool, UINT32, SatelliteInfo *) 156] isScanMode = 1, frequency = 482000000, bandwidth = 8000000, tunerId = 0, feType = 2, modulation = 11,  symbolRate = 6900000<br>[FrontendLib_SetTuner 174] frequency=482000000 bandwidth=8000000 tvSystem=19<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 298] ret = 1<br>virtual void CDtvFreqDetector::xStageBeginFreq()_304 signal LOCKED !!!!!!!!<br>[virtual void CDtvFreqDetector::xStageCheckFrontend() 771] m_curFreq = 482000000, m_curBandwidth = 8000000 m_modulation = 11<br>[virtual void CTableScanner::xWorkerThread() 166] CH_SCAN_STATE_SCANNING end<br>[virtual void CTableScanner::xWorkerThread() 171] CH_SCAN_STATE_END_FREQ begin<br>[xUpdateChannelMgr:197] freq=482000000, bSave=1, bUpdateCurChIndex=0, bKeepChannel=0, curFrequency=0, modulation=11<br>xUpdateChannelMgr 211 RemoveChannel 482000000<br>[xRemoveChannel:2220]<br><strong>[bool CDvbTableScanner::xGetNitFreqList(bool) 139] errCode = 0, freqCount = 39</strong><br><strong>xGetNitFreqList..freq:482750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:458750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:124000000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:466750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:506750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:578750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:386750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:498750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:626750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:650750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:148000000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:714750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:698750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:706750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:762750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:826750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:858750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:642750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:778750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:810750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:834750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:746750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:298750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:602750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:610750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:850750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:140000000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:738750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:530750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:818750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:690750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:164000000, symbolRate:6900000, modulation:9, polarization:0</strong><br><strong>xGetNitFreqList..freq:842750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:666750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:682750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:156000000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:554750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:490750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:132000000, symbolRate:6900000, modulation:11, polarization:0</strong><br>[Mf_ScanInit 1000] modeEx=0, param=-1, scanMode=7 m_deleteAll=1<br>[xRemoveChannel:2288] m_chVector.m_size=39<br>ScanInit….type 2 antennaIndex 0xffffffff typeEx 0 time 304186343<br>[virtual void CTableScanner::xWorkerThread() 139] CH_SCAN_STATE_BEGIN_FREQ start<br>[virtual void CTableScanner::xWorkerThread() 145] CH_SCAN_STATE_SCANNING start<br>xStageBeginFreq:161:: m_isDeleteAll = 1, m_curFreq = 482750000<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 296] isScanMode = 1, m_curFreq = 482750000, m_curBandwidth = 8000000, tunerId = 0, m_feType = 2, m_modulation = 11,  m_symbolrate = 6900000<br>[bool FrontendLib_SetTuner(UINT32, UINT32, UINT8, RT_FRONTEND_TYPE, RT_MODULATION, RT_SPECTRAL_INVERSION, bool, UINT32, SatelliteInfo *) 156] isScanMode = 1, frequency = 482750000, bandwidth = 8000000, tunerId = 0, feType = 2, modulation = 11,  symbolRate = 6900000<br>[FrontendLib_SetTuner 174] frequency=482750000 bandwidth=8000000 tvSystem=19<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 298] ret = 1<br>virtual void CDtvFreqDetector::xStageBeginFreq()_304 signal LOCKED !!!!!!!!<br>[virtual void CDtvFreqDetector::xStageCheckFrontend() 771] m_curFreq = 482750000, m_curBandwidth = 8000000 m_modulation = 11<br>[virtual void CTableScanner::xWorkerThread() 166] CH_SCAN_STATE_SCANNING end<br>[virtual void CTableScanner::xWorkerThread() 171] CH_SCAN_STATE_END_FREQ begin<br>[xUpdateChannelMgr:197] freq=482750000, bSave=1, bUpdateCurChIndex=0, bKeepChannel=0, curFrequency=0, modulation=11<br>bool CDvbSiMgr::xUpdateChannelMgr(__UINT32, INT16, bool, bool, bool, __UINT32, RT_MODULATION) 218 count 6<br>AddChannel:LCN=1,chName=Nederland 1 HD,frequency=482750000<br>AddChannel:LCN=2,chName=Nederland 2 HD,frequency=482750000<br>AddChannel:LCN=3,chName=RTL Lounge,frequency=482750000<br>AddChannel:LCN=4,chName=TVE,frequency=482750000<br>AddChannel:LCN=5,chName=HZN Barker 1,frequency=482750000<br>AddChannel:LCN=6,chName=HZN Barker 2,frequency=482750000<br>bool CDvbSiMgr::xUpdateChannelMgr(__UINT32, INT16, bool, bool, bool, __UINT32, RT_MODULATION) use time 0  </p>
</blockquote>
<p>使用码流分析工具查看码流：<br><img src="https://i.loli.net/2018/12/18/5c18b1955d467.png" alt="NIT">  </p>
<p>代码片段[RTD2831]：  </p>
<pre><code class="cpp">bool CDvbTableScanner::xGetNitFreqList(bool bDelete)
{
    int freqCount=0;
    SI_DELIVERY_PARAM *pFreqList = NULL;
    ErrCode errCode;
    int startindex=0;
    bool bDelFollow=false;
    bool bAddCurrent=false;
    bool bIncludeExistTP=false;
    RT_FRONTEND_TYPE feType = m_pFreqScanDetector-&gt;Mf_GetFrontendType();
    SI *siHandle = (SI*)((IDtvMedia*)m_pTvMedia)-&gt;GetDtvFlow()-&gt;GetSiHandle();
    if(feType == RT_FRONTEND_DVB_CABLE &amp;&amp; !m_bRemoveAll)
    {
        bIncludeExistTP=true;
    }

    errCode = SI_GetFreqList(siHandle, &amp;freqCount, &amp;pFreqList, bIncludeExistTP);
    ALOGD("[%s %d] errCode = %lu, freqCount = %d\n", __func__, __LINE__, errCode, freqCount);

    if (errCode != SI_ERR_OK || freqCount==0 || pFreqList == NULL)
    {
        return FALSE; //如果freqCount为零，就返回了。
    }

    if(feType == RT_FRONTEND_DVB_SATELLITE &amp;&amp; m_HomeTp.count!=0)
    {
        bDelete=true;
        if(m_HomeTp.onid!=0)
        {
            bDelete=false;
            for(int i=0;i&lt;freqCount;i++)
            {
                if(pFreqList[i].onid==m_HomeTp.onid)
                {
                    bDelete=true;
                    break;
                }
            }
        }
    }

    if(feType == RT_FRONTEND_DVB_SATELLITE &amp;&amp; bDelete &amp;&amp; m_pFreqList!=NULL)
    {
        bDelFollow=true;
        bDelete=false;
    }

    if(bDelete || m_pFreqList==NULL)
    {
        xFreeTable();
        
        m_pFreqList = (RT_PHY_CHANNEL *)malloc(sizeof(RT_PHY_CHANNEL) * (freqCount+1));
        if(m_pFreqList == 0)
            return false;
        m_freqListSize = freqCount+1;
        memset(m_pFreqList, 0, sizeof(RT_PHY_CHANNEL)* (m_freqListSize));
        m_isMallocedList=true;
        
        if(feType == RT_FRONTEND_DVB_CABLE)
        {
            bAddCurrent=true;
        }
    }
    else
    {
        RT_PHY_CHANNEL *pFreqList;
        int sizeTmp=m_freqListSize;
        pFreqList = (RT_PHY_CHANNEL *)malloc(sizeof(RT_PHY_CHANNEL)* (sizeTmp+freqCount));
        if(pFreqList==NULL)
        {
            return false;
        }
        memcpy(pFreqList, m_pFreqList, sizeof(RT_PHY_CHANNEL)* (sizeTmp));
        xFreeTable();
        m_pFreqList=pFreqList;
        if(bDelFollow)
            startindex=m_curFreqIndex;
        else
            startindex=sizeTmp;
        m_freqListSize=sizeTmp+freqCount;
        m_isMallocedList=true;
    }

    for (int i = 0; i &lt; freqCount &amp;&amp; startindex&lt;m_freqListSize; i++)
    {
        m_pFreqList[startindex].channelNum = startindex;

        m_pFreqList[startindex].frequency = pFreqList[i].frequency;

        switch (pFreqList[startindex].modulation)    // Cable delivery system descriptor, defined in en300468 DVB-SI spec
        {
            case SI_DVB_16_QAM:      // 16QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM16;
                break;
            case SI_DVB_32_QAM:      // 32QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM32;
                break;
            case SI_DVB_64_QAM:      // 64QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM64;
                break;
            case SI_DVB_128_QAM:      // 128QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM128;
                break;
                        default:
            case SI_DVB_256_QAM:      // 256QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM256;
                break;
        }
        m_pFreqList[startindex].symbolRate = pFreqList[i].symbol_rate;


        if(feType == RT_FRONTEND_DVB_SATELLITE)
        {
            m_pFreqList[startindex].modulation = pFreqList[i].modulation_system == 0 ? RT_MOD_DVB_S : RT_MOD_DVB_S2;
            m_pFreqList[startindex].symbolRate = pFreqList[i].symbol_rate;
        }


        m_pFreqList[startindex].bandwidth = 8000000;
        m_pFreqList[startindex].polarization= pFreqList[i].polarization%2;
        if(bDelete || iSNewTP(m_pFreqList,startindex,&amp;m_pFreqList[startindex]))
        {
            ALOGD("%s..freq:%d, symbolRate:%d, modulation:%d, polarization:%d\n",__FUNCTION__,m_pFreqList[startindex].frequency,m_pFreqList[startindex].symbolRate,
            m_pFreqList[startindex].modulation,m_pFreqList[startindex].polarization);
                startindex++;
        }

        if(bAddCurrent &amp;&amp; startindex&lt;m_freqListSize)
        {
            if(m_curFreq/1000000 == m_pFreqList[startindex].frequency/1000000)
            {
                bAddCurrent=false;
            }
        }
    }

    if(bAddCurrent)
    {
        m_pFreqList[startindex].frequency = m_curFreq;
        m_pFreqList[startindex].bandwidth = m_curBandwidth;
        m_pFreqList[startindex].channelNum = m_curChNum;
        m_pFreqList[startindex].modulation = m_curModulation;
        m_pFreqList[startindex].symbolRate = m_curSymbolRate;
        m_pFreqList[startindex].polarization = m_curPolarization;
        startindex++;
    }

    m_freqListSize=startindex;
    return true;
}

bool CDvbTableScanner::iSNewTP(RT_PHY_CHANNEL *src, int size, RT_PHY_CHANNEL *pTp)
{
    if(pTp-&gt;frequency == 0)
        return FALSE;
    for(int i=0;i&lt;size;i++)
    {
        if(abs((int)src[i].frequency/100000 - (int)pTp-&gt;frequency/100000) &lt; 3)
        {
            if(src[i].symbolRate != pTp-&gt;symbolRate)
                continue;

            if(src[i].polarization != pTp-&gt;polarization)
                continue;

            if(src[i].modulation != pTp-&gt;modulation)
                continue;

            return false;
        }
    }
    return true;
}
</code></pre>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>可知是NIT的原因，自动搜台的时候（如果没有指定频点）会从频点由低往高搜台，搜到台后，解析NIT时发现有FreqList，就去FreqList里面的频点搜。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>NIT(Network Information Table 网络信息表)。此DVB列表包含了有关网络的范围、转换器等信息。它总是位于PID 0x0010的位置。DVB定义了两种类型的NIT，NIT Actual与NIT Other。NIT Actual是一个包含有关正在被访问的网络的物理参数的一个命令列表。NIT Other包含了有关其他网络的物理参数，NIT Other是可选项。  </li>
<li>NIT搜索就是从NIT表开始的搜索，NIT表中的第二个循环，给出了当前网络中的频点，调制方式，符号率。搜索NIT表知道这些消息以后，将得到的频点做一个列表，然后挨个锁频，在每个频点下搜索PAT,PMT，然后得到节目，搜索完所有的频点以后，当前网络所有的节目就得到了。  </li>
<li><a href="https://blog.csdn.net/kkdestiny/article/details/12994675">【PSI/SI学习系列】2.PSI/SI深入学习3——SI信息解析1(NIT,BAT)</a>  </li>
<li><a href="https://blog.csdn.net/rongdeguoqian/article/details/40372097">DVB-SI理解入门</a>  </li>
<li><a href="https://www.xjishu.com/zhuanli/62/200810067838.html">现有数字电视的搜台方式包含两大类全频点搜台和利用NIT (Network Information Table,网络信息表)快速搜台。前者的做法与模拟电视相似，根据频压曲线的变化和解码器相关数据当前的状态改变步进从低频到高频逐步扫描，这种过程一般会超过20分钟，并且由于无法利用NIT表，没有节目自动更新的功能；而后者先找到NIT并从NIT中提取Frequency List Descriptor(频率列表描述子)，利用频率列表描述子所带的频率信息，快速定位到每一个有信 号的频率点，从而完成快速搜台</a></li>
</ul>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>realtek</tag>
        <tag>dvb</tag>
        <tag>dvb-c</tag>
        <tag>dtv</tag>
        <tag>si</tag>
        <tag>scan</tag>
      </tags>
  </entry>
  <entry>
    <title>一次SKD生产异常</title>
    <url>/2018/12/08/skw-skd/</url>
    <content><![CDATA[<p>客户拿到我们板卡，直接装整机，装好整机后上电升级，有的板卡升级后无法开机。</p>
<span id="more"></span>

<p>一共寄回来19块板子，客户反馈的状态如下：  </p>
<ul>
<li>有11片板子是如下两种状态：  </li>
</ul>
<ol>
<li>上电 按键按一下 灯闪一下 但是不开机 –&gt; 好多板卡都被升级了，此现象无法看到  </li>
<li>按键灯一直是红灯 没反应 不开机 –&gt; 确实有这个现象，有两种不同情况  </li>
</ol>
<ul>
<li>另外8片板子状态如下：  </li>
</ul>
<ol>
<li>有4片是上螺钉时打坏器件 –&gt; 硬件处理  </li>
<li>有1片是指示灯插反 –&gt; 硬件处理  </li>
<li>有1片有时候能开机，有时候不能开机，老化两小时之后，都能开机了 –&gt; 看到的现象是有时候能开机，有时候要自动开好几回才能开起来，后来flash被人换掉，换掉后都能正常开机，然后把旧的flash换回来，也能正常开机了，还不能明白准确原因，看之前的log信息，自动开好几回才能开起来像是DRAM没有跑起来，可是以前有现象的时候，没有量到DRAM电压和core power电压，就被换掉flash，现在也无法复测现象了，只能认为板子焊接有问题导致DRAM不能正常跑起来（如果外围没有问题，可以考虑更换IC尝试）  </li>
<li>有1片3.3V对地短路 –&gt; ？？？  </li>
<li>有1片是上电不开机有1.8V –&gt; 这里应该是core power，这片应该属于11片板那一类  </li>
</ol>
<p>无法开机的，硬件检查都没有异常，板卡都被人重新空片升级掉了，能用的板卡（我手上就两块），有两种情况：  </p>
<ol>
<li>上电后log信息提示“code is not complete”，此类可以重新上电升级。  </li>
<li>上电后log信息只有“S2Tek_a35 08/15”，此类是boot坏掉了，需要进行空片升级。把flash拿下来，读一下，得到：  <blockquote>
<p>0x00000000 ~ 0x0000FFF0: 全部0xFF<br>0x00010000 ~ 0x00377490: 有数据<br>0x003774A0 ~ 0x003EAFF0: 全部0xFF<br>0x003EB000 ~ 0x003EB380: 有数据<br>0x003EB390 ~ 0x003EBFF0: 全部0xFF<br>0x003EC000 ~ 0x003EC270: 有数据<br>0x003EC280 ~ 0x003ECFF0: 全部0xFF<br>0x003ED000: 有数据<br>0x003ED010 ~ 0x003EFFE0: 全部0xFF<br>0x003EFFF0 ~ 0x003F0FF0: 有数据<br>0x003F1000 ~ 0x003F1FF0: 全部0xFF<br>0x003F2000 ~ 0x003FFFF0: 有数据  </p>
</blockquote>
</li>
</ol>
<p>打开出货的ROM bin，发现：<br><img src="https://i.loli.net/2018/12/08/5c0b623b411de.jpg" alt="0x3774a0"><br>根据flash layout，0x003EB000此地址以上是Maincode分区，数据是连续的，以下则是模块分区，各模块之间并不是连续的。于是认为这是上电升级过程中，刚擦除boot的时候就断电了，所以后来上电也无法进行上电升级，更无法开机了，此种情况只能进行空片升级。（若升级前后boot版本相同，升级是不会擦除boot的，这种情况升级过程掉电，重新开机时也能做boot升级。若boot本身也要升级，原先boot code已被擦除而新的boot没能正常写入将会无法开机）  </p>
<p>奇怪的地方在于，19片板卡中，给原厂送去3片分析，有一片是属于“code is not cpmplete”但是可以继续上电升级的情况，但是另外有一片，读出来的rom bin，0H<del>3EC000H数据全部为FF，都被擦掉了，3EC000H</del>3FFFFFH后面部分段落有数据。这个情况看起来属于MENU升级而不属于上电升级，因为MENU升级的升级方式是全部擦除之后再烧写，上电升级则是擦一点写一点，可是客户端的升级方式是上电升级！不过刚才那片被擦掉boot的板卡不能完全明确是上电升级的结果，也可以认为是MENU升级，因为可能是刚刚好擦到boot就掉电了。具体还得跟踪代码才能知道上电升级究竟是不是擦一点写一点，如果是，擦一点写一点是怎么个擦一点写一点法呢？</p>
<p>最后，开机异常的，基本都是flash里面code被擦掉，至于怎么被擦掉，基本认为是升级过程中掉电造成的（客户亦承认工厂会有停电情况，也不能保证工人操作是否规范），不过除此之外，在生产过程中，是否有其他操作环节会擦掉代码？在向客户工厂和我们工厂了解了生产流程后，感觉可能性不大，但是不能说完全没有可能，我没有完全跟踪所有流程，所以很难没有遗漏，抓到“元凶”有一定难度。至于不良板卡读到的flash数据为啥看起来像是菜单升级？先跟踪一下上电升级流程看看吧！</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
      </tags>
  </entry>
  <entry>
    <title>红外解码之Toshiba协议简单记录</title>
    <url>/2018/08/22/ir-protocol-toshiba/</url>
    <content><![CDATA[<p>之前给创维做红外白平衡调试的几点记录。  </p>
<span id="more"></span>

<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>客户出大货前需要做白平衡调试，上一年还是用串口来调试，今年全球工厂都用红外来调试了，想不清楚为什么要改用红外来代替串口，感觉用串口更可靠一点。以前的做法是直接用测试主机接到我的TV平台，测试主机通过串口直接给TV下值，现在的做法是测试主机通过串口发给一个红外发射器（看了一下是用STM32做的，不同的红外协议使用的发射器还不一样），发射器再把值通过红外的方式发给TV。  </p>
<p>串口调试图例:<br><img src="https://i.loli.net/2018/08/22/5b7cde4b55468.jpg" alt="串口调试图例"><br>红外调试图例:<br><img src="https://i.loli.net/2018/08/22/5b7cde6b27243.jpg" alt="红外调试图例"></p>
<h3 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h3><p><img src="https://i.loli.net/2018/08/22/5b7ce03d4c1d7.jpg" alt="红外白平衡设计规范"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>东芝协议除了引导码和结束位，一帧数据刚好是4个字节，包括两个字节客户码和两个字节的键值。<br><img src="https://i.loli.net/2018/08/22/5b7cf86885007.jpg" alt="frame"><br>而目前代码中对于一帧数据的用法是，客户码2个字节有利用到，但是键值只用了一个字节，反码的那个字节没有利用。原厂的解释是反码部分只是用于验证，目前规格没有利用这部分数据，一直也不影响遥控器使用。<br>我们只要把这4个字节的内容都解出来，就可以实现客户功能</p>
<h3 id="解码算法"><a href="#解码算法" class="headerlink" title="解码算法"></a>解码算法</h3><p>对于“{0x0e0e, 0x11, UI_EVENT_MENU}”这个按键，客户码等于0x0e0e，Keycode等于0x11ee。按下此按键时可以看到如下打印信息：  </p>
<blockquote>
<p> [IR]IR_ISR    IR_len:33    reg0C:0x000010ef    reg54:0x0000e0e1<br> [IR]0    IR:00008877    tmpData:00000000    IR_Custom:00007070<br> [IR]1    IR:443b8000    tmp:000011ee    tmp_Custom:00000e0e<br> [IR]1st reg_single_sts received!!<br> [IR]Single Start Address  Address_  Cmd: 0xe,0xe, 0x11,0xee!!<br> [IR]IR_ISR    IR_len:2    reg0C:0x00000003    reg54:0x00000000<br> [IR]0    IR:00000001    tmpData:00000000    IR_Custom:00000000<br> [IR]1    IR:00008000    tmp:00000080    tmp_Custom:00000000<br> [IR]repeat key received!!<br>_APP_GUIOBJ_PopMsg_OnRelease is called<br> [IR]Single_end received!!  </p>
</blockquote>
<p>而代码中表现如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sisir_toshiba_ParseData</span><span class="params">(UINT8* mmiobase, IR_IOC_IOData* dataBuf)</span></span></span><br><span class="line"><span class="function"></span>{	</span><br><span class="line">	<span class="keyword">volatile</span> UINT32 IR_Data, IR_Custom, IR_bit_len, tmp_data, tmp_Custom, i;</span><br><span class="line">	<span class="keyword">volatile</span> UINT16 tmp_1 = <span class="number">0xffff</span>;</span><br><span class="line">	<span class="keyword">volatile</span> UINT16 tmp_2 = <span class="number">0xffff</span>;</span><br><span class="line">	datBuf = dataBuf;</span><br><span class="line">	IR_Data = irdatas.Value &amp; <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">	IR_Custom = GetMMIO_DWORD(mmiobase, <span class="number">0x54</span>);	<span class="comment">//read from IR decoder recevied custom code</span></span><br><span class="line"></span><br><span class="line">	IR_Custom = IR_Custom &amp; <span class="number">0x1ffff</span>;</span><br><span class="line"></span><br><span class="line">	IR_bit_len = (GetMMIO_DWORD(mmiobase, <span class="number">0x50</span>) &amp; <span class="number">0x3f00</span>) &gt;&gt; <span class="number">8</span>; <span class="comment">//read from IR decoder recevied bit length</span></span><br><span class="line">	DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]IR_ISR\tIR_len:%d\treg0C:0x%08x\treg54:0x%08x\n"</span>, IR_bit_len, IR_Data, IR_Custom);</span><br><span class="line">	IR_Data = IR_Data &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> ( (IR_Custom &amp; <span class="number">0x1</span> ) == <span class="number">1</span> )</span><br><span class="line">	{</span><br><span class="line">		IR_Data = IR_Data | <span class="number">0x8000</span>;</span><br><span class="line">	}</span><br><span class="line">	IR_Custom = IR_Custom &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	tmp_data = <span class="number">0</span>;</span><br><span class="line">	tmp_Custom = <span class="number">0</span>;</span><br><span class="line">	DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]0\tIR:%08x\ttmpData:%08x\tIR_Custom:%08x\n"</span>, IR_Data, tmp_data, IR_Custom);</span><br><span class="line"><span class="comment">//	for ( i=0;i&lt;7;i++ )</span></span><br><span class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++ ) <span class="comment">//fenghl</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> ( IR_Data &amp; <span class="number">0x8000</span> )</span><br><span class="line">		{</span><br><span class="line">			tmp_data = tmp_data | <span class="number">0x8000</span>;</span><br><span class="line">		}</span><br><span class="line">		tmp_data = tmp_data &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		IR_Data = IR_Data &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ( IR_Data &amp; <span class="number">0x8000</span> )</span><br><span class="line">	{</span><br><span class="line">		tmp_data = tmp_data | <span class="number">0x8000</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">	tmp_1 = tmp_data &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	tmp_2 = tmp_data &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	tmp_data = tmp_1 | tmp_2;</span><br><span class="line">	tmp_data = tmp_data &amp; <span class="number">0xffff</span>;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">15</span>; i++ )</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> ( IR_Custom &amp; <span class="number">0x8000</span> )</span><br><span class="line">		{</span><br><span class="line">			tmp_Custom = tmp_Custom | <span class="number">0x8000</span>;</span><br><span class="line">		}</span><br><span class="line">		tmp_Custom = tmp_Custom &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		IR_Custom = IR_Custom &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ( IR_Custom &amp; <span class="number">0x8000</span> )</span><br><span class="line">	{</span><br><span class="line">		tmp_Custom = tmp_Custom | <span class="number">0x8000</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">	tmp_1 = tmp_Custom &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	tmp_2 = tmp_Custom &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	tmp_Custom = tmp_1 | tmp_2;</span><br><span class="line">	tmp_Custom = tmp_Custom &amp; <span class="number">0xffff</span>;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">	DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]1\tIR:%08x\ttmp:%08x\ttmp_Custom:%08x\n"</span>, IR_Data, tmp_data, tmp_Custom);</span><br><span class="line">	<span class="comment">//IR_Data = tmp_data;</span></span><br><span class="line">	<span class="keyword">if</span> ( IR_bit_len == <span class="number">33</span>)</span><br><span class="line">	{	<span class="comment">// Single start</span></span><br><span class="line">		<span class="keyword">if</span> ( (singleKey == <span class="number">1</span>) || (rpt_cnt != <span class="number">0</span>) )</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> ( ir_timer_flag )</span><br><span class="line">			{</span><br><span class="line">				del_timer(&amp;IR_ContiTimer);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> ( singleKey == <span class="number">1</span> )</span><br><span class="line">			{</span><br><span class="line">				DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]2nd reg_single_sts received!!\n"</span>);</span><br><span class="line">				datBuf-&gt;Databuf[datBuf-&gt;Length].ContinueKey = SINGLE_KEY_END;	<span class="comment">// single end</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]reg_single_sts received during repeat!!\n"</span>);</span><br><span class="line">				datBuf-&gt;Databuf[datBuf-&gt;Length].ContinueKey = CONTINUE_KEY_START_END;	<span class="comment">// continue end</span></span><br><span class="line">			}</span><br><span class="line">			datBuf-&gt;Databuf[datBuf-&gt;Length].Command = tmp_irCmd;</span><br><span class="line">			datBuf-&gt;Databuf[datBuf-&gt;Length].Command_ = tmp_irCmd_;</span><br><span class="line">			datBuf-&gt;Databuf[datBuf-&gt;Length].Address = tmp_irAddress;</span><br><span class="line">			datBuf-&gt;Databuf[datBuf-&gt;Length].Address_ = tmp_irAddress_;</span><br><span class="line">			datBuf-&gt;Length++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]1st reg_single_sts received!!\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		tmp_irCmd = dataBuf-&gt;Databuf[dataBuf-&gt;Length].Command = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(tmp_data &gt;&gt; <span class="number">8</span>);</span><br><span class="line">		tmp_irCmd_ = dataBuf-&gt;Databuf[dataBuf-&gt;Length].Command_ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(tmp_data);</span><br><span class="line">		tmp_irAddress = dataBuf-&gt;Databuf[dataBuf-&gt;Length].Address = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(tmp_Custom &gt;&gt; <span class="number">8</span>);</span><br><span class="line">		tmp_irAddress_ = dataBuf-&gt;Databuf[dataBuf-&gt;Length].Address_ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(tmp_Custom);;</span><br><span class="line">		DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]Single Start Address  Address_  Cmd: 0x%x,0x%x, 0x%x,0x%x!!\n"</span>, tmp_irAddress, tmp_irAddress_, tmp_irCmd, tmp_irCmd_);</span><br><span class="line">		dataBuf-&gt;Databuf[dataBuf-&gt;Length].ContinueKey = CONTINUE_KEY_HEAD;</span><br><span class="line">		dataBuf-&gt;Length++;</span><br><span class="line">		singleKey = <span class="number">1</span>;</span><br><span class="line">		rpt_cnt = <span class="number">0</span>;</span><br><span class="line">		init_IR_cont_timer(<span class="number">150</span>);		<span class="comment">// 150 ms</span></span><br><span class="line">		ir_timer_flag = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( IR_bit_len == <span class="number">2</span> )</span><br><span class="line">	{</span><br><span class="line">		DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]repeat key received!!\n"</span>);</span><br><span class="line">		<span class="keyword">if</span> ( ir_timer_flag == <span class="number">1</span> )</span><br><span class="line">		{</span><br><span class="line">			del_timer(&amp;IR_ContiTimer);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> ( rpt_cnt == <span class="number">0xff</span> )</span><br><span class="line">		{</span><br><span class="line">			rpt_cnt = <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		rpt_cnt ++;</span><br><span class="line">		<span class="keyword">if</span> ( (rpt_cnt == <span class="number">4</span>) &amp;&amp; (singleKey == <span class="number">1</span>) )</span><br><span class="line">		{</span><br><span class="line">			singleKey = <span class="number">0</span>;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].Command = tmp_irCmd;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].Command_ = tmp_irCmd_;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].Address = tmp_irAddress;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].Address_= tmp_irAddress_;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].ContinueKey = CONTINUE_KEY_START;</span><br><span class="line">			dataBuf-&gt;Length++;</span><br><span class="line">			DBG_MSG1(DBGCFG_IR, <span class="string">"[IR][IR]Continue_key_start\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		init_IR_cont_timer(<span class="number">150</span>);		<span class="comment">// 150 ms</span></span><br><span class="line">		ir_timer_flag = <span class="number">1</span>;</span><br><span class="line">	} </span><br><span class="line">}</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">其中：  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">irdatas.Value= GetMMIO_DWORD(mmiobase, <span class="number">0x0c</span>);	<span class="comment">//read from IR decoder recevied data</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>Toshiba客户码的高8位和低8位都是一样的？Toshiba一定是一样的,或是反向,硬体那边应该会直接转好反向的,所以到软体这边收到的都会是一样的。  </li>
<li>按遥控器MENU按键（custom code: 0x0E0E, data code: 0x11），示波器抓波形：<br><img src="https://i.loli.net/2018/12/06/5c0915a008d22.jpg" alt="UI_EVENT_MENU"><br>先发0x0E(0b00001110)，再发0x0E(0b00001110)，接着发0x11(0b00010001)，最后发0xEE(0b11101110)，由每个字节的低位开始发，所以示波器上按时间从早到晚（按图上从左到右）计算，得到：  <blockquote>
<p>01110000 01110000 10001000 01110111  </p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>rda</tag>
        <tag>toshiba</tag>
        <tag>remote</tag>
        <tag>ir</tag>
      </tags>
  </entry>
  <entry>
    <title>音频参数简单介绍</title>
    <url>/2018/02/28/rda8501-aq-v2/</url>
    <content><![CDATA[<p>重写8501AQ相关，作为《RDA8501调AQ的几点记录》的补充或修正。</p>
<span id="more"></span>

<h3 id="频响曲线"><a href="#频响曲线" class="headerlink" title="频响曲线"></a>频响曲线</h3><ul>
<li>对频响的理解</li>
</ul>
<blockquote>
<p>频响曲线是在测试电路中，使信号发生器的输出信号频率发生连续变化（即通常说的‘扫频’）并保持幅度不变，在输出端通过示波器或者其他一些记录仪将放大器对于这个连续变化相应的输出电平记录下来，就可以在一个坐标上描绘出一个电平对应频率的曲线。这个坐标的纵坐标是电平，横坐标是频率。纵坐标的单位是dB，横坐标的单位是Hz(或KHz)。为了记录方便，横坐标的标尺为对数型的，纵坐标则是线性的。看频响曲线的时候，不要被曲线的‘平滑’或者‘崎岖’所迷惑，首先要看看坐标的标尺，改变标尺的单位会使曲线看起来差别很大。如果把标尺加大10倍，你大概看到的差不多是一条完美的直线了。</p>
</blockquote>
<blockquote>
<p>频响为什么会影响音质？一方面，人耳有心理声学的掩蔽效应，这个效应简而言之就是不同频率及不同的响度会相互影响，一部分声音的叠加，会导致另一部分声音无法听见。表现到重放系统，如果频响不够平，或者不同频率变化幅度过大，就会导致有部分本来应该听到的内容听不到。这就是细节的丢失。还有一方面，不同频率的频响不同，会导致声音呈现出非原义的表现形式。比如，一段音乐，本来是笛子和古筝交相辉映珠联璧合的，如果笛子那个频段频响过高而古筝那个频段频响较低，就会导致不和谐的情况发生。很恼人的感觉就会出现，本来好听的就不再好听了。</p>
</blockquote>
<blockquote>
<p>在实际的调音中,  频响曲线要根据喇叭的特性进入调整以弥补喇叭自身的不足,  在哪些频点要提升或降低几个dB,  这就要考验音频工程师的功力。</p>
</blockquote>
<ul>
<li><p>工厂菜单调试点</p>
<ul>
<li>EQ Setting<br>  作用：通过BandPass Filter来改变特定频率范围信号强度（目前分为7段）  <ul>
<li>EQ Band：需要改变的EQ band  </li>
<li>Gain：设置EQ band增益，范围-50~50（-12db ~ 12db）  </li>
<li>Q Factor：调整EQ Band的影响频宽（0.1(宽)~5.0(窄)），预设1.5  </li>
<li>Frequency：调整EQ Band的中心频率（20HZ~20KHZ）</li>
</ul>
</li>
<li>PEQ Setting<br>  作用：用于EQ band不满足要求时候，对特定频率进行补偿使用  <ul>
<li>PEQ1：用于设置第一个频率补偿点参数  </li>
<li>Center Freq：设置中心频率  </li>
<li>Q Factory：同上EQ Band Setting中Q Factor  </li>
<li>Gain Step：同上EQ Band Setting中gain  </li>
<li>PEQ2：用于设置第二频率补偿点参数  </li>
<li>PEQ3：用于设置第三频率补偿点参数</li>
</ul>
</li>
</ul>
</li>
<li><p>举例：如图是8503P531板卡搭载RDA3118功放，软件使用默认设定，AP 500mV输入，喇叭功率为1W情况下得到的频响曲线<br>  <img src="https://i.loli.net/2018/02/28/5a9642c0ab9f2.jpg"></p>
</li>
<li><p>调好参数后把数值填充到结构体<strong>g_stSettingDefault_FactoryUser</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/app_data_setting.c</em>）和<strong>g_stAudioSoundModeEqualizerSetting</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/subcustomer_setting.c</em>）</p>
</li>
</ul>
<h3 id="最大声音功率"><a href="#最大声音功率" class="headerlink" title="最大声音功率"></a>最大声音功率</h3><p>指TV音量为最大(100)时，喇叭最大功率。不同客户输入信号标准或许不同，一般使用1KHz/-12dB（500mV）输入。<br>比如调一个4W最大声音功率，步骤如下：</p>
<ol>
<li>令工厂菜单Audio-&gt;AVL-&gt;AVL Mode = Disable，Audio-&gt;Power Limiter-&gt; Sp Attack = 0（PLC用于限制后端输出）；</li>
<li>令工厂菜单Function-&gt;Curve Setting-&gt;Volume Curve-&gt;OSD Volume Value（即TV系统音量）= 100，调Function-&gt;Curve Setting-&gt;Volume Curve-&gt;Vol.Pt.100，使功率达到4W，记录数值用于填回音量曲线表；</li>
<li>调大输入源幅度或继续增大Vol.Pt.100，使输出大于4W；</li>
<li>降低PLC Sp Attack，使输出小于等于4W，记录数值设为默认值；</li>
<li>完成。需要记录的参数是Sp Attack（<strong>PLC_SP_ATTACK</strong>：<em>aps/customer/s2tek/hk8501/adaptable/board_config.h</em>）和Vol.Pt.100（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/subcustomer_setting.h</em>）。</li>
</ol>
<h3 id="音量曲线"><a href="#音量曲线" class="headerlink" title="音量曲线"></a>音量曲线</h3><p>要求制作的音量曲线不可有明显突变，各个通道的曲线尽量接近。<br>步骤：</p>
<ol>
<li>调最大声音功率</li>
<li>依次调Function-&gt;Curve Setting-&gt;Volume Curve-&gt;Vol.Pt各个点，使每个音量点测量得到的功率基本满足客户要求，调试时注意Vol.Pt 值跟OSD Volume Value值匹配；</li>
<li>记录数值写回音量曲线表（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/subcustomer_setting.h</em>）</li>
</ol>
<h3 id="AVL（AVC-输入灵敏度）"><a href="#AVL（AVC-输入灵敏度）" class="headerlink" title="AVL（AVC/输入灵敏度）"></a>AVL（AVC/输入灵敏度）</h3><p>AVL用于控制输入信号的强弱（限制前端IC输入）。</p>
<ol>
<li>工厂菜单内容：  <ul>
<li>AVL Mode：Enable（开启AVL功能），Disable（关闭AVL功能）；AVL功能默认关闭，做输入灵敏度测试的时候先打开AVL功能；Audio -&gt; AVL -&gt; AVL Mode与OSD -&gt; SOUND上的 Auto Volume 功能一致  </li>
<li>Attack Rate：控制压抑以及还原速度（时间）的比例，即开关AVL功能时，功率变化的快慢  </li>
<li>Active Time：超过Limite Level时，每隔Active Time调整一次增益，每次减小0.1dB，直到降到Limite Level  </li>
<li>Limiter：当输入信号超过Limite Level时开始压抑  </li>
<li>Pullup Gain：当信号小于<strong>AGC_PULL_UP_ACTIVE_LEVEL</strong>的时候，会依照Pullup Gain的定义将信号放大（但是放大信号容易失真，建议设置0dB） </li>
</ul>
</li>
<li>调好后记录数据<strong>g_stSettingDefault_FactoryUser</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/app_data_setting.c</em>）</li>
</ol>
<h3 id="高低音"><a href="#高低音" class="headerlink" title="高低音"></a>高低音</h3><p>即OSD -&gt; SOUND上的Treble/Bass，如图，当Treble=100，Bass=100时得到红线AB，当 Treble=0，Bass=0时得到红线CD，增益范围在±6dB~±8dB，每一根线都是Treble和Bass作用叠加的效果图：<br><img src="https://i.loli.net/2018/02/27/5a9515e332cbe.png"><br>调试点主要有A、B、C、D四个，标准是增益范围，即A到C的增益差，B到D的增益差，有以下几种情况：  </p>
<ol>
<li><p>如需使A点向下移，即需减小Bass=100时候的增益（Treble也有作用，只不过低频段主要影响的是Bass，所以这时一般不改动Treble的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f73d1e.png"><br>如需使A点向上移，同理；  </p>
</li>
<li><p>如需使C点向上移，即需增大Bass=0时候的增益（Treble也有作用，只不过低频段主要影响的是Bass，所以这时一般不改动Treble的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f67a2d.png"><br>如需使C点向下移，同理；  </p>
</li>
<li><p>如需使B点向下移，即需减小Treble=100时候的增益（Bass也有作用，只不过高频段主要影响的是Treble，所以这时一般不改动Bass的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f671a4.png"><br>如需使B点向上移，同理；  </p>
</li>
<li><p>如需使D点向上移，即需增大Treble=0时候的增益（Bass也有作用，只不过高频段主要影响的是Treble，所以这时一般不改动Bass的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f6ce43.png"><br>如需使D点向下移，同理。  </p>
</li>
</ol>
<p>调好参数后把数据填入<strong>g_arAudioBassTable</strong> 和 <strong>g_arAudioTrebleTable</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/subcustomer_setting.c</em>）。</p>
<h3 id="声音模式"><a href="#声音模式" class="headerlink" title="声音模式"></a>声音模式</h3><p>即OSD -&gt; SOUND上的四种音效模式，不同的声音模式的差别是高低音的设定的不同。不建议修改OSD -&gt; SOUNG上Treble/Bass的默认值，而是通过调整Bass/Treble曲线满足客户需求。调试方法参考高低音调试。<br>如图是8501某板卡的声音模式曲线：<br><img src="https://i.loli.net/2018/02/27/5a9516de46c4f.png"> </p>
<h3 id="其他1"><a href="#其他1" class="headerlink" title="其他1"></a>其他1</h3><ul>
<li><p>分离度：左、右两个声道相互串扰的程度<br><img src="https://i.loli.net/2018/02/27/5a9516de2dfc1.png">  </p>
</li>
<li><p>增益差：左、右两个声道的信号增益之差<br><img src="https://i.loli.net/2018/02/27/5a9516de414d7.png">  </p>
</li>
<li><p>失真度：表示喇叭对输入信号的还原程度，一般来说，输出功率为 1W 时，失真度须小于等于 1%。输出功率最大时须小于等于 7%<br><img src="https://i.loli.net/2018/02/27/5a9516de38c7e.png">  </p>
</li>
<li><p>信噪比：喇叭播放时，正常声音信号强度与噪声信号强度的比值<br><img src="https://i.loli.net/2018/02/27/5a9516de40ee6.png"></p>
</li>
</ul>
<h3 id="其他2"><a href="#其他2" class="headerlink" title="其他2"></a>其他2</h3><ul>
<li><p>AV Out音频输出幅度：带AV Out端子的板卡需要测试这一项目，修改<strong>g_arAudioAuxiliaryVolumeOffset</strong>（<em>aps/customer/s2tek/hk8501/adaptable/board_config.c</em>）</p>
</li>
<li><p>唇音同步：声音图像同步（AV Sync） Audio–&gt;Misc.-&gt;Lipsync：调整 AV Sync，范围为 -200ms~200ms。修改<strong>g_stSettingDefault_FactoryUser</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/app_data_setting.c</em>）</p>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>测量声音相关参数时需220V交流供电；</li>
<li>明确各个指标的测试方法和测试标准；测量频响前先确认客户是测电频响（测板卡的）还是声频响（测整机的）；</li>
<li>调试顺序：首先调频响；最大声音功率 &gt; 声音曲线 &gt; 失真度；高低音&gt; 声音模式。</li>
</ol>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>rda</tag>
        <tag>audio</tag>
        <tag>aq</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下搭建FTP服务器</title>
    <url>/2018/01/31/ftp-server/</url>
    <content><![CDATA[<p>前前后后配了好几次FTP Server，每次都要重新开始的样子各种百度谷歌。先记一次留着下次用。</p>
<span id="more"></span>

<p>环境：Ubuntu 16.04 i386</p>
<h3 id="安装软件和添加用户"><a href="#安装软件和添加用户" class="headerlink" title="安装软件和添加用户"></a>安装软件和添加用户</h3><ol>
<li>sudo apt-get install vsftpd //安装vsftpd</li>
<li>vsftpd -version //查看vsftpd版本</li>
<li>sudo mkdir /home/ftp_root -p //创建FTP服务器工作目录ftp_root //注意目录权限</li>
<li>sudo useradd -d /home/ftp_root -s /bin/bash xxx //新建FTP用户xxx</li>
<li>sudo passwd xxx //为新建的FTP用户xxx设置密码 //可用cat /etc/passwd可以查看当前系统用户</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li><p>vim /etc/vsftpd.conf  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">listen=YES</span><br><span class="line"></span><br><span class="line">listen_ipv6=NO</span><br><span class="line"></span><br><span class="line">anonymous_enable=YES</span><br><span class="line">anon_root=/home/ftp_root/ftp_anonymous</span><br><span class="line"></span><br><span class="line">local_enable=YES</span><br><span class="line"></span><br><span class="line">write_enable=YES</span><br><span class="line"></span><br><span class="line">local_root=/home/ftp_root</span><br><span class="line"></span><br><span class="line">local_umask=022</span><br><span class="line"></span><br><span class="line">dirmessage_enable=YES</span><br><span class="line"></span><br><span class="line">use_localtime=YES</span><br><span class="line"></span><br><span class="line">xferlog_enable=YES</span><br><span class="line"></span><br><span class="line">connect_from_port_20=YES</span><br><span class="line"></span><br><span class="line">xferlog_file=/var/<span class="built_in">log</span>/vsftpd.log</span><br><span class="line"></span><br><span class="line">ftpd_banner=Welcome to blah FTP service.</span><br><span class="line"></span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"></span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line"></span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line"></span><br><span class="line"><span class="comment">#pam_service_name=vsftpd</span></span><br><span class="line">pam_service_name=ftp</span><br><span class="line"></span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line"></span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_deny=NO</span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>vim /etc/vsftpd.user_list</p>
</li>
<li><p>vim /etc/vsftpd.chroot_list</p>
</li>
<li><p>其他</p>
</li>
</ol>
<ul>
<li>防火墙：直接关闭或者开放端口</li>
<li>SeLinux：关闭</li>
<li>添加开机自启动</li>
</ul>
<h3 id="启动vsftpd服务"><a href="#启动vsftpd服务" class="headerlink" title="启动vsftpd服务"></a>启动vsftpd服务</h3><p>sudo service vsftpd start</p>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>方式有很多种，比如ssh、浏览器、Windows资源管理器添加FTP站点、FTP客户端工具等都可以。<br>我在Windows下用客户端工具FileZilla，好处是文件共享方便的同时是能直观看到log信息。</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol>
<li>启动vsftpd服务后查看状态，发现启动失败</li>
</ol>
<blockquote>
<p>Active: failed (Result: exit-code)<br>(code=exited, status=2)  </p>
</blockquote>
<p>原因：不明<br>解决方法：将 vsftpd.conf 里面的 listen 从 NO 改成 YES  </p>
<ol start="2">
<li>331和530错误，且匿名用户能登陆，但是用户账户不能登陆</li>
</ol>
<blockquote>
<p>331 Please specify the password.<br>530 Logiin incorrect.  </p>
</blockquote>
<p>原因：“By default vsFTPd uses the file /etc/pam.d/vsftpd. This file by default requires FTP users to have a shell listed in /etc/shells and requires them not to be listed in /etc/ftpusers. If you check those 2 things your probably find what the problem is.”<br>解决方法：将 vsftpd.conf 里面的 pam_service_name 从 vsftpd 改成 ftp  </p>
<ol start="3">
<li>500错误</li>
</ol>
<blockquote>
<p>500 OOPS: cannot change directory  </p>
</blockquote>
<p>原因：未明，权限问题？普通用户不能进入到 /root 目录？<br>解决方法：修改 /etc/passwd ，把FTP工作目录从 /root/ftp_root 改为 /home/ftp_root  </p>
<ol start="4">
<li>root用户能上传文件，但是xxx用户不行</li>
</ol>
<blockquote>
<p>227 Entering Passive Mode<br>553 Could not create file  </p>
</blockquote>
<p>原因：未明<br>解决方法：无解</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li><a href="https://blog.csdn.net/danson_yang/article/details/65629948">Linux useradd 与 adduser的区别， /sbin/nologin 与 /bin/bash</a></li>
<li>主动模式与被动模式</li>
</ol>
<ul>
<li><a href="https://www.cnblogs.com/ShaYeBlog/p/5897303.html">参考链接1</a></li>
<li><a href="https://www.360doc.com/content/14/1225/15/15077656_435676206.shtml">参考链接2</a></li>
<li><a href="https://blog.csdn.net/huanggang028/article/details/41248663">参考链接3</a></li>
<li><a href="https://blog.csdn.net/u010154760/article/details/45458219">参考链接4</a></li>
<li><a href="https://www.cnblogs.com/xiaohh/p/4789813.html">参考链接5</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>纯手动吹风机</title>
    <url>/2018/01/22/lmao/</url>
    <content><![CDATA[<p>精彩段子收集。</p>
<span id="more"></span>

<h4 id="银教授"><a href="#银教授" class="headerlink" title="银教授"></a><a href="https://weibo.com/qiaoyinrong">银教授</a></h4><ul>
<li>想起当年求婚的画面，现在还历历在目，当时是女友生日，她吃着蛋糕，突然吃到一粒钻戒，随机害羞地对我说：“我愿意嫁给你。”后来我们就结婚了，毕竟，我无法拒绝一个自己掏钱买戒指藏在蛋糕里的女孩</li>
<li>我在佛前苦苦求了几千年，只想问佛一个问题：我在佛前苦苦求了几千年？</li>
<li>我在佛前苦苦求了几千年，后面一个排队的拍拍我的肩膀：“哥你求完没？”</li>
<li>“你必须要很努力，才能看起来毫不费力。” “那我为什么不直接毫不费力呢？”</li>
<li>这些年我一直在退步，幸运的是，我背对着目标。</li>
<li>老师：你为什么迟到？我：正义都会迟到，我就不能了？</li>
<li>面试官：“说说你为什么擅长这项工作？”我：“说实话，我不擅长。” “那你擅长什么？” “擅长说实话。”  </li>
<li>有一天我求佛了，偶然发现这个佛是假的，是仿佛。  </li>
<li>刚看完消息就被对方撤回，有一种不小心看到对方走光的感觉，只好假装没看到。  </li>
<li>有时想无故请人吃饭，给对方一种困惑的感觉。  </li>
<li>单身汉给宠物花钱，就像恋爱的人给对象花钱，爱意总归要有个去向。  </li>
</ul>
<h4 id="那个洞是他的家"><a href="#那个洞是他的家" class="headerlink" title="那个洞是他的家"></a><a href="https://weibo.com/u/5187109870">那个洞是他的家</a></h4><ul>
<li>动物学校开课，大象迟到了。老师生气地说：“你为什么现在才来？干脆别来算了。”大象说：“真象可能会迟到，但永远不会缺席。”</li>
</ul>
<h4 id="小驴吃火烧"><a href="#小驴吃火烧" class="headerlink" title="小驴吃火烧"></a><a href="https://weibo.com/u/1046610712">小驴吃火烧</a></h4><ul>
<li>我欺负同桌后觉得很开心，换位思考了一下，我坐到他后面，欺负他一样很开心。</li>
</ul>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>lmao</tag>
      </tags>
  </entry>
  <entry>
    <title>搭个梯子</title>
    <url>/2018/01/03/fanqiang/</url>
    <content><![CDATA[<p>没有谷歌是在很不方便，搜索，玩游戏，备份相片、通讯录什么的都很麻烦。</p>
<span id="more"></span>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><ul>
<li><p>购买VPS<br>  百度了一圈，觉得比较划算的还是Bandwagon或者Vultr（Vultr可付支付宝，搬瓦工没了解）。我用的是Vultr，直接充钱，最低充10美元。最低套餐是2.5美元/月，这个比较缺货。好像日本新加坡的主机比较热门，不过也听说容易被墙。当时买2.5的时候只有美国NYC和迈阿密有售。我选了个迈阿密的，至于体验如何？对于YouTube没有太大的需求，用一加3T联通卡，ShadowsocksAPK测试，Ping值一般250~400ms。如果你也选择Vultr，可以点击我的<a href="https://www.vultr.com/?ref=7243025">邀请链接</a>，这样大家都可以得到10刀的优惠。</p>
</li>
<li><p>部署云主机<br>  选VC2，选服务器，选系统。我选的是 Ubuntu 16.04 i386，其他默认，创建服务器。这样就可以得到服务器IP，用户名和密码。</p>
</li>
</ul>
<h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><ul>
<li><p>安装Shadowsocks服务端<br>  先SSH登陆服务器，然后安装Shadowsocks。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install python</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install python-setuptools</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install python-pip</span><br><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>配置Shadowsocks<br>  vim /etc/shadowsocks/config.json</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"你的服务器IP地址"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:端口号,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"你的Shadowsocks密码"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>启动Shadowsocks</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line">sudo ssserver -c <span class="regexp">/etc/</span>shadowsocks.json -d start</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>把Shadowsocks加入开机启动项<br>  编辑/etc/rc.local文件</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>rc.local</span><br></pre></td></tr></tbody></table></figure>
<p>  在 exit 0 这一行的上边加入如下内容</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>ssserver –c <span class="regexp">/etc/</span>shadowsocks.json</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="上网冲浪"><a href="#上网冲浪" class="headerlink" title="上网冲浪"></a>上网冲浪</h2><p>Shadowsocks软件下载安装与登录即可，至此翻墙工作基本完成。<br>下载地址：<br><a href="https://github.com/shadowsocks/shadowsocks-android">Android</a><br><a href="https://github.com/shadowsocks/shadowsocks-windows">windows</a></p>
<h2 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h2><p>曾试过用得好好的突然就挂了，服务器能连上也能Ping通，换了个端口号重启就行了。端口冲突吗？</p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitstream or PCM？</title>
    <url>/2017/09/27/bitstream-or-pcm/</url>
    <content><![CDATA[<p>电视上同轴输出的做法。  </p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>USB通道下播放声音格式为AAC的视频文件，同轴输出设置为Auto，功放没有声音，设置成PCM，有声音。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><p>Auto/PCM的做法是怎样的？Auto的做法这里其实就是Bitstream，PCM就是PCM。<br>Bitstream与PCM差别在哪？如何取舍？为什么一个有声音，一个没有？</p>
<h3 id="讨论精选"><a href="#讨论精选" class="headerlink" title="讨论精选"></a>讨论精选</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>Basically,<br>Bitstream - will send the raw digital audio without processing out of the DVD player so your receiver can process<br>PCM - the player will convert everything to and output as 2 channel PCM<br>So if you want your receiver to process DD and DTS multichannel tracks then you must set the player to Bitstream<br>This PCM/Bitstream option doesn’t effect the players analogue outputs. This is the reason why your analogue outs sounded better than your digital out when its set to PCM.</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>If you select PCM the bluray player will do the decoding and send the sound to the amp. Bitstream will send it in raw format and leave the amp to decode it. PCM would be your safest bet so all audio formats work, but maybe select bitstream and see what happens…</p>
<h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><p><a href="https://www.lifewire.com/what-is-pcm-1846928">链接1</a> <a href="https://www.lifewire.com/blu-ray-audio-bitstream-vs-pcm-1846396">链接2</a><br>The PCM Option<br>If you set the Blu-ray Disc player to output audio as PCM, the player will perform the audio decoding of all Dolby/Dolby TrueHD and DTS/DTS-HD Master Audio - related soundtracks internally and send the decoded audio signal in uncompressed form to your home theater receiver. As a result, your home theater receiver will not have to perform any additional audio decoding before the audio is sent through the amplifier section and the speakers. With this option, the home theater receiver will display the term “PCM” on its front panel display.</p>
<p>The Bitstream Option<br>If you select Bitstream as the HDMI audio output setting for your Blu-ray player, the player will bypass its own internal Dolby and DTS audio decoders and send the undecoded signal to your HDMI-connected home theater receiver.</p>
<p>With this setting, the home theater receiver will do all the audio decoding of the incoming signal. As a result, in this case, the receiver will display Dolby, Dolby TrueHD, DTS, DTS-HD Master Audio, Dolby Atmos, DTS:X, etc…on its front panel display depending on which type of bitstream signal is being decoded.</p>
<p>NOTE: The Dolby Atmos and DTS:X surround sound formats are only available from a Blu-ray Disc player via the Bitstream setting option. There are no Blu-ray Disc players that can decode these formats internally and to PCM and pass that on to a home theater receiver.</p>
<h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4><p>what is the difference between connecting a dvd player to amp, having the output mode of dvd player set to bitstream and pcm? how difference these setting will influence the output of sound?</p>
<p><strong>Answer 1:</strong><br>Bitstream is digital output to the amp, it means either optical or coaxial output should be connected to the receiver. The digital to analog conversion will be done by the receiver.</p>
<p>PCM is analog output. Analog output should be connected to the receiver. For DTS etc, your player should have a dts decoder and the 5 channel output should be connected to the receiver’s external decoder inputs.</p>
<p><strong>Answer 2:</strong><br>Doors, you information is only partially correct. PCM is not analog, but digital. Let me explain. </p>
<p>There are lots of confusion between PCM/LPCM and bitstream. This confusion is there because the two refer to completely different things - one is a encoding and storage methodology, while the other is just a transport mechanism. </p>
<p>Pulse Code Modulation or PCM is a digital form of representing analog signals. PCM has two step process - one is called Modulation and other is called Demodulation. In Modulation, an analog signal is sampled at regular intervals and quantisized. For each sample, an available value is chosen using an advanced algorithm. This creates a fully discreet digital signal that can be easily stored and processed. In demodulation, the modulation process is reversed and a high frequency analog signal is created. This is them sent though a filter to remove, what we in audio call, jitter. Modulation is what we know as Analog-to-Digital conversion, and demodulation is what we call Digital-to-Analog conversion. Both your audio CD as well as your DVD store digital data that have been created using PCM. </p>
<p>For a long time, because of the small spaces available for storage (CD, DVD, etc) as well narrow bandwidths available for data transmission, digital data has been stored in lossy compressed form for both audio and video. Such compression always have some loss of data. </p>
<p>Using optical or co-axial connections, these compressed digital data is streamed across from one point to another. Since a bit is the most basic form of digital data, this way of transmission is called bitstreaming. Digital data is streamed using synchronous or asynchronous modes. In computer for example, TCP uses asynchronous mode for data transportation. </p>
<p>Most data streams are sent as packets or frames of data and contain the following information:</p>
<ul>
<li>header</li>
<li>error check</li>
<li>audio or video data</li>
<li>ancillary data</li>
</ul>
<p>The header of each packet contains general information such as the CODEC, sampling frequency, number of channels, CRC protection, etc. On the receiving side, the data is validated for accuracy, and once validated, the actual data is processed as needed.</p>
<p>Over the last few years two things have happened. Storage space has increased, and new transmission methodology have been discovered that have a much higher bandwidth. HDMI 1.3, for example, can carry data at a bandwidth of 340 MHz which equals to 10.2 giga bits per second. In addition HDMI also allows multiplexing of multi data streams over a single physical link. A 192 kHz sampling frequency equates to just 6.144 gigabits per second of transmission speeds. </p>
<p>Now suddenly you could store data with lossless compression, and also transmit multiple channels of data from one place to another at very high speed. </p>
<p>LPCM is a term that is loosely used for both encoding and storage, and of decoding and transmission of lossless video/audio data. LPCM sampling resolutions can go up to 24 bits per sample, while PCM’s resolution is a max of 16 bits. LPCM is generally used in conjunction with WAV files in computers (also FLAC, AIFF etc), and with Blu-Ray, TrueHD, DTS-HD </p>
<p>PCM and bitstream is used in conjunction with traditional formats such as 2 channel stereo, Dolby Digital, DTS, etc. </p>
<p>The question is which one should I use? </p>
<p>If you are using coaxial or optical digital connection, you must use bitstream or what some players call RAW. Many DVD players will have PCM set as default. PCM will not send Dolby Digital or DTS as multi channel sound, but as Stereo PCM through these connections,</p>
<p>HD Audio such as TrueHD, DTS HD etc are stored in compressed form and cannot be transmitted as such. A high end DVD player will, thus, extract such sound from the disc, decode it, and mix it into muti channel PCM. This is then transmitted through HDMI 1.1 or higher connections. You have to ensure that your receiver not only has an HDMI input but should also have the ability to handle the multichannel PCM signal. </p>
<p>Cheers  </p>
<h4 id="五"><a href="#五" class="headerlink" title="五"></a>五</h4><p><a href="https://www.cnblogs.com/lihaiping/p/LPCM.html">拓展1</a> <a href="https://blog.chinaunix.net/uid-9688646-id-1998399.html">拓展2</a>  </p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>讨论部分，网友的回答已经非常明了。  </p>
<ul>
<li>同轴选择Bitstream输出，则TV不做decode，直接把raw data给到功放，功放直接处理raw，比如Dolby的话，按功放面板上info，切到Audio decoder就会看到Dolby；同轴输出选择PCM输出，则TV给到功放的是已经经过处理后得到的PCM，功放info显示的是PCM。我的功放型号是雅马哈RX377。</li>
<li>对于好一点的功放，选Bitstream，听说音效听起来很好，否则保险起见，选PCM，因为大多数的功放都能解PCM。</li>
<li>同轴输出设置为Auto时没声音，是因为功放不支持AAC吗？查看<a href="https://www.yamaha.com.cn/images/products/audio-visual/aduio-family/av-receiver/RX-V377/RX-V377.pdf">功放说明书</a>，没看懂支持不支持AAC。但是用功放直接播放USB里的AAC音乐文件，Audio Decoder显示为AAC，应该能说明AAC是支持的。</li>
<li>播放AAC音源没有声音的问题，原厂处理如下：[what]when audio = aac, spdif select AUTO, AV receiver doesn’t output，[why]AV receiver don’t support AAC raw data，[how]when audio = aac, spdif select AUTO, force SPDIF output PCM。我认为这个处理方法还有待商榷，因为AV receiver看起来是支持AAC的，所以当同轴输出设置为Bitstream时功放无声音的问题，软件层面应该还有更合理的改善的地方，而不是简单地“force SPDIF output PCM”。出于对比方案的做法参考和出货的紧迫时间，就这么处理了！</li>
<li>还有一个问题，功放插上U盘，播放U盘里面的音乐的时候，功放info可正确输出音乐的音频格式（试过了PCM、AAC、WMA），但是视频却不能（这里用TV多媒体通道播放视频，同轴输出到功放，把同轴输出设置为Auto时，info看到的东西除了PCM就是Dolby Digital，我用一个音频格式为wma的视频（这个视频是用格式工厂转码得到的，但是用MediaInfo对比这个视频的音频参数和之前测试的wma音乐的音频参数，文件格式/编码设置ID/编码设置ID/信息都一致）试了，info显示的是PCM），这是功放本身的做法问题吗？</li>
</ul>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>pcm</tag>
        <tag>coax</tag>
        <tag>dolby</tag>
      </tags>
  </entry>
  <entry>
    <title>EDID</title>
    <url>/2017/09/04/edid/</url>
    <content><![CDATA[<p>(这特么写的啥？<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>20200910)<br>还有一些一直没搞懂，先记一部分下来。</p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>PC：在任意分辨率下，连接电脑主机GeForce GTX750，显示Unsupported。多次实验。主机重启后画面能正常出来，但仍然无法读取EDID。测试了4台主机（其他3台显卡型号不确定），只有一台正常。</p>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>搜集到以下资讯：</p>
<blockquote>
<ul>
<li>显示设备生产由于切割成本等原因都是1366X768，而视频讯号都是1360X768</li>
<li>知乎问题：《为什么说 1366 * 768 是「反人类」的分辨率？》<br>回答1：这个分辨率，横向不能被4整除。在一些情况下不适合使用。影响是，这个分辨率单行扫描不能32位字节对齐。而我们知道主流机器的int是32位（64位机的int也同样是32位）。这会导致经常需要为它额外留空。所以你会看到在某些场合只能用 1360 * 768 代替这个1366分辨率。<br>回答2：16:9屏幕是成本竞争的产物：细心的朋友会发现16:9的屏幕面积要比16：10的屏幕小0.1英寸。这0.1英寸看起来不多，其实它的面积并不小，大规模的切割母版时能多切几块。如果相同尺寸的母版按照14.1英寸能切出30块，那么14.0英寸的屏幕或许就能切出40块。如果总成本是6万元，那么16:10的屏幕是2000元一块，而16：9的屏幕就是1500元一块。<br>回答3：因为分辨率太小，强行16:9，为了面板切割的更多，导致高度只有768，网页竖着显示不了多少内容。而16:9作为看电影的最佳比例，1366 * 768 又远达不到1080P。最终为了赚钱，市面上全都是 1366 * 768，导致大量的反感。<br>回答4：1366 * 768 是对成本妥协的产物，在切割液晶板时最经济。<br>回答5：切割效率最高。每一代液晶面板都有自己最大效率的分辨率，比例，以及尺寸大小，以尽量减少浪费为前提的切割。</li>
<li>早期很多显卡里面都没有设置 1366 * 768，所以早期的显卡都没法识别 1366 * 768，只有 1360 * 768。</li>
<li>1366x768 appears most commonly on monitors and laptop displays. I’ve seen 1360x768 creep its way onto cheap ass TVs though. My older TV’s native resolution, for example, is 1360x768.  Nevertheless, I’d go for 1360x768 if you wanted 16:9 content, as 1366x768 cannot display anything at a native 16:9 without rounding, while 1360x768 can (at 1360x765; if you check YouTube and it displaying a video when your fullscreen resolution is 1360x768, you’ll see).</li>
<li>At the time the first computer wide-screens became popular, the usual resolution on 4:3 panels was 1024×768 (the XGA display standard). For simplicity and backward compatibility, the XGA resolution was kept as a basis when making the WXGA resolution (so that XGA graphics could be easily displayed on WXGA screens).<br>Just extending the width and keeping the same height was also simpler technically because you would only have to tweak the horizontal refresh rate timing to achieve it. However, the standard aspect ratio for wide displays was 16:9, which is not possible with 768 pixels, so the nearest value was chosen, 1366×768.<br>WXGA can also refer to a 1360×768 resolution (and some others that are less common), which was made to reduce costs in integrated circuits. 1366×768 8-bit pixels would take just above 1-MiB to be stored (1024.5KiB), so that would not fit into an 8-Mbit memory chip and you would have to have a 16-Mbit memory chip just to store a few pixels. That is why something a bit lower that 1366 was chosen. Why 1360? Because you can divide it by 8 (or even 16) which is far simpler to handle when processing graphics (and could bring to optimized algorithms).</li>
<li>1366×768 8-bit pixels is just above 1MiB (by 512 bytes), so it does not fit into an 8Mbit memory chip.<br>1360 is also divisible with both 8 and 16, enabling simplified and optimized algorithms for processing graphics.</li>
</ul>
</blockquote>
<p>总结下来就是：</p>
<ul>
<li>1366 * 768 是硬件分辨率，1360 * 768 是VESA规定的显示标准,如要输出1366，需要驱动或特别的软件支持</li>
<li>笔记本用 1366 * 768，切割效率高，节省面板成本</li>
<li>1366 * 768 更接近16:9，而 1360 * 768 则为16:10</li>
</ul>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul>
<li>EDID最佳分辨率是做 1366 * 768 还是 1360 * 768 ？ – 应该还是 1366 * 768 ？毕竟跟屏匹配才是最佳？</li>
<li>出货的屏是 1366 * 768，如果EDID最佳分辨率做 1360 * 768，能做点对点吗？ – 即使第一详细时序是 1360 * 768，如果TV软件有 1366 * 768 的支持，就可以点对点，比如在第二详细时序添加 1366 * 768？</li>
<li>为什么最佳分辨率写了 1360 * 768，屏显还是 1366 * 768？ – 在Win7控制面板里看到的分辨率是 1360 * 768，通过edidw2k工具抓取的EDID也是最佳分辨率 1360 * 768，偏偏屏显上是 1366 * 768。拿竞争对手C的板子做个对比，发现他们的EDID写的是 1366 * 768，但是屏显又是 1360 * 768？未解之谜。</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>后来也是用同样的软件测试，画面能正常出来，EDID也能读到，使用相同的主机，相同的线材，相同的软件，相同的板卡。测试前有做工厂复位。<br>为什么测试那边会出现那样的情况，本来看到“主机重启后画面能正常出来，但仍然无法读取EDID。”，觉得很有可能是电脑的问题了（因为我的笔记本也很难读，台式机比较容易），但是升完级没画面，需要重启才有，这个情况让人困惑。</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>edid</tag>
      </tags>
  </entry>
  <entry>
    <title>RDA8501调AQ的几点记录</title>
    <url>/2017/08/24/rda8501-aq/</url>
    <content><![CDATA[<p>记录一次调音频经历，作为在客户端工作的总结。</p>
<span id="more"></span>

<h2 id="最大声音功率"><a href="#最大声音功率" class="headerlink" title="最大声音功率"></a>最大声音功率</h2><p>指音量为100时，喇叭能支持的最大功率，不同的板型使用的功放不同，喇叭不同，最大功率有差别。每个客户输入信号标准不同，一般使用1KHz/-12dB输入。</p>
<ul>
<li>Audio -&gt; Power Limiter<br>PLC: Enable/Disable，用于Audio输出最大值限制<br>Sp Attack: 喇叭输出最大值<br>Hp Attack: 耳机输出最大值（仅限IC  Headphone Output）<br>Lo Attack: Line Out输出最大值</li>
<li>比如调4W的喇叭：</li>
</ul>
<ol>
<li>把音量调至100；</li>
<li>关闭 Audio -&gt; Power Limit –&gt; PLC（PLC主要起限制后端放大的作用）；</li>
<li>调Function –&gt; Curve Setting -&gt; Volume Curve -&gt; Vol.Pt.100，使功率达到4W；</li>
<li>开启PLC，测量此刻的功率值  ，若功率小于4W，增大Audio -&gt; Power Limit –&gt; SP Attack值（趋向于0(0dB)），直到功率等于4W，若功率大于4W，减小SP Attack值（趋向于-240(-30dB)），直到功率等于4W；</li>
<li>增大Vol.Pt.100，测量此刻的功率，若功率稳定在4W，则Vol.Pt.100和SP Attack值可确定，记录Vol.Pt.100值和SP Attack值，若 功率大于4W，说明PLC限幅不够，继续减小SP Attack值，直到功率等于4W ；</li>
<li>重复步骤5进行微调，直到无论怎么增大Vol.Pt.100值，功率都能稳定在4W。若无法准确到4W，可选最接近4W的功率作为最大功率，假设得到Vol.Pt.100值为A；</li>
<li>增大输入。比如换1KHz/-10dB作为输入，如果此刻功率大于4W，假设功率为B（B&gt;4W），则继续减小SP Attack值（按最小单位微调）到C，量的此刻功率为D（此时D应该小于等于4W），则折中选择一个最接近4W的功率值（B或D），如果选择B值，则步骤6得到的Vol.Pt.100 和SP Attack为最优解，如果选择 D 值，有可能Vol.Pt.100 = A时候量到的功率与A减小几个单位后量到的功率一样，这个时候还需减小 A 值（原因是 PLC 限制得太多了）；</li>
<li>记录Vol.Pt.100值【subcustomer_setting.h】和SP Attack【board_config.h】。<br><img src="https://i.loli.net/2018/02/27/5a9513cb88b4b.png"></li>
</ol>
<h2 id="音量曲线"><a href="#音量曲线" class="headerlink" title="音量曲线"></a>音量曲线</h2><p>  指电视机各个音量点的功率，因客户要求而异。要求制作音量曲线不可有明显突变，各个通道的曲线尽量接近。每个客户输入信号标准不同，一般使用1KHz/-12dB输入。步骤如下：</p>
<ol>
<li>调最大功率</li>
<li>依次调Function –&gt; Curve Setting -&gt; Volume Curve -&gt; Vol.Pt各个点，使每个音量点测量得到的功率基本满足客户要求，调试时注意Vol.Pt 值跟Function –&gt; Curve Setting -&gt; Volume Curve -&gt; OSD Volume Value值匹配；</li>
<li>记录每个Vol.Pt 值【subcustomer_setting.h】。</li>
</ol>
<h2 id="频响曲线"><a href="#频响曲线" class="headerlink" title="频响曲线"></a>频响曲线</h2><p>指音响系统对输入信号的反应和辨别能力。比如一台好的音响，他的频率响应范围是20赫兹到20000赫兹。那么当一个包含有20-20000赫兹的音频信号的音乐进来之后，它就会有足够深的低频下潜和非常出色的高频表现；假如你把这个信号输入给一台比较烂的音响（我们假设它只有100-12000的频率响应范围），那么比这个范围低或者高的信号音响就无法处理和播放，你就会感觉这个音乐很窄，缺乏表现力。当然频率响应还有一些别的必须要参考的标准，比如在某个频段，响应的情况如何，这里略过。（百度）。<br>参考Mstar V56方案频响曲线图：<br><img src="https://i.loli.net/2018/02/27/5a9515719cdc8.png"><br>与V56相比，8501方案的频响曲线低频段部分（20Hz~150Hz）没有作抑制，如不能满足客户要求，可自行调整频响曲线。</p>
<p>频响曲线涉及的调试内容是Audio -&gt; EQ和Audio -&gt; PEQ，调频响曲线一般先调EQ，再通过PEQ进行微调。</p>
<ul>
<li>EQ 主要作用于特定频率范围的信号强度，当需要调节频率范围内的曲线趋势时，可以调EQ，EQ在工厂菜单里可供调试的项目有EQ Band、Gain、Frequency、Q Factor。<ul>
<li>EQ Band: 目前有7段</li>
<li>Gain: 设置EQ Band的增益，范围 -50<del>50（-12dB</del>12dB）</li>
<li>Frequency: 调节EQ band 的中心频率，范围 20Hz~20KHz</li>
<li>Q Factor: 调节EQ band 的影响频宽 0.1(宽)~5.0(窄)</li>
</ul>
</li>
<li>PEQ用于EQ Band不满足要求时，对特定频率进行补偿使用。<ul>
<li>Center Frequency: 设置中心频率</li>
<li>Q Factor: 调节EQ band 的影响频宽 0.1(宽)~5.0(窄)</li>
<li>Gain Step: 设置EQ Band的增益，范围 -50<del>50（-12dB</del>12dB）<br>【app_data_setting.c、subcustomer_setting.c】</li>
</ul>
</li>
</ul>
<h2 id="AVL（即AVC、输入灵敏度）"><a href="#AVL（即AVC、输入灵敏度）" class="headerlink" title="AVL（即AVC、输入灵敏度）"></a>AVL（即AVC、输入灵敏度）</h2><p>客户一般有要求输入幅度范围下把声音功率限定在特定功率内的指标，AVL用于控制输入信号的强弱（限制芯片输入）。</p>
<ul>
<li>AVL Mode：Enable（开启AVL功能），Disable（关闭AVL功能）；AVL功能默认关闭，做输入灵敏度测试的时候先打开AVL功能；Audio -&gt; AVL -&gt; AVL Mode与OSD -&gt; SOUND上的 Auto Volume 功能一致</li>
<li>Attack Rate：控制压抑以及还原速度（时间）的比例</li>
<li>Active Time：超过Limite Level时，每隔Active Time调整一次增益，每次减小0.1dB，直到降到Limite Level</li>
<li>Limiter：当输入信号超过Limite Level时开始压抑</li>
<li>Pullup Gain：当信号小于-12dB时候，会依照Pullup Gain的定义将信号放大（但是放大信号容易失真，建议设置0dB）<br>【app_data_setting.c】</li>
</ul>
<p>下图为V56方案AVL曲线图，蓝线为Disable AVL时候的曲线，黄线为Enable AVL时候的曲线：<br><img src="https://i.loli.net/2018/02/27/5a95159ee5bbe.png"><br>与V56相比，HK8501方案AVL曲线没有过零点，输入为0时，仍有3mV~4mV的输出，目前无解。如下图：<br><img src="https://i.loli.net/2018/02/27/5a9515bfe2d90.png"></p>
<h2 id="高低音"><a href="#高低音" class="headerlink" title="高低音"></a>高低音</h2><p>即OSD -&gt; SOUND上的Treble/Bass，不同客户对声音模式的要求可能不同，一般是增益范围的差别。下图较高的红线（AB线）对应Treble=100，Bass=100，较低的红线（CD线）对应Treble=0，Bass=0，增益范围在±6dB~±8dB，每一根线都是Treble和Bass作用叠加的效果图：<br><img src="https://i.loli.net/2018/02/27/5a9515e332cbe.png">  </p>
<p>调试点主要有A、B、C、D四个，标准是增益范围，即A到C的增益差，B到D的增益差，有以下几种情况：</p>
<ol>
<li>如需使A点向下移，即需减小Bass=100时候的增益（Treble也有作用，只不过低频段主要影响的是Bass，所以这时一般不改动Treble的增益）,<br><img src="https://i.loli.net/2018/02/27/5a95166f73d1e.png"><br>如需使A点向上移，同理；</li>
<li>如需使C点向上移，即需增大Bass=0时候的增益（Treble也有作用，只不过低频段主要影响的是Bass，所以这时一般不改动Treble的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f67a2d.png"><br>如需使C点向下移，同理；</li>
<li>如需使B点向下移，即需减小Treble=100时候的增益（Bass也有作用，只不过高频段主要影响的是Treble，所以这时一般不改动Bass的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f671a4.png"><br>如需使B点向上移，同理；</li>
<li>如需使D点向上移，即需增大Treble=0时候的增益（Bass也有作用，只不过高频段主要影响的是Treble，所以这时一般不改动Bass的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f6ce43.png"><br>如需使D点向下移，同理.</li>
</ol>
<p>高低音的修改内容主要是Treble/Bass曲线表【subcustomer_setting.c】。</p>
<h2 id="声音模式"><a href="#声音模式" class="headerlink" title="声音模式"></a>声音模式</h2><p>即OSD -&gt; SOUND上的四种音效模式，不同的声音模式是突出不同的声音特点，有的突出低音，有的突出高音，有的是突出人声部分。参考下图：<br><img src="https://i.loli.net/2018/02/27/5a9516de46c4f.png"><br>不同的音效模式Treble值和Bass值不同，所以增益不同，可以修改OSD -&gt; SOUNG上Treble/Bass的默认值【app_data_setting.c】，在客户对OSD -&gt; SOUNG上Treble/Bass的默认值有要求的情况下，只能调整Treble/Bass曲线【subcustomer_setting.c】。</p>
<h2 id="分离度"><a href="#分离度" class="headerlink" title="分离度"></a>分离度</h2><p>通道间串音分离度测量的是其他通道保持输入信号的情况下对本通道的影响。<br><img src="https://i.loli.net/2018/02/27/5a9516de2dfc1.png"></p>
<h2 id="失真度"><a href="#失真度" class="headerlink" title="失真度"></a>失真度</h2><p><img src="https://i.loli.net/2018/02/27/5a9516de38c7e.png"></p>
<h2 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h2><p>信噪比是作为调制频率的 1KHz 音频信号的输出功率或电压与背景噪声的功率或电压之比，用分贝（ dB）表示。<br><img src="https://i.loli.net/2018/02/27/5a9516de40ee6.png"></p>
<h2 id="增益差"><a href="#增益差" class="headerlink" title="增益差"></a>增益差</h2><p>指测量扬声器左右通道信号幅度不等性。<br><img src="https://i.loli.net/2018/02/27/5a9516de414d7.png"></p>
<h2 id="耳机频响-耳机失真-耳机信噪比-耳机增益差"><a href="#耳机频响-耳机失真-耳机信噪比-耳机增益差" class="headerlink" title="耳机频响/耳机失真/耳机信噪比/耳机增益差"></a>耳机频响/耳机失真/耳机信噪比/耳机增益差</h2><p>HK8501方案耳机跟喇叭共用一路，所以耳机项目的这几个测试结果跟喇叭一样。</p>
<h2 id="AV-Out频响-失真-信噪比-增益差"><a href="#AV-Out频响-失真-信噪比-增益差" class="headerlink" title="AV Out频响/失真/信噪比/增益差"></a>AV Out频响/失真/信噪比/增益差</h2><p>HK8501方案AV Out跟喇叭/耳机硬件上不是同一路。。。</p>
<h2 id="AV-Out音频输出幅度"><a href="#AV-Out音频输出幅度" class="headerlink" title="AV Out音频输出幅度"></a>AV Out音频输出幅度</h2><p>带AV Out端子的板卡需要测试这一项目。【board_config.c】</p>
<h2 id="唇音同步"><a href="#唇音同步" class="headerlink" title="唇音同步"></a>唇音同步</h2><p>即声音图像同步（AV Sync）<br>Audio –&gt; Misc. -&gt; Lipsync：调整 AV Sync，范围为 -200ms~200ms<br>【app_data_setting.c】</p>
<h2 id="谐波失真"><a href="#谐波失真" class="headerlink" title="谐波失真"></a>谐波失真</h2><p>谐波失真是音频通道的非线性引起的正弦波信号的谐波分量。<br>。。。</p>
<h2 id="总谐波失真"><a href="#总谐波失真" class="headerlink" title="总谐波失真"></a>总谐波失真</h2><p>总谐波失真是输出信号谐波失真的有效值与总输出信号的有效值之比，用百分数表示。<br>。。。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>测量声音相关参数时需220V交流供电；</li>
<li>测试过程中，无特殊要求一般把声音参数设置为标准，环绕声关闭，相关音效处理功能关闭（特殊测试项目除外），这个在测试前需跟测试人员进行有效沟通；</li>
<li>AQ调试优先级说明：<ul>
<li>先调频响；</li>
<li>高低音&gt; 声音模式；</li>
<li>最大声音功率 &gt; 声音曲线 &gt; 失真度；</li>
<li>AVL、信噪比、分离度、增益差这几个一般在频响之后。</li>
</ul>
</li>
</ul>
<p>以上所有的曲线图仅参考，实际效果会因客户标准，板卡，功放，喇叭规格不同而存在差异。</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>rda</tag>
        <tag>audio</tag>
        <tag>aq</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Chromium的使用两则</title>
    <url>/2017/08/20/settle-chromium/</url>
    <content><![CDATA[<p>Chromium在WIN/Linux平台的一个配置。</p>
<span id="more"></span>

<h4 id="1、解决-Windows-中-Chromium-“缺少-GOOGLE-API-密钥”-和无法登陆账户的问题（转载）"><a href="#1、解决-Windows-中-Chromium-“缺少-GOOGLE-API-密钥”-和无法登陆账户的问题（转载）" class="headerlink" title="1、解决 Windows 中 Chromium “缺少 GOOGLE API 密钥” 和无法登陆账户的问题（转载）"></a>1、解决 Windows 中 Chromium “缺少 GOOGLE API 密钥” 和无法登陆账户的问题（转载）</h4><p>一打开 Chromium，地址栏下方就提示 “缺少 Google API 密钥，因此 Chromium 的部分功能将无法使用”。这直接导致了无法在 Chromium 登录 Google 账户并同步各种信息。  </p>
<p>打开 windows 的 CMD 命令提示符，依次输入以下命令： </p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">setx</span> GOOGLE_API_KEY <span class="string">"no"</span></span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_ID <span class="string">"no"</span></span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_SECRET <span class="string">"no"</span></span><br></pre></td></tr></tbody></table></figure>

<p>其实就是设置这样三个环境变量，值均为“no”。然而这样只是消除了哪行提示而已（对于没有 Google 账户的“良民”们，或许有用），Google 账户还是无法登录。  </p>
<p>在 Debian Jessie 为 Chromium 设置 PepperFlashPlayer 的时候，在 /etc/chromium.d 目录中看到一个 apikeys 文件。打开它，看到里面的内容如下： </p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># API keys assigned to Debian by Google for access to their services like sync and gmail.</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOOGLE_API_KEY</span>=”AIzaSyCkfPOPZXDKNn8hhgu3JrA62wIgC93d44k”</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOOGLE_DEFAULT_CLIENT_ID</span>=”811574891467.apps.googleusercontent.com”</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOOGLE_DEFAULT_CLIENT_SECRET</span>=”kdloedMFGdGla2P1zacGjAQh”</span><br></pre></td></tr></tbody></table></figure>

<p>这不就是设置环境变量吗？于是将上述文章中提到的环境变量按照这个 apikeys 文件中的值进行设置，即在 CMD 中执行： </p>
<figure class="highlight apache"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">setx</span> GOOGLE_API_KEY AIzaSyCkfPOPZXDKNn<span class="number">8</span>hhgu<span class="number">3</span>JrA<span class="number">62</span>wIgC<span class="number">93</span>d<span class="number">44</span>k</span><br><span class="line"><span class="attribute">setx</span> GOOGLE_DEFAULT_CLIENT_ID <span class="number">811574891467</span>.apps.googleusercontent.com</span><br><span class="line"><span class="attribute">setx</span> GOOGLE_DEFAULT_CLIENT_SECRET kdloedMFGdGla<span class="number">2</span>P<span class="number">1</span>zacGjAQh</span><br></pre></td></tr></tbody></table></figure>

<p>再尝试打开 Chromium，发现提示消失了，Google 账户也能登录了。</p>
<h4 id="2、解决-Mint-中-Chromium-弹窗-“Enter-password-for-keyring-‘Default-keyring’-to-unlock”-的问题"><a href="#2、解决-Mint-中-Chromium-弹窗-“Enter-password-for-keyring-‘Default-keyring’-to-unlock”-的问题" class="headerlink" title="2、解决 Mint 中 Chromium 弹窗 “Enter password for keyring ‘Default keyring’ to unlock” 的问题"></a>2、解决 Mint 中 Chromium 弹窗 “Enter password for keyring ‘Default keyring’ to unlock” 的问题</h4><p>桌面版 Mint 使用 Chromium 会弹窗提示 “Enter password for keyring ‘Default keyring’ to unlock” ，输入 Mint 密码弹窗消失，怎么才能在每次使用 Chromium 的时候让这个弹窗消失？  </p>
<p>关闭 Chromium ，命令行下运行 seahorse ，找到 Passwords -&gt; Default keyring ，右键选 Change Password ，把新密码改为空，重启系统。  </p>
<p>版本：Version 59.0.3071.109 (Developer Build) Built on Ubuntu , running on LinuxMint 18.2 (32-bit)</p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用记录</title>
    <url>/2017/04/16/ubuntu-omg/</url>
    <content><![CDATA[<p>记录一次Ubuntu初始化流程。</p>
<span id="more"></span>

<h3 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h3><ul>
<li>检查你的电脑有哪些显卡<br>lspci -k | grep -A 2 -i “VGA”  </li>
<li>查看Ubuntu正在使用哪块显卡<br>System Settings &gt; Details &gt; Overview  </li>
<li>查看哪一个专有驱动是推荐安装的<br>sudo ubuntu-drivers devices  </li>
<li>安装Nvidia专有显卡驱动<br>终端执行software-properties-gtk打开GUI或执行sudo apt-get install nvidia-375直接安装  </li>
<li>切换显卡<br>Dash中打开Nvidia X Server Settings或终端执行命令nvidia-settings，在PRIME Profiles切换  </li>
</ul>
<h3 id="系统基础配置"><a href="#系统基础配置" class="headerlink" title="系统基础配置"></a>系统基础配置</h3><ul>
<li>卸载多余的软件<br>sudo apt-get remove libreoffice-common<br>sudo apt-get remove unity-webapps-common<br>sudo apt-get remove totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-install onboard deja-dup imagemagick  </li>
<li>桌面布局<br>gsettings set org.compiz.unityshell:/org/compiz/profiles/unity/plugins/unityshell/ launcher-minimize-window true<br>gsettings set com.canonical.Unity.Launcher launcher-position Bottom  </li>
<li>更换源<br>sudo vim /etc/apt/sources.list<br>sudo apt-get update<br>sudo apt-get upgrade  </li>
<li>安装基础软件  <ul>
<li>通过源直接安装<br>sudo apt-get install vim<br>sudo apt-get install samba<br>sudo apt-get install chromium<br>sudo apt-get install screenfetch<br>sudo apt-get install git subversion vpnc<br>sudo apt-get install axel uget aria2<br>sudo apt-get install vlc<br>sudo apt-get install okular<br>sudo apt-get install kchmviewer<br>sudo apt-get install mediainfo mediainfo-gui<br>sudo add-apt-repository ppa:webupd8team/sublime-text-3<br>sudo apt-get update<br>sudo apt-get install sublime-text  </li>
<li>安装deb文件<br><a href="https://github.com/geeeeeeeeek/electronic-wechat">微信</a><br><a href="https://music.163.com/#/download">网易云音乐</a><br>sudo apt-get install libqgsttools-p1 libqt5multimedia5-plugins libqt5multimediawidgets5 libqt5libqgtk2<br>sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb<br><a href="https://pinyin.sogou.com/linux/?r=pinyin">搜狗输入法</a><br>sudo apt install libopencc1 fcitx fcitx-libs fcitx-libs-qt fonts-droid-fallback<br>sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb<br><a href="https://github.com/LiuLang/bcloud-packages">百度云盘</a><br>sudo apt-get install gnome-icon-theme-symbolic python3-crypto python3-pyinotify python3-keyring<br>sudo dpkg -i bcloud_3.8.2-1_all.deb<br><a href="https://github.com/getlantern/lantern">蓝灯</a><br>sudo dpkg -i lantern-installer-beta-64-bit.deb<br><a href="https://www.jianguoyun.com/s/downloads/linux">坚果云</a><br>sudo apt-get install python-gtk2 python-notify default-jre-headless<br>sudo dpkg -i nautilus_nutstore_amd64.deb<br><a href="https://community.wps.cn/download/">WPS</a><br>sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb  </li>
</ul>
</li>
<li><a href="https://wiki.ubuntu.org.cn/Gedit%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81">Gedit中文乱码</a><br>sudo apt-get install dconf-editor<br>运行dconf-editor<br>展开/org/gnome/gedit/preferences/encodings<br>Candidate Encodings的value配置为[‘GB18030’, ‘UTF-8’, ‘CURRENT’, ‘ISO-8859-15’, ‘UTF-16’]  </li>
</ul>
<h3 id="Jekyll环境"><a href="#Jekyll环境" class="headerlink" title="Jekyll环境"></a>Jekyll环境</h3><ul>
<li>sudo apt-get install ruby ruby-dev  </li>
<li>gem sources –remove <a href="https://rubygems.org/">https://rubygems.org/</a>  </li>
<li>gem sources -a <a href="https://ruby.taobao.org/">https://ruby.taobao.org/</a>  </li>
<li>gem sources -l  </li>
<li>sudo gem install jekyll bundler  </li>
<li>bundle install  </li>
<li><a href="https://jekyllcn.com/">build&amp;run</a></li>
</ul>
<h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><ul>
<li> <strong>在Linux Mint 18.3上执行sudo gem install jekyll报错：</strong></li>
</ul>
<blockquote>
<p>Building native extensions.  This could take a while…<br>ERROR:  Error installing jekyll:<br>   ERROR: Failed to build gem native extension.</p>
<p>  current directory: /var/lib/gems/2.3.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser<br>/usr/bin/ruby2.3 -r ./siteconf20180226-49726-1ijhpau.rb extconf.rb<br>creating Makefile</p>
<p>current directory: /var/lib/gems/2.3.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser<br>make “DESTDIR=” clean</p>
<p>current directory: /var/lib/gems/2.3.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser<br>make “DESTDIR=”<br>compiling ruby_http_parser.c<br>In file included from /usr/include/ruby-2.3.0/ruby/ruby.h:36:0,<br>                from /usr/include/ruby-2.3.0/ruby.h:33,<br>                from ruby_http_parser.c:1:<br>/usr/include/ruby-2.3.0/ruby/defines.h:26:19: fatal error: stdio.h: No such file or directory<br>compilation terminated.<br>Makefile:239: recipe for target ‘ruby_http_parser.o’ failed<br>make: *** [ruby_http_parser.o] Error 1</p>
<p>make failed, exit code 2</p>
<p>Gem files will remain installed in /var/lib/gems/2.3.0/gems/http_parser.rb-0.6.0 for inspection.<br>Results logged to /var/lib/gems/2.3.0/extensions/x86_64-linux/2.3.0/http_parser.rb-0.6.0/gem_make.out   </p>
</blockquote>
<p>解决方法：<br>sudo apt-get install build-essential patch ruby-dev zlib1g-dev liblzma-dev libsqlite3-dev</p>
<ul>
<li><strong>VMware Tools工具安装失败，无法复制粘贴（平台：Mint 18.3，VMware 11）</strong><blockquote>
<p>Makefile:120: recipe for target ‘vmhgfs.ko’ failed  </p>
</blockquote>
</li>
</ul>
<p>解决方法：</p>
<ol>
<li><p>Make sure the updates are done:<br>sudo apt-get update</p>
</li>
<li><p>Make sure git is installed<br>sudo apt-get install git</p>
</li>
<li><p>Run the command to get the tools from repository.<br>sudo git clone <a href="https://github.com/rasa/vmware-tools-patches.git">https://github.com/rasa/vmware-tools-patches.git</a></p>
</li>
<li><p>cd to vmware-tools-folder<br>cd vmware-tools-patches</p>
</li>
<li><p>Run the patch<br>sudo ./download-tools.sh</p>
</li>
<li><p>Run the following patch<br>sudo ./untar-and-patch.sh</p>
</li>
<li><p>Run the complie.sh file<br>sudo ./compile.sh<br><a href="https://communities.vmware.com/message/2665867?tstart=0">参考此贴</a></p>
</li>
</ol>
<ul>
<li><p><strong>Windows无法访问Samba服务器，访问被拒绝</strong><br>需要在Samba中创建用户。Ubuntu系统中的用户，和Samba用户是两回事，要将资源共享给系统中的某个用户，必须将该用户添加到Samba中。<a href="https://blog.sina.com.cn/s/blog_6c9d65a10100oobp.html">参考</a><br>用到的命令：smbpasswd。<a href="https://man.linuxde.net/smbpasswd">参考</a>  </p>
</li>
<li><p><strong>安装oh-my-zsh步骤</strong></p>
</li>
</ul>
<ol>
<li>sudo apt-get install zsh //安装</li>
<li>zsh –version //确认是否安装成功</li>
<li>sudo chsh -s $(which zsh) //设置zsh为默认shell</li>
<li>注销重新登录</li>
<li>echo $SHELL //确认zsh是否是默认SHELL</li>
<li>使用curl方式安装oh-my-zsh：sudo sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</a></li>
<li>配置：vim ~/.zshrc</li>
<li>若有中文乱码，再配置：export LANG=zh_CN.UTF-8</li>
<li>使配置生效：source ~/.zshrc</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>How to install and initialize Manjaro OS</title>
    <url>/2017/04/03/manjaro-install-and-initial-guide/</url>
    <content><![CDATA[<p>记录一次Manjaro安装流程。</p>
<span id="more"></span>

<h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>一、安装系统  </p>
<ol>
<li>df –&gt;确认U盘名称和路径  </li>
<li>umount sdb1 –&gt;卸载已挂载的U盘  </li>
<li>dd if=/home/manjaro-xfce-17.0-stable-x86_64.iso of=/dev/sdb –&gt;dd命令中的目标是sdb，没有标号  </li>
<li>install boot non-free –&gt;对于双显卡驱动，安装的时候boot选择non-free，如果boot default的话，装好系统以后也可以在设置里安装bumblebee  </li>
</ol>
<h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>二、系统初始配置  </p>
<ol>
<li>sudo pacman-mirrors -g –&gt;排列源  </li>
<li>sudo pacman-optimize&amp;&amp;sync –&gt;同步，碎片整理。固态硬盘不能用pacman-optimize  </li>
<li>sudo pacman -Syyu –&gt;升级系统  </li>
<li>sudo nano /etc/pacman.conf –&gt;添加ArchLinuxCN源  </li>
<li>sudo pacman -Syyu –&gt;同步  </li>
<li>sudo pacman -S archlinuxcn-keyring –&gt;导入GPG Key  </li>
</ol>
<h3 id="Basic-Tools"><a href="#Basic-Tools" class="headerlink" title="Basic Tools"></a>Basic Tools</h3><p>三、安装基础软件  </p>
<ol>
<li>sudo pacman -Syu yaourt –&gt;Archlinux的软件包管理工具是Pacman，而yaourt工具可以安装AUR(Archlinux官方不支持)的软件  </li>
<li>yaourt screenfetch –&gt;一个能够在终端显示系统/主题信息的命令行脚本  </li>
<li>yaourt vim –&gt;文本编辑工具  </li>
<li>yaourt lantern –&gt;科学上网工具  </li>
<li>yaourt sogou –&gt;搜狗输入法<br> 进入fcitx config gui异常，还需安装fcitx-configtool；<br> vim ~/.xprofile,添加<br> export GTK_IM_MODULE=fcitx<br> export QT_IM_MODULE=fcitx<br> export XMODIFIERS=”@im=fcitx”<br> 注销重新登录系统<br> 还是不行，执行fcitx -diagnose命令诊断，然后执行对应的修复  </li>
<li>yaourt uget –&gt;Firefox可以通过添加FlashGot插件把uget设置为其默认下载管理器  </li>
<li>yaourt qq –&gt;安装QQ  </li>
<li>yaourt netease –&gt;安装网易云音乐  </li>
<li>yaourt wechat –&gt;安装微信  </li>
<li>安装zsh<br>安装 zsh: sudo pacman -S zsh<br>配置 oh-my-zsh: sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</a><br>更换默认的 shell: chsh -s /bin/zsh<br>重启  </li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>把时间当作朋友</title>
    <url>/2017/03/06/be-frd-with-time/</url>
    <content><![CDATA[<p>2月份读完了《把时间当作朋友》这本书，现在才来记录，有点晚了。作者从心智的角度考虑问题，有种醍醐灌顶的感觉。</p>
<span id="more"></span>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>书本的章节编排：  </p>
<ol start="0">
<li>所有人的困境</li>
<li>心智的力量</li>
<li>开启自己的心智</li>
<li>通过管理自己与时间做朋友</li>
<li>开拓自己的心智</li>
<li>小心所谓“成功学”</li>
<li>更多思考</li>
<li>从此时此刻开始改变</li>
</ol>
<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><p>有一些章节的具体内容现在的我有点忘了，记录一下对我来说比较重要的观点，希望能提醒自己：</p>
<h4 id="1、你永远不是最痛苦的"><a href="#1、你永远不是最痛苦的" class="headerlink" title="1、你永远不是最痛苦的"></a>1、你永远不是最痛苦的</h4><p>针对这个观点作者专门有举例，令人印象深刻。</p>
<h4 id="2、坚持与策略"><a href="#2、坚持与策略" class="headerlink" title="2、坚持与策略"></a>2、坚持与策略</h4><p>这个我觉得有点难度，挑战实在不小。无论你定了多详尽的计划，总会有意外发生，尽管作者已经告诉我把意外当成计划的一部分。尽量像作者一样把计划按照一个星期一个星期的周期来完成吧。</p>
<h4 id="3、控制自己的大脑"><a href="#3、控制自己的大脑" class="headerlink" title="3、控制自己的大脑"></a>3、控制自己的大脑</h4><p>控制自己的大脑，而不是被自己的大脑控制，这就是心智力量的强大之处。这是我读这本书的最大收获。比如起床，不想起床是因为自己被大脑控制了，因为睡觉舒服，大脑想的是舒服，这不是我想的，我想的是起床做事，但是为什么还是起不来？因为大脑控制了我。我有这样的经验：第二天要是有重要的事情必须要按时起床的，临睡前心里面提醒自己明天几点一定要起床做什么事情，第二天往往都能准时起床。因为我控制了自己的大脑，我告诉大脑必须做什么事情，这件事是对我有益的。控制自己的大脑，开启心智强大力量的第一步！</p>
<h4 id="4、记录尴尬"><a href="#4、记录尴尬" class="headerlink" title="4、记录尴尬"></a>4、记录尴尬</h4><p>把自己生活或工作中尴尬的事情记录下来，偶尔看一下，对自己后来的处事态度和方式，都会有警示的作用。</p>
<h4 id="5、提前准备"><a href="#5、提前准备" class="headerlink" title="5、提前准备"></a>5、提前准备</h4><p>这个我不知道说什么好，道理都懂，却依然过不好这一生？多多反思吧！为什么没有提前准备，临时抱佛脚乱阵脚？这个应该还要从计划做起，有计划才有准备！当然，行动是前提！</p>
<h4 id="6、按时打盹，按时清醒"><a href="#6、按时打盹，按时清醒" class="headerlink" title="6、按时打盹，按时清醒"></a>6、按时打盹，按时清醒</h4><p>我觉得我很需要睡眠，如果要做到按时打盹按时清醒，是很需要环境配合的，这个不好执行。</p>
<h4 id="7、马上开始永远都不迟"><a href="#7、马上开始永远都不迟" class="headerlink" title="7、马上开始永远都不迟"></a>7、马上开始永远都不迟</h4><p>是的，所以我马上把购物车清空了。嘻嘻，开玩笑。</p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/1970/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
